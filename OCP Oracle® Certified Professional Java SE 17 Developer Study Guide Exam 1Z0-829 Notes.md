# Introduction

## Reviewing Question Types

**Questions with Extra Information** 
  Provided Imagine the question includes a statement that `XMLParseException` is a checked exception. It’s fine if you don’t know what an `XMLParseException` is or what XML is, for that matter. (If you are wondering, it is a format for data.) This question is a gift. You know the question is about exception handling.

**Questions with Embedded Questions**
  To answer some questions on the exam, you may have to answer two or three sub-questions. For example, the question may contain two blank lines and ask you to choose the two answers that fill in each blank. In some cases, the two answer choices are not related, which means you’re really answering multiple questions, not just one! These questions are among the most difficult and time-consuming on the exam because they contain multiple, often independent, questions to answer.

**Questions with Unfamiliar APIs**
  If you see a class or method that wasn’t covered in this book, assume that it works as you would expect. Assume that the part of the code using that API is correct, and look very hard for other errors.

**Questions That Are Really Out of Scope**
  When introducing new questions, Oracle includes them as unscored questions at first. This allows the exam creators to see how real exam takers do without impacting your score. You will still receive the number of questions the exam lists. However, a few of them may not count. These unscored questions may contain out-of- scope material or even errors. They will not be marked as unscored, so you still have to do your best to answer them. Follow the previous advice to assume that anything you haven’t seen before is correct. That will cover you if the question is being counted!


## How This Book Is Organized

The chapters are organized as follows:
- **Chapter 1: Building Blocks** 
	   describes the basics of Java, such as how to run a program. It covers variables such as primitives, object data types, and scoping variables. It also discusses garbage collection.
	   
- **Chapter 2: Operators** 
	 explains operations with variables. It also talks about casting and the precedence of operators.
	 
-  **Chapter 3: Making Decisions** 
	 covers core logical constructs such as decision statements, pattern matching, and loops.
	 
- **Chapter 4: Core APIs** 
	 works with String, StringBuilder, arrays, and dates.
	 
- **Chapter 5: Methods** 
	explains how to design and write methods. It also introduces access modifiers, which are used throughout the book.
	
- **Chapter 6: Class Design** 
	covers class structure, constructors, inheritance, and initialization. It also teaches you how to create abstract classes and overload methods.
	
- **Chapter 7: Beyond Classes** 
	introduces many top-level types (other than classes), including interfaces, enums, sealed classes, records, and nested classes. It also covers polymorphism.
	
- **Chapter 8: Lambdas and Functional Interfaces** 
	shows how to use lambdas, method references, and built-in functional interfaces.
	
- **Chapter 9: Collections and Generics** 
	demonstrates method references, generics with wildcards, and Collections. The Collections portion covers many common interfaces, classes, and methods that are useful for the exam and in everyday software development.
	
- **Chapter 10: Streams** 
	explains stream pipelines in detail. It also covers the Optional class. If you want to become skilled at creating streams, read this chapter more than once!
	
 - **Chapter 11: Exceptions and Localization** 
	 demonstrates the different types of exception classes and how to apply them to build more resilient programs. It concludes with localization and formatting, which allow your program to gracefully support multiple countries or languages.
	 
- **Chapter 12: Modules** 
	details the benefits of the new module feature. It shows how to compile and run module programs from the command line. Additionally, it describes services and how to migrate an application to a modular infrastructure.
	
-  **Chapter 13: Concurrency** 
	introduces the concept of thread life cycle and thread-safety. It teaches you how to build multithreaded programs using the Concurrency API and parallel streams.

- **Chapter 14: I/O** 
	introduces you to managing files and directories using the I/O and NIO.2 APIs. It covers a number of I/O stream classes, teaches you how to serialize data, and shows how to interact with a user. Additionally, it includes techniques for using streams to traverse and search the file system.
	
- **Chapter 15: JDBC** 
	provides the basics of working with databases in Java, including working with stored procedures and transactions.

At the end of each chapter
 - **Summary** 
	This section reviews the most important topics that were covered in the chapter and serves as a good review.

- **Exam Essentials** 
	This section summarizes highlights that were covered in the chapter.

- **Review Questions** 
	Each chapter concludes with at least 20 review questions. You should answer these questions and check your answers against the ones provided in the Appendix. If you can’t answer at least 80 percent of these questions correctly, go back and review the chapter,

## Identifying Your Weakest Link

The review questions in each chapter are designed to help you home in on those features of the Java language where you may be weak and that are required knowledge for the exam. For each chapter, you should note which questions you got wrong, understand why you got them wrong, and study those areas even more. After you’ve reread the chapter and written lots of code, you can do the review questions again
## Using the Provided Writing Material

After first checking whether the code compiles, it is time to understand what the program
does! One of the most useful applications of writing material is tracking the state of primitive
and reference variables. For example, let’s say you encountered the following code snippet on a question about garbage collection:

```java
Object o = new Turtle();
Mammal m = new Monkey();
Animal a = new Rabbit();
o = m;
```

In a situation like this, it can be helpful to draw a diagram of the current state of the variable
references. As each reference variable changes which object it points to, you erase or
cross out the arrow between them and draw a new one to a different object.
Using the writing material to track state is also useful for complex questions that involve
a loop, especially questions with embedded loops

## Understanding the Question

the number-one question we recommend that you answer before attempting to solve the question is this:

==***Does the code compile?***==

> If all of the answers to a question are printed values, aka there is no Does not compile option, consider that question a gift. It means every line does compile, and you may be able to use information from this question to answer other questions! #TIP

## Applying the Process of Elimination

Although you might not immediately know the correct answer to a question, if you can
reduce the question from five answers to three, your odds of guessing the correct answer are markedly improved.

In some cases, you may be able to eliminate answer choices without even reading the
question. If you come across such questions on the exam, consider it a gift.

1. Which line, when inserted independently at line m1, allows the code to compile?
-Code Omitted -

```java
A. public abstract final int swim();
B. public abstract void swim();
C. public abstract swim();
D. public abstract void swim() {}
E. public void swim() {}
```

B & E

## Skipping Difficult Questions

The exam software includes an option to “mark” a question and review all marked questions
at the end of the exam. If you are pressed for time, answer a question as best you can
and then mark it to come back to later.

All questions are weighted equally, so spending 10 minutes answering five questions correctly is a lot better use of your time than spending 10 minutes on a single question.

## Being Suspicious of Strong Words

Many questions on the exam include answer choices with descriptive sentences rather than
lines of code. When you see such questions, be wary of any answer choice that includes
strong words such as “**must**,” “**all**,” or “**cannot**.”

If you think about the complexities of programming languages, it is rare for a rule to have no exceptions or special cases. Therefore, ==if you are stuck between two answers and one of them uses “must” while the other uses “can” or “may,” you are better off picking the one with the weaker word since it is a more ambiguous statement.==

## Choosing the Best Answer

If you’re nearly out of time or you just can’t decide on an answer, select a random option and move on. If you’ve been able to eliminate even one answer choice, then your guess is better than blind luck.


|Chapter|Exam Objectives|
|---|---|
|1, 2, 4|Handling date, time, text, numeric, and boolean values. Use primitives and wrapper classes, including Math API, parentheses, type promotion, and casting to evaluate arithmetic and boolean expressions.|
|4|Manipulate text, including text blocks, using String and StringBuilder classes.|
|4|Manipulate date, time, duration, period, instant, and time-zone objects using Date-Time API.|
|3|Controlling Program Flow. Create program flow control constructs including if/else, switch statements and expressions, loops, and break and continue statements.|
|1, 7|Utilizing Java Object-Oriented Approach. Declare and instantiate Java objects, including nested class objects, and explain the object life-cycle, including creation, reassigning references, and garbage collection.|
|5, 6, 7|Create classes and records, and define and use instance and static fields and methods, constructors, and instance and static initializers. Implement overloading, including var-arg methods.|
|1, 6, 7, 8|Understand variable scopes, use local variable type inference, apply encapsulation, and make objects immutable.|
|3, 6, 7|Implement polymorphism and differentiate object type versus reference type. Perform type casting, identify object types using the instanceof operator and pattern matching.|
|7, 8|Create and use interfaces, identify functional interfaces, and utilize private, static, and default interface methods.|
|7|Create and use enumerations with fields, methods, and constructors.|
|11|Handling Exceptions. Handle exceptions using try/catch/finally, try-with-resources, and multi-catch blocks, including custom exceptions.|
|4, 9|Working with Arrays and Collections. Create Java arrays, List, Set, Map, and Deque collections, and add, remove, update, retrieve, and sort their elements.|
|10|Working with Streams and Lambda expressions. Use Java object and primitive Streams, including lambda expressions implementing functional interfaces, to supply, filter, map, consume, and sort data. Perform decomposition, concatenation and reduction, and grouping and partitioning on sequential and parallel streams.|
|12|Packaging and deploying Java code and use the Java Platform Module System. Define modules and their dependencies, expose module content including for reflection. Define services, producers, and consumers. Compile Java code, produce modular and non-modular jars, runtime images, and implement migration using unnamed and automatic modules.|
|13|Managing concurrent code execution. Create worker threads using Runnable and Callable, manage the thread lifecycle, including automations provided by different Executor services and concurrent API. Develop thread-safe code, using different locking mechanisms and concurrent API. Process Java collections concurrently, including the use of parallel streams.|
|14|Using Java I/O API. Read and write console and file data using I/O Streams. Serialize and de-serialize Java objects. Create, traverse, read, and write Path objects and their properties using java.nio.file API.|
|15|Accessing databases using JDBC. Create connections, create and execute basic, prepared and callable statements, process query results and control transactions using JDBC API.|
|11|Implementing Localization. Implement localization using locales, resource bundles, parse and format messages, dates, times, and numbers including currency and percentage values.|

## Assessment Test

1. What is the result of executing the following code snippet?

```java
41: final int score1 = 8, score2 = 3;
42: char myScore = 7;
43: var goal = switch (myScore) {
44: default -> { if (10 > score1) yield "unknown"; }
45: case score1 -> "great";
46: case 2, 4, 6 -> "good";
47: case score2, 0 -> { "bad"; }
48: };
49: System.out.println(goal);
```

- [ ] A. unknown
- [ ] B. great
- [ ] C. good
- [ ] D. bad
- [ ] E. unknowngreatgoodbad
- [ ] F. Exactly one line needs to be changed for the code to compile.
- [x] G. Exactly two lines need to be changed for the code to compile.
- [ ] H. None of the above

**The question does not compile because line 44 and line 47 do not always return a value**
**in the case block, which is required when a switch expression is used in an assignment**
**operation.** 
**Line 44 is missing a yield statement when the if statement evaluates to false,**
**while line 47 is missing a yield statement entirely.**

---

2. What is the output of the following code snippet?

```java
int moon = 9, star = 2 + 2 * 3;
float sun = star > 10 ? 1 : 3;
double jupiter = (sun + moon) - 1.0f;
int mars = --moon <= 8 ? 2 : 3;
System.out.println(sun + ", " + jupiter + ", " + mars);

```

- [ ] A. 1, 11, 2
- [x] B. 3.0, 11.0, 2
- [ ] C. 1.0, 11.0, 3
- [ ] D. 3.0, 13.0, 3
- [ ] E. 3.0f, 12, 2
- [ ] F. The code does not compile because one of the assignments requires an explicit numeric
- [ ] cast.

**The multiplication operator (*) has a higher order of precedence than the addition operator (+), so it gets evaluated first. Since star is not greater than 10, sun is assigned a value of 3, which is**
**promoted to 3.0f as part of the assignment. The value of jupiter is (3.0f + 9) -1.0, which is 11.0f.**

**This value is implicitly promoted to double when it is assigned. In the last assignment, moon is decremented from 9 to 8, with the value of the expression returned as 8. Since 8 less than or equal to 8 is true, mars is set to a value of 2. The final output is 3.0, 11.0, 2,**

**Note that while Java outputs the decimal for both float and double values, it does not output the f for float values**

---

3. Which changes, when made independently, guarantee the following code snippet prints 100 at
runtime? (Choose all that apply.)

```java
List<Integer> data = new ArrayList<>();
IntStream.range(0, 100)
         .parallel()
         .forEach(s -> data.add(s));
System.out.println(data.size());
```

- [ ] A. Change data to an instance variable and mark it volatile.
- [x] B. Remove parallel() in the stream operation.
- [x] C. Change forEach() to forEachOrdered() in the stream operation.
- [ ] D. Change parallel() to serial() in the stream operation.
- [x] E. Wrap the lambda body with a synchronized block.
- [ ] F. The code snippet will always print 100 as is.

My Answer : A, E

**The code may print 100 without any changes, but since the data class is not thread-safe,**
**this behavior is not guaranteed. For this reason, option F is incorrect. Option A is also**
**incorrect, as volatile does not guarantee thread-safety.**

**Options B and C are correct, as they both cause the stream to apply the add() operation in a synchronized manner. Option D is incorrect, as serial() is not a stream method. Option E is correct. Synchronization will cause each thread to wait so that the List is modified one element at a time**

---

4. What is the output of this code?
```java
20: Predicate<String> empty = String::isEmpty;
21: Predicate<String> notEmpty = empty.negate();
22:
23: var result = Stream.generate(() -> "")
24:               .filter(notEmpty)
25:               .collect(Collectors.groupingBy(k -> k))
26:               .entrySet()
27:               .stream()
28:               .map(Entry::getValue)
29:               .flatMap(Collection::stream)
30:               .collect(Collectors.partitioningBy(notEmpty));
31: System.out.println(result);
```

- [ ] A. It outputs {}.
- [ ] B. It outputs {false=[], true=[]}.
- [ ] C. The code does not compile.
- [x] D. The code does not terminate.

My Answer: A

**the source is an infinite stream. The filter operation will check each element in turn to see whether any are not empty. While nothing passes the filter, the code does not terminate.**

---

5. What is the result of the following program?

```java
1: public class MathFunctions {
2:     public static void addToInt(int x, int amountToAdd) {
3:         x = x + amountToAdd;
4:     }
5:     public static void main(String[] args) {
6:         var a = 15;
7:         var b = 10;
8:         MathFunctions.addToInt(a, b);
9:        System.out.println(a);
		}
	 }
```

- [ ] A. 10
- [x] B. 15
- [ ] C. 25
- [ ] D. Compiler error on line 3
- [ ] E. Compiler error on line 8
- [ ] F. None of the above

**The value of a cannot be changed by the `addToInt()` method, no matter what the method does, because only a copy of the variable is passed into the parameter x. Therefore, a does not change, and the output on line 9 is 15 which is option B.**

---


6. Suppose that we have the following property files and code. What values are printed on lines
8 and 9, respectively?
**Penguin.properties**
name=Billy
age=1
**Penguin_de.properties**
name=Chilly
age=4
**Penguin_en.properties**
name=Willy

```java
5: Locale fr = new Locale("fr");
6: Locale.setDefault(new Locale("en", "US"));
7: var b = ResourceBundle.getBundle("Penguin", fr);
8: System.out.println(b.getString("name"));
9: System.out.println(b.getString("age"));
```

- [ ] A. Billy and 1
- [ ] B. Billy and null
- [x] C. Willy and 1
- [ ] D. Willy and null
- [ ] E. Chilly and null
- [ ] F. The code does not compile.

My Answer: F

**Since there is no match for French, the default locale is used. Line 8 finds a matching**
**key in the Penguin_en.properties file. Line 9 does not find a match in the**
**Penguin_en.properties file; therefore, it has to look higher up in the hierarchy to**
**Penguin.properties. This makes option C the answer**

---

7. What is guaranteed to be printed by the following code? (Choose all that apply.)

``` java
int[] array = {6, 9, 8}; System.out.println("B" + Arrays.binarySearch(array, 9)); System.out.println("C" + Arrays.compare(array, new int[]{6, 9, 8})); System.out.println("M" + Arrays.mismatch(array, new int[]{6, 9, 8}));
```

- [ ] A. B1
- [ ] B. B2
- [ ] C. C-1
- [x] D. C0
- [x] E. M-1
- [ ] F. M0
- [ ] G. The code does not compile.

My Answer: A

**The array is allowed to use an anonymous initializer because it is in the same line as**
**the declaration. The results of the binary search are undefined since the array is not sorted.**
**Since the question asks about guaranteed output, options A and B are incorrect.**

**Option D is correct because the compare() method returns 0 when the arrays are the same**
**length and have the same elements. Option E is correct because the mismatch() method**
**returns a -1 when the arrays are equivalent.**

---

8. Which functional interfaces complete the following code, presuming variable r exists?
(Choose all that apply.)
```java
6: x =  r.negate();
7: y = () -> System.out.println();
8: z = (a, b) -> a - b;
```


- [ ] `A. BinaryPredicate<Integer, Integer>`
- [ ] `B. Comparable<Integer>`
- [x] `C. Comparator<Integer>`
- [ ] `D. Consumer<Integer>`
- [x] `E. Predicate<Integer>`
- [x] `F. Runnable`
- [ ] `G. Runnable<Integer>`

My Answer: C, D

**note that option A is incorrect because the interface should be BiPredicate**
**and not BinaryPredicate. Line 6 requires you to know that negate() is a convenience**
**method on Predicate. This makes option E correct. Line 7 takes zero parameters and**
**doesn’t return anything, making it a Runnable. Remember that Runnable doesn’t use**
**generics. This makes option F correct. Finally, line 8 takes two parameters and returns an**
**int. Option C is correct. Comparable is there to mislead you since it takes only one parameter**
**in its single abstract method**

---

9. Suppose you have a module named com.vet. Where could you place the following
module-info.
java file to create a valid module?

```java
public module com.vet {
	exports com.vet;
}
```

- [ ] A. At the same level as the com folder
- [ ] B. At the same level as the vet folder
- [ ] C. Inside the vet folder
- [x] D. None of the above

My Answer: A

**If this were a valid module-info. java file, it would need to be placed at the root directory of the module, which is option A. However, a module is not allowed to use the public access modifier.**

---

10. What is the output of the following program? (Choose all that apply.)

```java
1: interface HasTail { private int getTailLength(); }
2: abstract class Puma implements HasTail {
3: String getTailLength() { return "4"; }
4: }
5: public class Cougar implements HasTail {
6: public static void main(String[] args) {
7: var puma = new Puma() {};

8: System.out.println(puma.getTailLength());
9: }
10: public int getTailLength(int length) { return 2; }
11: }
```

- [ ] A. 2
- [ ] B. 4
- [x] C. The code will not compile because of line 1.
- [ ] D. The code will not compile because of line 3.
- [ ] E. The code will not compile because of line 5.
- [ ] F. The code will not compile because of line 7.
- [ ] G. The code will not compile because of line 10.
- [ ] H. The output cannot be determined from the code provided.

My Answer: D, E

**The getTailLength() method in the interface is private; therefore, it must include**
**a body. For this reason, line 1 is the only line that does not compile and option C is correct.**
**Line 3 uses a different return type for the method, but since it is private in the interface, it**
**is not considered an override. Note that line 7 defines an anonymous class using the abstract**  **Puma parent class**



---

11. Which lines in Tadpole.java give a compiler error? (Choose all that apply.)

```java
// Frog.java
1: package animal;
2: public class Frog {
3: protected void ribbit() { }
4: void jump() { }
5: }
// Tadpole.java
1: package other;
2: import animal.*;
3: public class Tadpole extends Frog {
4: public static void main(String[] args) {
5: Tadpole t = new Tadpole();
6: t.ribbit();
7: t.jump();
8: Frog f = new Tadpole();
9: f.ribbit();
10: f.jump();
11: } }
```

- [ ] A. Line 5
- [ ] B. Line 6
- [x] C. Line 7
- [ ] D. Line 8
- [x] E. Line 9
- [x] F. Line 10
- [ ] G. All of the lines compile.

My Answer: G

**The jump() method has package access, which means it can be accessed only**
**from the same package. Tadpole is not in the same package as Frog, causing lines 7**
**and 10 to trigger compiler errors**

**The ribbit() method has protected access, which means it can only be accessed from a subclass reference or in the same package. Line 6 is fine because Tadpole is a subclass. Line 9 does not compile and our final answer is option E because the variable reference is to a Frog, which doesn’t grant access to the protected method**

---

12. Which of the following can fill in the blanks in order to make this code compile?
"_________"a  ="_________" .getConnection( url, userName, password);
"___________" b = a.prepareStatement(sql);
"________" c = b.executeQuery();
if (c.next()) System.out.println(c.getString(1));

- [x] `A. Connection, Driver, PreparedStatement, ResultSet`
- [ ] `B. Connection, DriverManager, PreparedStatement, ResultSet`
- [ ] `C. Connection, DataSource, PreparedStatement, ResultSet`
- [ ] `D. Driver, Connection, PreparedStatement, ResultSet`
- [ ] `E. DriverManager, Connection, PreparedStatement, ResultSet`
- [ ] `F. DataSource, Connection, PreparedStatement, ResultSet`

My Answer: B

**DataSource isn’t on the exam, so any question containing one is wrong. The key variables**
**used in running a query are Connection, PreparedStatement, and ResultSet.**
**A Connection is obtained through a DriverManager, making option B correct**

---

13. Which of the following statements can fill in the blank to make the code compile successfully?
(Choose all that apply.)

```java
Set<? extends RuntimeException> mySet = new ??? ();
```

- [ ] `A. HashSet<? extends RuntimeException>`
- [ ] `B. HashSet<Exception>`
- [x] `C. TreeSet<RuntimeException>`
- [x] `D. TreeSet<NullPointerException>`
- [ ] `E. None of the above`

My Answer: A, C

**The mySet declaration defines an upper bound of type RuntimeException.**
**This means that classes may specify RuntimeException or any subclass of**
**RuntimeException as the type parameter**

**Option A is incorrect because the wildcard cannot occur on the right side of the assignment**

---

14. Assume that birds.dat exists, is accessible, and contains data for a Bird object. What is
the result of executing the following code? (Choose all that apply.)

```java
1: import java.io.*;
2: public class Bird {
3: private String name;
4: private transient Integer age;
5:
6: // Getters/setters omitted
7:
8: public static void main(String[] args) {
9: try(var is = new ObjectInputStream(
10: new BufferedInputStream(
11: new FileInputStream("birds.dat")))) {
12: Bird b = is.readObject();
13: System.out.println(b.age);
14: } } }
```

- [ ] A. It compiles and prints 0 at runtime.
- [ ] B. It compiles and prints null at runtime.
- [ ] C. It compiles and prints a number at runtime.
- [x] D. The code will not compile because of lines 9–11.
- [x] E. The code will not compile because of line 12.
- [ ] F. It compiles but throws an exception at runtime.

My Answer: A, B

**Line 10 includes an unhandled checked `IOException`, while line 11 includes an**
**unhandled checked `FileNotFoundException`, making option D correct. Line 12 does not**
**compile because `is.readObject()` must be cast to a Bird object to be assigned to b. It**
**also does not compile because it includes two unhandled checked exceptions, `IOException`**
**and `ClassNotFoundException`, making option E correct. If a cast operation were added**
**on line 12 and the main() method were updated on line 8 to declare the various checked**

**exceptions, the code would compile but throw an exception at runtime since Bird does not**
**implement Serializable. Finally, if the class did implement Serializable, the program**
**would print null at runtime, as that is the default value for the transient field age.**

---

15. Which of the following are valid instance members of a class? (Choose all that apply.)
- [ ] `A. var var = 3;`
- [ ] `B. Var case = new Var();`
- [x] `C. void var() {}`
- [ ] `D. int Var() { var _ = 7; return _;}`
- [ ] `E. String new = "var";`
- [ ] `F. var var() { return null; }`

My Answer:  B, F

**Option A is incorrect because var is only allowed as a type for local variables, not instance**
**members. Options B and E are incorrect because new and case are reserved words**
**and cannot be used as identifiers. Option C is correct, as var can be used as a method name.**
**Option D is incorrect because a single underscore (_) cannot be used as an identifier. Finally,**
**option F is incorrect because var cannot be specified as the return type of a method**

---

16. Which is true if the table is empty before this code is run? (Choose all that apply.) 

```java
var sql = "INSERT INTO people VALUES(?, ?, ?)";
conn.setAutoCommit(false);
try (var ps = conn.prepareStatement(sql,
ResultSet.TYPE_SCROLL_SENSITIVE,
ResultSet.CONCUR_UPDATABLE)) {
ps.setInt(1, 1);
ps.setString(2, "Joslyn");
ps.setString(3, "NY");
ps.executeUpdate();
Savepoint sp = conn.setSavepoint();
ps.setInt(1, 2);
ps.setString(2, "Kara");
ps.executeUpdate();
conn. ??? ;
}
```

- [x] A. If the blank line contains rollback(), there are no rows in the table.
- [ ] B. If the blank line contains rollback(), there is one row in the table.
- [ ] C. If the blank line contains rollback(sp), there are no rows in the table.
- [x] D. If the blank line contains rollback(sp), there is one row in the table.
- [ ] E. The code does not compile.
- [ ] F. The code throws an exception because the second update does not set all the parameters.

My Answer:  B

**JDBC will use the existing parameter**
**set if you don’t replace it. This means Kara’s row will be set to use NY as the third parameter.**
**Rolling back to a savepoint throws out any changes made since. This leaves Joslyn and**
**eliminates Kara, making option D correct. Rolling back without a savepoint brings us back**
**to the beginning of the transaction, which is option A**

---

17. Which is true if the contents of path1 start with the text Howdy? (Choose two.)

```java
System.out.println(Files.mismatch(path1,path2));
```

- [ ] A. If path2 doesn’t exist, the code prints -1.
- [ ] B. If path2 doesn’t exist, the code prints 0.
- [x] C. If path2 doesn’t exist, the code throws an exception.
- [x] D. If the contents of path2 start with Hello, the code prints -1.
- [ ] E. If the contents of path2 start with Hello, the code prints 0.
- [ ] F. If the contents of path2 start with Hello, the code prints 1.

My Answer: C, D

**Option C is correct as mismatch() throws an exception if the files do not exist unless**
**they both refer to the same file. Additionally, option F is correct because the first index that**
**differs is returned, which is the second character. Since Java uses zero-based**
**indexes, this is 1.**

---

18. Which of the following types can be inserted into the blank to allow the program to compile successfully? (Choose all that apply.)

```java
1: import java.util.*;
2: final class Amphibian {}
3: abstract class Tadpole extends Amphibian {}
4: public class FindAllTadpoles {
5: public static void main(String... args) {
6: var tadpoles = new ArrayList<Tadpole>();
7: for (var amphibian : tadpoles) {
8:  ??? tadpole = amphibian;
9: } } }
```

- [ ] `A. List<Tadpole>`
- [ ] `B. Boolean`
- [ ] `C. Amphibian`
- [ ] `D. Tadpole`
- [ ] `E. Object`
- [x] `F. None of the above`

**The Amphibian class is marked final, which means line 3 triggers a compiler error and**
**option F is correct.**

---

19. What is the result of compiling and executing the following program?

```java
1: public class FeedingSchedule {
2: public static void main(String[] args) {
3: var x = 5;
4: var j = 0;

5: OUTER: for (var i = 0; i < 3;)
6: INNER: do {
7: i++;
8: x++;
9: if (x> 10) break INNER;
10: x += 4;
11: j++;
12: } while (j <= 2);
13: System.out.println(x);
14: } }
```

- [ ] A. 10
- [ ] B. 11
- [x] C. 12
- [ ] D. 17
- [ ] E. The code will not compile because of line 5.
- [ ] F. The code will not compile because of line 6.

My Answer: 11

**On the first iteration of the outer loop, i is 0, so the loop continues.**
- **On the first iteration of the inner loop, i is updated to 1 and x to 6. The if statement**
**branch is not executed, and x is increased to 10 and j to 1.**
- **On the second iteration of the inner loop (since j = 1 and 1 <= 2), i is updated to 2**
**and x to 11. At this point, the if branch will evaluate to true for the remainder of**
**the program run, which causes the flow to break out of the inner loop each time it**
**is reached.**
- **On the second iteration of the outer loop (since i = 2), i is updated to 3 and x to 12. As**
**before, the inner loop is broken since x is still greater than 10.**
- **On the third iteration of the outer loop, the outer loop is broken, as i is already not less**
**than 3. The most recent value of x, 12, is output, so the answer is option C.**

---

20. When printed, which String gives the same value as this text block?

```java
var pooh = """
"Oh, bother." -Pooh
""".indent(1);
System.out.print(pooh);
```

- [ ] `A. "\n\"Oh, bother.\" -Pooh\ n"`
- [ ] `B. "\n \"Oh, bother.\" -Pooh\ n"`
- [x] `C. " \"Oh, bother.\" -Pooh\ n"`
- [ ] `D. "\n\"Oh, bother.\" -Pooh"`
- [ ] `E. "\n \"Oh, bother.\" -Pooh"`
- [ ] `F. " \"Oh, bother.\" -Pooh"`
- [ ] `G. None of the above`

My Answer: G

**First, note that the text block has the closing """ on a separate line, which means there**
**is a new line at the end and rules out options D, E, and F. Additionally, text blocks don’t**
**start with a new line, ruling out options A and B**

---

21. A(n) ???  module always contains a module-info. java file, while a(n) ??? module always exports all its packages to other modules.

- [ ] A. automatic, named
- [ ] B. automatic, unnamed
- [x] C. named, automatic
- [ ] D. named, unnamed
- [ ] E. unnamed, automatic
- [ ] F. unnamed, named
- [ ] G. None of the above

**Only named modules are required to have a module-info. java file, ruling out options**
**A, B, E, and F. Unnamed modules are not readable by any other types of modules, ruling**
**out option D. Automatic modules always export all packages to other modules, making the**
**answer option C.**

---

22. What is the result of the following code?
```java
22: var treeMap = new TreeMap<Character, Integer>();
23: treeMap.put('k', 1);
24: treeMap.put('k', 2);
25: treeMap.put('m', 3);
26: treeMap.put('M', 4);
27: treeMap.replaceAll((k, v) -> v + v);
28: treeMap.keySet()
29: .forEach(k ->
System.out.print(treeMap.get(k)));
```


- [ ] A. 268
- [ ] B. 468
- [ ] C. 2468
- [ ] D. 826
- [x] E. 846
- [ ] F. 8246
- [ ] G. None of the above

My Answer: G

**When the same key is put into a Map, it overrides the original value. This means that line**
**23 could be omitted and the code would be the same, and there are only three key/value**
**pairs in the map. TreeMap sorts its keys, making the order M followed by k followed by m.**
**Remember that natural sort ordering has uppercase before lowercase. The replaceAll()**
**method runs against each element in the map, doubling the value**

---

23. Which of the following lines can fill in the blank to print true? (Choose all that apply.)

```java
10: public static void main(String[] args) {
11: System.out.println(test( ??? ));
12: }
13: private static boolean test(Function<Integer, Boolean> b) {
14: return b.apply(5);
15: }
```

- [ ] `A. i::equals(5)`
- [ ] `B. i -> {i == 5;}`
- [x] `C. (i) -> i == 5`
- [ ] `D. (int i) -> i == 5`
- [ ] `E. (int i) -> {return i == 5;}`
- [x] `F. (i) -> {return i == 5;}`

**A looks like a method reference. However, it doesn’t call a valid method, nor**
**can method references take parameters. The Predicate interface takes a single parameter**
**and returns a boolean. Lambda expressions with one parameter are allowed to omit**
**the parentheses around the parameter list, making option C correct.**

**The return statement**
**is optional when a single statement is in the body, making option F correct. Option**
**B is incorrect because a return statement must be used if braces are included around the**
**body. Options D and E are incorrect because the type is Integer in the predicate and int**
**in the lambda. Autoboxing works for collections, not inferring predicates. If these two were**
**changed to Integer, they would be correct.**

---

24. How many times is the word true printed?

```java
var s1 = "Java";
var s2 = "Java";
var s3 = s1.indent(1).strip();
var s4 = s3.intern();
var sb1 = new StringBuilder();
sb1.append("Ja").append("va");


System.out.println(s1 == s2);
System.out.println(s1.equals(s2));
System.out.println(s1 == s3);
System.out.println(s1 == s4);
System.out.println(sb1.toString() == s1);
System.out.println(sb1.toString().equals(s1));
```

- [ ] A. Once
- [ ] B. Twice
- [ ] C. Three times
- [x] D. Four times
- [ ] E. Five times
- [ ] F. The code does not compile.

My Answer: B

**String literals are used from the string pool. This means that s1 and s2 refer to the**
**same object and are equal. Therefore, the first two print statements print true. While the**
**indent() and strip() methods create new String objects and the third statement prints**
**false, the intern() method reverts the String to the one from the string pool. Therefore,**
**the fourth print statement prints true. The fifth print statement prints false because**
**toString() uses a method to compute the value, and it is not from the string pool. The**
**final print statement again prints true because equals() looks at the values of String**
**objects**

---

25. What is the output of the following program?

```java
1: class Deer {
2: public Deer() {System.out.print("Deer");}
3: public Deer(int age) {System.out.print("DeerAge");}
4: protected boolean hasHorns() { return false; }
5: }
6: public class Reindeer extends Deer {
7: public Reindeer(int age) {System.out.print("Reindeer");}
8: public boolean hasHorns() { return true; }
9: public static void main(String[] args) {
10: Deer deer = new Reindeer(5);
11: System.out.println("," + deer.hasHorns());
12: } }
```

- [ ] A. ReindeerDeer,false
- [ ] B. DeerAgeReindeer,true
- [x] C. DeerReindeer,true
- [ ] D. DeerReindeer,false
- [ ] E. ReindeerDeer,true
- [ ] F. DeerAgeReindeer,false
- [ ] G. The code will not compile because of line 4.
- [ ] H. The code will not compile because of line 12.

My Answer: B

**The Reindeer object is instantiated using the constructor that takes an int value. Since**
**there is no explicit call to the parent constructor, the compiler inserts super() as the first**
**line of the constructor on line 7. The parent constructor is called, and Deer is printed on line**
2. **The flow returns to the constructor on line 7, with Reindeer being printed. Next, the**
**hasHorns() method is called. The reference type is Deer, and the underlying object type**
**is Reindeer. Since Reindeer correctly overrides the hasHorns() method, the version in**
**Reindeer is called, with line 11 printing ,true. Therefore, option C is correct**

---

26. Which of the following are true? (Choose all that apply.)

```java
private static void magic(Stream<Integer> s) {
Optional o = s
.filter(x ->
x < 5)
.limit(3)
.max((x, y) ->
x-y);
System.out.println(o.get());
}
```

- [ ] `A. magic(Stream.empty()); runs infinitely.`
- [x] `B. magic(Stream.empty()); throws an exception.`
- [ ] `C. magic(Stream.iterate(1, x -> x++)); runs infinitely.`
- [ ] `D. magic(Stream.iterate(1, x -> x++)); throws an exception.`
- [ ] `E. magic(Stream.of(5, 10)); runs infinitely.`
- [x] `F. magic(Stream.of(5, 10)); throws an exception.`
- [ ] `G. The method does not compile.`

My Answer: D, F

**Calling get() on an empty Optional causes an exception to be thrown, making**
**option B correct. Option F is also correct because filter() makes the Optional empty**
**before it calls get(). Option C is incorrect because the infinite stream is made finite by the**
**intermediate limit() operation. Options A and E are incorrect because the source streams**
**are not infinite.**

---

27. Assuming the following declarations are top-level types declared in the same file, which successfully compile? (Choose all that apply.)

```java
record Music() {
final int score = 10;
}
record Song(String lyrics) {
Song {
this.lyrics = lyrics + "Hello World";
}
}
sealed class Dance {}
record March() {
@Override String toString() { return null; }
}
class Ballet extends Dance {}
```

- [ ] A. Music
- [ ] B. Song
- [x] C. Dance
- [ ] D. March
- [ ] E. Ballet
- [ ] F. None of them compile.

**Music does not compile because records cannot include instance variables not listed in**
**the declaration of the record, as it could break immutability. Song does not compile because**
**a compact constructor cannot set an instance variable. The record would compile if this**
**were removed from the compact constructor, as compact constructors can modify input**
**parameters. March does not compile because it is an invalid override; it reduces the visibility**
**of the toString() method from public to package access. Ballet does not compile**
**because the subclass of a sealed class must be marked final, sealed, or non-sealed.**
**Since the only one that compiles is Dance, option C is the answer.**

---

28. Which of the following expressions compile without error? (Choose all that apply.)

- [ ] `A. int monday = 3 + 2.0;`
- [x] `B. double tuesday = 5_6L;`
- [ ] `C. boolean wednesday = 1 > 2 ? !true;`
- [x] `D. short thursday = (short)Integer.MAX_VALUE;`
- [ ] `E. long friday = 8.0L;`
- [ ] `F. var saturday = 2_.0;`
- [ ] `G. None of the above`

My Answer: E, F

**Option A does not compile, as the expression 3 + 2.0 is evaluated as a double,**
**and a double requires an explicit cast to be assigned to an int. Option B compiles without**
**issue, as a long value can be implicitly cast to a double. Option C does not compile**
**because the ternary operator (? :) is missing a colon (:), followed by a second expression.**
**Option D is correct. Even though the int value is larger than a short, it is explicitly cast to**
**a short, which means the value will wrap around to fit in a short. Option E is incorrect,**
**as you cannot use a decimal (.) with the long (L) postfix. Finally, option F is incorrect, as an**
**underscore cannot be used next to a decimal point.**

---

29. What is the result of executing the following application?

```java
final var cb = new CyclicBarrier(3,
() ->
System.out.println("Clean!")); // u1
ExecutorService service = Executors.newSingleThreadExecutor();
try {
IntStream.generate(() ->
1)
.limit(12)
.parallel()
.forEach(i ->
service.submit(() ->
cb.await())); // u2
} finally { service.shutdown(); }
```

- [ ] A. It outputs Clean! at least once.
- [ ] B. It outputs Clean! exactly four times.
- [ ] C. The code will not compile because of line u1.
- [ ] D. The code will not compile because of line u2.
- [ ] E. It compiles but throws an exception at runtime.
- [x] F. It compiles but waits forever at runtime.

**The code compiles without issue. The key to understanding this code is to notice that our**
**thread executor contains only one thread, but our CyclicBarrier limit is 3. Even though**
**12 tasks are all successfully submitted to the service, the first task will block forever on the**
**call to await(). Since the barrier is never reached, nothing is printed, and the program**
**hangs, making option F correct.**

---

30.  Which statement about the following method is true?

```java
5: public static void main(String... unused) {
6: System.out.print("a");
7: try (StringBuilder reader = new StringBuilder()) {
8: System.out.print("b");
9: throw new IllegalArgumentException();
10: } catch (Exception e || RuntimeException e) {
11: System.out.print("c");
12: throw new FileNotFoundException();
13: } finally {
14: System.out.print("d");
15: } }
```

- [ ] A. It compiles and prints abc.
- [ ] B. It compiles and prints abd.
- [ ] C. It compiles and prints abcd.
- [ ] D. One line contains a compiler error.
- [ ] E. Two lines contain a compiler error.
- [x] F. Three lines contain a compiler error.
- [ ] G. It compiles but prints an exception at runtime.

My Answer: C

**Line 5 does not compile as the FileNotFoundException thrown on line 12 is not handled**
**or declared by the method. Line 7 does not compile because StringBuilder does not**
**implement AutoCloseable and is therefore not compatible with a try-with- resource**
**statement. Finally, line 10 does not compile as RuntimeException is a subclass of Exception**
**in the multi-catch block, making it redundant. Since this method contains three compiler**
**errors, option F is the correct answer.**

---

# Chapter 1 - Building Blocks #Chapter

## Learning about the Environment

### Major Components of Java

The Java Development Kit (JDK) contains the minimum software you need to do Java development. Key commands include:

- ==**`javac`: Converts .java source files into .class bytecode**==
- ==**`java`: Executes the program**==
- ==**`jar`: Packages files together**==
- ==**`javadoc`: Generates documentation==**

The `javac` program generates instructions in a special format called bytecode that the java command can run.
Then java launches the Java Virtual Machine (JVM) before running the code The JVM knows how to run bytecode on the actual machine it is on. think of the JVM as a special magic box on your machine that knows how to run your .class file within your particular operating system and hardware.

---

**Where Did the JRE Go?**

In Java 8 and earlier, you could download a Java Runtime Environment (JRE) instead of the full JDK. The JRE was a subset of the JDK that was used for running a program but could not compile one.

Now, people can use the full JDK when running a Java program. Alternatively, developers can supply an executable that contains the required pieces that would have been in the JRE.

When writing a program, there are common pieces of functionality and algorithms that developers need. Java comes with a large suite of application programming interfaces (APIs) that you can use.

For example, there is a `StringBuilder` class to create a large `String` and a method in `Collections` to sort a list. When writing a program, it is helpful to determine what pieces of your assignment can be accomplished by existing APIs.

---
## Understanding the Class Structure

In Java programs, classes are the basic building blocks. When defining a class, you describe all the parts and characteristics of one of those building blocks.

To use most classes, you have to create objects.  ==**An object is a runtime instance of a class in memory.**== An object is often referred to as an instance since it represents a single representation of the class.

All the various objects of all the different classes represent the state of your program. ==**A reference is a variable that points to an object.**==
### Fields and Methods

Java classes have ==**two primary elements**==: 
- **==methods==, often called functions or procedures in other languages,** 
- **==fields==, more generally known as variables.** 
Together these are called the members of the class. Variables hold the state of the program, and methods operate on that state. If the change is important to remember, a variable stores that change.

The simplest Java class you can write looks like this:

```java
1: public class Animal {
2: }
```

Line 1 includes the `public` keyword, which allows other classes to use it. The `class` keyword indicates you’re defining a class. ``Animal`` gives the name of the class.

```java
1: public class Animal {
	2: String name;
3: }
```

On line 2, we define a variable named name. We also declare the type of that variable to be `String`.

```java
1: public class Animal {
	2: String name;
	3: public String getName() {
		4: return name;
	5: }
	6: public void setName(String newName) {
		7: name = newName;
	8: }
9: }
```

The `setName()` method has one parameter named `newName`, and it is of type ``String``. This means the caller should pass in one `String` parameter and expect nothing to be returned.

==**The method name and parameter types are called the method signature.**==

```java
public int numberVisitors(int month) {
	return 10;
}
```

The method name is `numberVisitors`. There’s one parameter named ``month``, which is of type `int`, which is a numeric type. the method signature is **`numberVisitors(int).`**

---
- **Most of the time, each Java class is defined in its own .java file.**  
-  **==A top-level class is often ``public``==, which means any code can call it.**  
-  **==If you do have a ``public`` type, it needs to match the filename.==**


```java  
/*public */ class AnimalV2 { // ONLY AnimalV2 class can be public in this source file.  
    private String name;  
}  
  
class Animal2 {  
}  
  
// public class Animal3{} // Compile Error
```

-  **You can even put two types in the same file.**  
-  **When you do so, at most one of the top-level types in the file is allowed to be ``public``.**

---
### Comments

Another common part of the code is called a comment. Because comments aren’t executable code, you can place them in many places. Comments can make your code easier to read.

There are three types of comments in Java.  
**single-line comment**:

```java
// comment until end of line
```

A single-line comment begins with two slashes. The compiler ignores anything you type after that on the same line. 
**multiple-line comment**

```java
/* Multiple
* line comment
*/
```

A multiple-line comment includes anything starting from the symbol ``/* until the symbol  * /``.
**Javadoc comment**

```go
/**
* Javadoc multiple-line
comment
* @author Jeanne and Scott
*/
```

This comment is similar to a multiline comment, except it starts with `/**`.   This special syntax tells the Javadoc tool to pay attention to the comment. Javadoc comments have a specific structure that the Javadoc tool knows how to read.

```java
/*
* // anteater
*/
// bear
// // cat
// /* dog */
/* elephant */
/*
* /* ferret */
*/
```

The line with ferret is interesting in that it doesn’t compile. Everything from the first /* to the first */ is part of the comment which means the compiler sees something like this:  `/* * /  */` There is an extra `*/`. That’s not valid syntax
### Classes and Source Files

Most of the time, each Java class is defined in its own .java file.  A top-level type is a data structure that can be defined independently within a source file. **==A top-level class is often `public`, which means any code can call it. Interestingly, Java does not require that the type be `public`==**

```java
1: class Animal {
	2: String name;
3: }
```

You can even put two types in the same file. When you do so, ==**at most one of the top-level types in the file is allowed to be public**==

```java
1: public class Animal {
	2: private String name;
3: }
4: class Animal2 {} 
```

==**If you do have a public type, it needs to match the filename**. The declaration ``public class Animal2`` would not compile in a file named **`Animal.java`**.==
## Writing a `main()` Method

A Java program begins execution with its `main()` method.  The `main()` method is often called an entry point into the program, because it is the starting point that the JVM looks for when it begins running a new program.
### Creating a ``main()`` Method

```java
1: public class Zoo {
2: public static void main(String[] args) { 
3: System.out.println("Hello World");
4: }
5: }
```

To compile and execute this code, type it into a file called`` Zoo.java`` and execute the following:

```shell
javac Zoo.java
java Zoo
```

To compile Java code with the `javac` command, the file must have the extension ``.java``. The name of the file must match the name of the public class.  The result is a file of bytecode with the same name but with a .class filename extension.

To keep things simple for now, we follow this subset of the rules:
- ==**Each file can contain only one public class.**==
- ==**The filename must match the class name, including case, and have a .java extension.**==
- ==**If the Java class is an entry point for the program, it must contain a valid main() method.**==

review the words in the `main()` method’s signature, one at a time. 

- ==**The keyword `public` is what’s called an access modifier. It declares this method’s level of exposure to potential callers in the program. Naturally, ``public`` means full access from anywhere in the program.**==

- ==**The keyword `static` binds a method to its class so it can be called by just the class name  Java doesn’t need to create an object to call the ``main()`` method**== 

- ==**The keyword `void` represents the return type. A method that returns no data returns control to the caller silently.  In general, it’s good practice to use `void` for methods that change an object’s state. In that sense, the `main()` method changes the program state from started to finished.**==

- ==**Finally, the `main()` method’s parameter list, represented as an array of `java.lang.String` objects. can use any valid variable name along with any of these three formats:**==

- ==**`String[] args`**==
- ==**`String options[]`**==
- ==**`String... friends`**==

The variable name args is common because it hints that this list contains values that were read in (arguments) when the JVM started.

---
**Optional Modifiers in ``main()`` Methods** #TIP

While most modifiers, such as ``public`` and ``static``, are required for ``main()`` methods, there are some optional modifiers allowed.

```java
public final static void main(final String[] args) {}
```

both **final** modifiers are optional, and the ``main()`` method is a valid entry point with or without them.

---
### Passing Parameters to a Java Program

```java
public class Zoo {
	public static void main(String[] args) {
		System.out.println(args[0]);
		System.out.println(args[1]);
	}
}
```

The code ``args[0]`` accesses the first element of the array.
To run:
```bash
javac Zoo.java
java Zoo Bronx Zoo
```

The output: 

```
Bronx
Zoo
```

The program correctly identifies the first two “words” as the arguments. Spaces are used to separate the arguments. **==want spaces inside an argument, you need to use quotes==**

```shell
javac Zoo.java
java Zoo "San Diego" Zoo
```

what happens if you don’t pass in enough arguments?

```shell
javac Zoo.java
java Zoo Zoo
```

Reading args[0] goes fine, and Zoo is printed out. Then Java panics. There’s no second argument! Java prints out an exception telling you it has no idea what to do with this argument at position 1.

```java
Zoo
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException:
Index 1 out of bounds for length 1
at Zoo.main(Zoo.java:4)
```

To review, the JDK contains a compiler. Java class files run on the JVM and therefore run on any machine with Java rather than just the machine or operating system they happened to have been compiled on.

---

**Single-File Source-Code**

```shell
java Zoo.java Bronx Zoo
```

There is a key difference here. When compiling first, you omitted the .java extension when running java. When skipping the explicit compilation step, you include this extension. This feature is called launching single-file source-code programs and is useful for testing or for small programs.

---
## Understanding Package Declarations and Imports

Java comes with thousands of built-in classes, and there are countless more from developers. With all those classes, Java needs a way to organize them. It handles this in a way similar to a file cabinet. Java puts classes in packages. These are logical groupings for classes. Java needs you to tell it which packages to look in to find code.

```java
public class NumberPicker {
	public static void main(String[] args) {
		Random r = new Random(); // DOES NOT COMPILE
		System.out.println(r.nextInt(10));
	}
}
```

the output: 

```java
error: cannot find symbol
```

This error could mean you made a typo in the name of the class. The other cause of this error is omitting a needed `import` statement. A statement is an instruction, and ``import`` statements tell Java which packages to look in for classes. Since you didn’t tell Java where to look for `Random`, it has no clue.

```java
import java.util.Random; // import tells us where to find Random
	public class NumberPicker {
		public static void main(String[] args) {
			Random r = new Random();
			System.out.println(r.nextInt(10)); // a number 0-9
		}
}
```
### Packages
Java classes are grouped into packages. The `import` statement tells the compiler which package to look in to find a class. ==**Java only looks for class names in the package.**== Package names are hierarchical. The rule for package names is that they are mostly letters or numbers separated by periods `(.)`. Technically, you’re allowed a couple of other characters between the periods` (.)`.
### Wildcards

**==Classes in the same package are often imported together==**. You can use a shortcut to import all the classes in a package.

```java
import java.util.*; // imports java.util.Random among other things
	public class NumberPicker {
		public static void main(String[] args) {
			Random r = new Random();
			System.out.println(r.nextInt(10));
		}
}
```

The `*` is a wildcard that matches all classes in the package.  Every class in the` java.util` package
is available to this program when Java compiles it. ==**The `import` statement doesn’t bring in child packages, fields, or methods; it imports only classes directly under the package**==

Example to use the class `AtomicInteger`

```java
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
```

Only the last import allows the class to be recognized because child packages are not included with the first two.
Might think that including so many classes slows down your program execution, but it doesn’t. The compiler figures out what’s actually needed.

- Listing the classes used makes the code easier to read
- Using the wildcard can shorten the import list.
### Redundant Imports

==**There’s one special package in the Java world called `java.lang`. This package is special in that it is automatically imported.**==

```java
1: import java.lang.System;
2: import java.lang.*;
3: import java.util.Random;
4: import java.util.*;
5: public class NumberPicker {
	6: public static void main(String[] args) {
		7: Random r = new Random();
		8: System.out.println(r.nextInt(10));
	9: }
10: }
```

How many of the imports do you think are redundant?  The answer is that three of the imports are redundant. Lines 1 and 2 are redundant because everything in `java.lang` is automatically imported. Line 4 is also redundant in this example because ``Random`` is already imported from `java.util.Random`

Another case of redundancy involves importing a class that is in the same package as the class importing it. Java automatically looks in the current package for other classes.

```java
public class InputImports {
	public void read(Files files) {
		Paths.get("name");
	}
}
```

Which import statements do you think would work to get this code to compile?
There are two possible answers. The shorter one is to use a wildcard to import both at the same time.

```java
import java.nio.file.*;
```

The other answer is to import both classes explicitly.

```java
import java.nio.file.Files;
import java.nio.file.Paths;
```

Some imports that don't work

```java
import java.nio.*; // NO GOOD -a wildcard only matches class names, not "file.Files"
import java.nio.*.*; // NO GOOD -you can only have one wildcard  and it must be at the end
import java.nio.file.Paths.*; // NO GOOD -you cannot import methods only class names
```
### Naming Conflicts

One of the reasons for using packages is so that class names don’t have to be unique across all of Java. This means you’ll sometimes want to import a class that can be found in multiple places. A common example of this is the Date class. Java provides implementations of `java.util.Date` and `java.sql.Date`. What import statement can we use if we want the `java.util.Date` version?

```java
public class Conflicts {
	Date date;
	// some more code
}
```

write either  `import java.util.*;` or  `import java.util.Date;`

The tricky cases come about when other imports are present. 

```java
import java.util.*;
import java.sql.*; // causes Date declaration to not compile
```

When the class name is found in multiple packages, Java gives you a compiler error.

```java
import java.util.Date;
import java.sql.*;
```

now it works! If you explicitly import a class name, it takes precedence over any wildcards present. 

 **==If you specifically mention the name of a class when importing in programming, it's more important than using a general import with a wildcard `(*)`. The specific import has priority.==**

What does Java do with “ties” for precedence? 

```java
import java.util.Date;
import java.sql.Date;
```

Java is smart enough to detect that this code is no good. As a programmer, you’ve claimed to explicitly want the default to be both the `java.util.Date` and` java.sql.Date` implementations. **==Because there can’t be two defaults, the compiler tells you the imports are ambiguous.==**

---
**If You Really Need to Use Two Classes with the Same Name**

you can pick one to use in the import statement and use the other’s fully qualified class name. Or you can drop both import statements and ==**always use the fully qualified class name.**==

```java
public class Conflicts {
	java.util.Date date;
	java.sql.Date sqlDate;
}
```

---
### Creating a New Package

**The default package**. This is a special unnamed package that you should use only for throwaway code. You can tell the code is in the default package, because there’s no package name. In real life, always name your packages to avoid naming conflicts and to allow others to reuse your code.

```java
package packageb;
import packagea.ClassA; // Bold
public class ClassB {
	public static void main(String[] args) {
		ClassA a; // Bold
		System.out.println("Got it");
	}
}
```

When you run a Java program, Java knows where to look for those package names.
### Ordering Elements in a Class

Comments can go anywhere in the code.

| **Element**                    | **Example**               | **Required?** | **Where does it go?**                                          |
| ------------------------------ | ------------------------- | ------------- | -------------------------------------------------------------- |
| **Package declaration**        | **`package abc;`**        | **No**        | **First line in the file (excluding comments or blank lines)** |
| **Import statements**          | **`import java.util.*;`** | **No**        | **Immediately after the package (if present)**                 |
| **Top-level type declaration** | **`public class C`**      | **Yes**       | **Immediately after the import (if any)**                      |
| **Field declarations**         | **`int value;`**          | **No**        | **Any top-level element within a class**                       |
| **Method declarations**        | **`void method()`**       | **No**        | **Any top-level element within a class**                       |
**A Few Example**
**Good**

```java
package structure; // package must be first non-comment
import java.util.*; // import must come after package
public class Meerkat { // then comes the class
	double weight; // fields and methods can go in either order
	public double getWeight() {
		return weight; 
	}
	double height; // another field -they don't need to be together
}
```

```java
/* header */
package structure;
// class Meerkat
public class Meerkat { }
```

**Bad**
```java
import java.util.*;
package structure; // DOES NOT COMPILE
String name; // DOES NOT COMPILE
public class Meerkat { } // DOES NOT COMPILE
```

There are two problems here. One is that the package and import statements are reversed. Although both are optional, package must come before `import` if present. The other issue is that a field attempts a declaration outside a class. This is not allowed. Fields and methods must be within a class.
## Creating Objects

### Calling Constructors

To create an instance of a class, all you have to do is write ``new`` before the class name and add parentheses after it.

```java
Park p = new Park();
```

First you declare the type that you’ll be creating (`Park`) and give the variable a name (`p`). This gives Java a place to store a reference to the object.  Then you write `new Park()` to actually create the object.

`Park()` looks like a method since it is followed by parentheses. It’s called a **constructor**, which is a special type of method that creates a new object.

```java
public class Chick {
	public Chick() {
		System.out.println("in constructor");
	}
}
```

==***There are two key points to note about the constructor:***==
- ==***the name of the constructor matches the name of the class***==
- ==***there’s no return type***==

```java
public class Chick {
	public void Chick() { } // NOT A CONSTRUCTOR
}
```

==**When you see a method name beginning with a capital letter and having a return type,**==
==**pay special attention to it. It is not a constructor since there’s a return type. It’s a regular**==
==**method that does compile but will not be called when you write new `Chick()`.**== #TIP 

The purpose of a constructor is to initialize fields,  Another way to initialize fields is to do so directly on the line on which they’re declared.

```java
public class Chicken {
	int numEggs = 12; // initialize on line
	String name;
	public Chicken() {
		name = "Duke"; // initialize in constructor
	}
}
```

For most classes, the compiler will supply a “do nothing” default constructor for you.
### Reading and Writing Member Fields

It’s possible to read and write instance variables directly from the caller.

```java
public class Swan {
	int numberEggs; // instance variable
	public static void main(String[] args) {
		Swan mother = new Swan();
		mother.numberEggs = 1; // set variable
		System.out.println(mother.numberEggs); // read variable
	}
}
```

can even read values of already initialized fields on a line initializing a new field:

```java
1: public class Name {
	2: String first = "Theodore"; // Write
	3: String last = "Moose"; // Write
	4: String full = first + last; // Read
5: }
```
### Executing Instance Initializer Blocks

The code between the braces (sometimes called “inside the braces”) is called a code block. Anywhere you see braces is a code block. Sometimes code blocks are inside a method. These are run when the method is called.
Other times, ==**code blocks appear outside a method. These are called instance initializers.**==

```java
1: public class Bird { // Class Definition
	2: public static void main(String[] args) { // Method Declaration
		3: { System.out.println("Feathers"); } // Inner Block
	4: }
	5: { System.out.println("Snowy"); } // Instance initializer
6: }
```

There are four code blocks in this example: a class definition, a method declaration, an inner block, and an instance initializer.

When you’re counting ==**instance initializers cannot exist inside of a method**==. Line 5 is an instance initializer, with its braces outside a method.
### Following the Order of Initialization

This is simply the order in which different methods, constructors, or blocks are called when an instance of the class is created.

| Order No. | Order of Initialization            | Description                                                                                      | Simple Example                                   |
|-----------|-------------------------------------|--------------------------------------------------------------------------------------------------|--------------------------------------------------|
| 1         | Static Variables Initialization | Static variables are initialized first, either at the time of declaration or in a static block.  | `static int staticVariable = 42;`                |
| 1         | Static Initialization Blocks    | Static initialization blocks are executed in the order they appear in the class after static variable initialization. | ```static { /* initialization code */ }``` |
| 2         | Instance Variables Initialization | Instance variables are initialized next, either at the time of declaration or in an instance initialization block. | `int instanceVariable = 10;`                     |
| 2         | Instance Initialization Blocks | Instance initialization blocks are executed in the order they appear in the class after instance variable initialization, just before the constructor is invoked. | ```java { /* initialization code */ }```        |
| 3         | Constructor Execution           | Finally, the constructor of the class is executed, allowing specific instance-level initialization tasks to be performed. | ```java public MyClass() { /* constructor code */ }``` |

- ==**Fields and instance initializer blocks are run in the order in which they appear in the file.**==
- ==**The constructor runs after all fields and instance initializer blocks have run.**==

```java
1: public class Chick {
	2: private String name = "Fluffy";
	3: { System.out.println("setting field"); }
	4: public Chick() {
		5: name = "Tiny";
		6: System.out.println("setting constructor");
	7: }
	8: public static void main(String[] args) {
		9: Chick chick = new Chick();
		10: System.out.println(chick.name); } 
	}
}
```

the output: 

```java
setting field
setting constructor
Tiny
```

start with the `main()` method because that’s where Java starts execution. On line 9, we call the constructor of ``Chick``. Java creates a new object. First it initializes name to ``Fluffy`` on line 2. Next it executes the `println()` statement in the instance initializer on line 3. Once all the fields and instance initializers have run, Java returns to the constructor. Line 5 changes the value of name to ``Tiny``, and line 6 prints another statement.

Order matters for the fields and blocks of code. You can’t refer to a variable before it has been defined:

```java
{ System.out.println(name); } // DOES NOT COMPILE
private String name = "Fluffy";
```

**Example**
```java
public class Egg {
	public Egg() {
		number = 5;
	}
	public static void main(String[] args) {
		Egg egg = new Egg();
		System.out.println(egg.number);
	}
	private int number = 3;
	{ number = 4; } 
}

```

Fields and blocks are run first in order, setting number to 3 and then 4. Then the constructor runs, setting number to 5.
## Understanding Data Types

Java applications contain two types of data: **==primitive==** types and **==reference==** types.
### Using Primitive Types

Java has eight built-in data types, referred to as the Java primitive types. These eight data types represent the building blocks for Java objects, because all Java objects are just a complex collection of these primitive data types.  A primitive is not an object in Java, nor does it represent an object. A primitive is just a single value in memory, such as a number or character.
### The Primitive Types

| Keyword  | Type                      | Min Value                   | Max Value                   | Default Value               | Example    |
|----------|---------------------------|-----------------------------|-----------------------------|-----------------------------|------------|
| boolean  | true or false              | n/a                         | n/a                         | false                       | true       |
| byte     | 8-bit integral value       | -128                        | 127                         | 0                           | 123        |
| short    | 16-bit integral value      | -32,768                     | 32,767                      | 0                           | 123        |
| int      | 32-bit integral value      | -2,147,483,648              | 2,147,483,647               | 0                           | 123        |
| long     | 64-bit integral value      | -9,223,372,036,854,775,808  | 9,223,372,036,854,775,807   | 0L                          | 123L       |
| float    | 32-bit floating-point value| n/a                         | n/a                         | 0.0f                        | 123.45f    |
| double   | 64-bit floating-point value| n/a                         | n/a                         | 0.0                         | 123.456   |
| char     | 16-bit Unicode value       | 0                           | 65,535                      | '\u0000'                    | 'a'        |

some key points:

- ==**The ``byte``, ``short``, ``int``, and ``long`` types are used for integer values without decimal** **points.**==

- ==**Each numeric type uses twice as many bits as the smaller similar type. For example,** ``short`` uses twice as many bits as ``byte`` does.**==

- ==**All of the numeric types are signed and reserve one of their bits to cover a negative** **range.**==

- ==**A ``float`` requires the letter f or F following the number so Java knows it is a ``float``. Without an f or F, Java interprets a decimal value as a ``double``.**==

- ==**``long`` requires the letter l or L following the number so Java knows it is a long.Without an l or L, Java interprets a number without a decimal point as an int in most** **scenarios.**==

---
**Signed and Unsigned: short and char**

For the exam, you should be aware that ``short`` and ``char`` are closely related, as both are stored as integral types with the same 16-bit length. ==**The primary difference is that ``short`` is signed, which means it splits its range across the positive and negative integers. Alternatively, char is unsigned, which means its range is strictly positive, including 0.**==

Often, short and char values can be cast to one another because the underlying data size is the same.

---
### Writing Literals

When a number is present in the code, it is called a literal. By default, Java assumes you are defining an int value with a numeric literal. In the following example, the number listed is bigger than what fits in an int.

```java
long max = 3123456789; // DOES NOT COMPILE
```

Java complains the number is out of range. And it is—for an ``int``. However, we don’t have an ``int``. The solution is to add the character `L` to the number:

```java
long max = 3123456789L; // Now Java knows it is a long
```

Another way to specify numbers is to change the `base.`  Java allows you to specify digits in several other formats:

- ==**Octal (digits 0–7), which uses the number 0 as a prefix—for example, 017.**==
-  ==**Hexadecimal (digits 0–9 and letters A–F/a–f), which uses 0x or 0X as a prefix—for example, 0xFF, 0xff, 0XFf. Hexadecimal is case insensitive, so all of these examples mean the same value.**==
-  ==**Binary (digits 0–1), which uses the number 0 followed by b or B as a prefix—for example, 0b10, 0B10.**==

### Literals and the Underscore Character

you can have underscores in numbers to make them easier to read:

```java
int million1 = 1000000;
int million2 = 1_000_000;
```

==**You can add underscores anywhere except at the beginning of a literal, the end of a literal, right before a decimal point, or right after a decimal point.**==

```java
double notAtStart = _1000.00; // DOES NOT COMPILE
double notAtEnd = 1000.00_; // DOES NOT COMPILE
double notByDecimal = 1000_.00; // DOES NOT COMPILE
double annoyingButLegal = 1_00_0.0_0; // Ugly, but compiles
double reallyUgly = 1__________2; // Also compiles
```
### Using Reference Types

**A reference type refers to an object (an instance of a class). Unlike primitive types that hold their values in the memory where the variable is allocated, ==references do not hold the value of the object they refer to. Instead, a reference “points” to an object by storing the memory address where the object is located, a concept referred to as a pointer.==**

```java
String greeting;
```

The greeting variable is a reference that can only point to a ``String`` object. A value assigned to a reference in one of two ways:

- ==**A reference can be assigned to another object of the same or compatible type.**==
- ==**A reference can be assigned to a new object using the ``new`` keyword.**==

```java
greeting = new String("How are you?");
```

The greeting reference points to a new String object, *"How are you?"*. The String object does not have a name and can be accessed only via a corresponding reference.
### Distinguishing between Primitives and Reference Types

There are a few important differences between primitives and reference types.

- ==**First, notice that all the primitive types have lowercase type names. All classes that come with Java begin with uppercase. Although not required, it is a standard practice, and you should follow this convention for classes you create as well.**==

- ==**Next, reference types can be used to call methods, assuming the reference is not ``null``. Primitives do not have methods declared on them.**==

  ```java
  String reference = "hello";
  int len = reference.length();
  int bad = len.length(); // DOES NOT COMPILE
```

Primitives do not have methods.

- ==**Finally, reference types can be assigned `null`, which means they do not currently refer to an object. Primitive types will give you a compiler error if you attempt to assign them `null`.**==

```java
int value = null; // DOES NOT COMPILE
String name = null;
```

### Creating Wrapper Classes

Each primitive type has a wrapper class, which is an object type that corresponds to the primitive.

| Primitive Type | Wrapper Class | Inherits Number? | Example of Creating |
|-----------------|---------------|-------------------|----------------------|
| boolean         | Boolean       | No                | `Boolean.valueOf(true)` |
| byte            | Byte          | Yes               | `Byte.valueOf((byte) 1)` |
| short           | Short         | Yes               | `Short.valueOf((short) 1)` |
| int             | Integer       | Yes               | `Integer.valueOf(1)` |
| long            | Long          | Yes               | `Long.valueOf(1)` |
| float           | Float         | Yes               | `Float.valueOf((float) 1.0)` |
| double          | Double        | Yes               | `Double.valueOf(1.0)` |
| char            | Character     | No                | `Character.valueOf('c')` |

There is also a `valueOf()` variant that converts a String into the wrapper class.

```java
int primitive = Integer.parseInt("123"); // Primitive Type - int
Integer wrapper = Integer.valueOf("123"); // Object Type - Integer
```

All of the numeric classes extend the ``Number`` class, which means they all come with some useful helper methods: `byteValue(), shortValue(), intValue(), longValue(), floatValue()`, and `doubleValue()`. The ``Boolean`` and ``Character`` wrapper classes include `booleanValue()` and `charValue()`, respectively. ==**These methods return the primitive value of a wrapper instance**==, in the type requested.

```java
Double apple = Double.valueOf("200.99");
System.out.println(apple.byteValue()); // -56
System.out.println(apple.intValue()); // 200
System.out.println(apple.doubleValue()); // 200.99
```

These helper methods do their best to convert values but can result in a loss of precision. 
### Defining Text Blocks

What if we want to have a String with something more complicated?

```java
"Java Study Guide"
by Scott & Jeanne
```

Building this as a ``String`` requires two things The syntax `\"` lets you say you want a " rather than to end the ``String``, and `\n` says you want a new line. Both of these are called escape characters because the backslash provides a special meaning

```java
String eyeTest = "\"Java Study Guide\"\n by Scott & Jeanne";
```

While this does work, it is hard to read. Luckily, Java has text blocks, also known as multiline strings.

![[Pasted image 20240111141502.png]]

A text block starts and ends with three double quotes `(""")`, and the contents don’t need to be escaped. This is much easier to read.

==**In Java text blocks, use triple quotes `(""")` on separate lines above and below your text. Only the text between these lines becomes the Java String.**==

==**Essential whitespace is the intentional indentation and formatting that directly contributes to the structure and readability of your String. Incidental whitespace, on the other hand, is extra spacing added for code readability, but it doesn't affect the actual ``String`` value.**== 

```java
String textblock = """
                   This is a text inside a
                   text block.
                   You can use "quotes" in here
                   without escaping them.
                   """;
```

You can freely adjust incidental whitespace without impacting your ``String`` content. ==**Visualize a vertical line on the leftmost non-whitespace character in your text block – everything to the left is incidental whitespace, and everything to the right is essential whitespace.**== Adjusting the left side won't change your ``String``; it's there solely for code aesthetics.

==**the difference in the start location of the last triple quotes `(""")` and the leftmost character of the text inside the text block determines how much indentation is left inside the Java String produced by the Java text block declaration.**==

```java
14: String pyramid = """
15: *
16: * *
17: * * *
18: """;
19: System.out.print(pyramid);
```

The closing `"""` on line 18 are the leftmost characters, so the line is drawn at the leftmost position

| Formatting                     | Meaning in Regular String | Meaning in Text Block    |
|--------------------------------|---------------------------|--------------------------|
| `\"`                           | `"`                       | `"`                      |
| `\"""` (Invalid)               | n/a - Invalid             | n/a - Invalid            |
| `\"\"\"`                       | n/a - Invalid             | `"""`                    |
| Space (at end of line)          | Space                     | Ignored                  |
| `\s` (Two spaces)              | Two spaces                | Two spaces (preserves leading space on the line) |
| `\` (at end of line, Invalid)   | n/a - Invalid             | Omits new line on that line (Invalid in a text block) |

**Examples**

```java
String block = """doe"""; // DOES NOT COMPILE
```

**==Text blocks require a line break after the opening ``""",`` making this one invalid==**

```java
String block = """
doe \
deer""";
```

How many lines ?  Just one. The output is doe deer since the \ tells Java not to add a new line before deer.

```java
String block = """
doe \n
deer
""";
```

This time we have four lines. Since the text block has the closing `"""` on a separate line,
we have three lines for the lines in the text block plus the explicit `\n`.

1. "doe " (ends with a space)
2. "deer" (no newline character here)
3. "" (empty line due to the closing `"""`)

---
```java
public static void main(String[] args) {  
  
  
    // Since Java 15, text blocks are available as a standard feature.  
    // A text block starts and ends with three double quotes ("""), and the contents don’t need to be escaped.  
    String textBlocks1 = """  
            Hello TextBlocks            """;  
  
    System.out.println("----textBlock1----");  
    System.out.println(textBlocks1);  
  
    String textBlocks2 = """  
                line1            """;  
  
    System.out.println("----textBlock2----");  
    System.out.println(textBlocks2);  
  
  
    String textBlocks3 = """  
                        line1            """;  
    System.out.println("----textBlock3----");  
    System.out.println(textBlocks3);  
  
  
    String textBlocks4 = """  
            line1                                """;  
  
    System.out.println("----textBlock4----");  
    System.out.println(textBlocks4);  
  
    String textBlocks5 = """  
                line1            line2                """;  
  
    System.out.println("----textBlock5----");  
    System.out.println(textBlocks5);  
  
    String textBlocks6 = """  
                line1            line2         """;  
  
    System.out.println("----textBlock6----");  
    System.out.println(textBlocks6);  
  
    String textBlocks7 = """  
                line1            line2               line3                        line4      """;  
  
    System.out.println("----textBlock7----");  
    System.out.println(textBlocks7);  
  
    String textBlocks8 = """  
                "line1"            "line2"                "line3"                    "line4"         """;  
  
    System.out.println("----textBlock8----");  
    System.out.println(textBlocks8);  
  
    String textBlocks9 = """  
                \"line1\"            \"line2\"                \"line3\"                    \"line4\"                """;  
  
    System.out.println("----textBlock9----");  
    System.out.println(textBlocks9);  
  
}
```

**the output**

```java
----textBlock1----
Hello TextBlocks

----textBlock2----
    line1

----textBlock3----
            line1

----textBlock4----
line1

----textBlock5----
    line1
line2

----textBlock6----
       line1
   line2

----textBlock7----
    line1
line2
   line3
            line4
----textBlock8----
       "line1"
   "line2"
       "line3"
           "line4"

----textBlock9----
    "line1"
"line2"
    "line3"
        "line4"
```

```java
public class DefiningTextBlockFormatting {  
  
    public static void main(String[] args) {  
  
        String textBlock1 = """  
                    \"sample"                """;  
  
        System.out.println(textBlock1);  
  
        String textBlock2 = """  
                    \"""line1"                """;  
  
        System.out.println(textBlock2);  
  
        String textBlock3 = """  
                    \"\"\"line1"                """;  
  
        System.out.println(textBlock3);  
  
  
        String textBlock4 = """  
                    \\\\\\line1"                """;  
  
        System.out.println(textBlock4);  
  
        String textBlock5 = """  
                \s\s\sline1                """;  
  
        System.out.println(textBlock5);  
  
        String textBlock6 = """  
                line1 \                    line1-part2 \                  line1-part3                """;  
  
        System.out.println(textBlock6);  
  
    }  
}

```

**the output**

```java
"sample"

    """line1"

    """line1"

    \\\line1"

   line1

line1     line1-part2   line1-part3
```

---
## Declaring Variables

A variable is a name for a piece of memory that stores data. When you declare a variable, you need to state the variable type along with giving it a name. Giving a variable a value is called initializing a variable. To initialize a variable, you just type the variable name followed by an equal sign, followed by the desired value

```java
String zooName = "The Best Zoo";
```

## Identifying Identifiers

An identifier is the name of a variable, method, class, interface, or package.

There are only four rules to remember for legal identifiers:
1. ==**Begin with a letter, currency symbol, or _ symbol:**== Identifiers must start with a letter `(a-z or A-Z)`, a currency symbol `(e.g., $, ¥, €)`, or an underscore `(_)`.
    
2. ==**Include numbers but not start with them:**== While identifiers can include numbers, they must not begin with a number.
    
3. ==**Single underscore _ is not allowed:**== Using a single underscore by itself as an identifier is not allowed.
    
4. ==**Avoid Java reserved words:**== Identifiers cannot have the same name as Java reserved words. Reserved words are special words in the Java language that have predefined meanings and cannot be used as identifiers.

* The reserved words `const` and `goto` aren’t actually used in Java. They are reserved so that people coming from other programming languages don’t use them by accident

- There are other names that you can’t use. For example, **`true`**, **`false`**, and **`null`** are literal values, so they can’t be variable names. Additionally, there are contextual keywords like **`module`**

**LEGAL**

```java
long okidentifier;
float $OK2Identifier;
boolean _alsoOK1d3ntifi3r;
char __SStillOkbutKnotsonice$;

int _a;  
int $c;  
int ______2_w;  
int _$;  
int this_is_a_very_detailed_name_for_an_identifier;

int ¥Ⅻ₤$ώ   = 100;  
// https://www.rapidtables.com/code/text/unicode-characters.html
```

**NOT LEGAL**

```java
int 3DPointClass; // identifiers cannot begin with a number
byte hollywood@vine; // @ is not a letter, digit, $ or _
String *$coffee; // * is not a letter, digit, $ or _
double public; // public is a reserved word
short _; // a single underscore is not allowed

int :b;  
int -d;  
int e#;  
int .f;  
int 7g;
```
## Declaring Multiple Variables

can also declare and initialize multiple variables in the same statement.

```java
void sandFence() {
	String s1, s2;
	String s3 = "yes", s4 = "no";
}
```

Four ``String`` variables were declared: s1, s2, s3, and s4. ==**You can declare many variables**== ==**in the same declaration as long as they are all of the same type**==

```java
void paintFence() {
	int i1, i2, i3 = 0;
}
```

three variables were declared: i1, i2, and i3. However, only one of those values was initialized: i3. The other two remain declared but not yet initialized.  ==**That’s the trick. Each snippet separated by a comma is a little declaration of its own**==. The initialization of i3 only applies to i3. It doesn’t have anything to do with i1 or i2 despite being in the same statement.

```java
int num, String value; // DOES NOT COMPILE
```

```java
4: boolean b1, b2;
5: String s1 = "1", s2;
6: double d1, double d2;
7: int i1; int i2;
8: int i3; i4;
```

- **Legal Declarations:**
    
    - Lines 4 and 5 are legal. Line 4 declares two ``boolean`` variables, and Line 5 declares a String variable (`s1`) and another uninitialized ``String`` variable (`s2`).
- **Legal, but Uncommon:**

    - Line 7 is legal. It declares two ``int`` variables (`i1` and `i2`) in separate statements on the same line, separated by a semicolon.
- **Illegal Declarations:**
    
    - Line 6 is not legal. Java doesn't allow the declaration of two different types in the same statement, even if the types are the same (e.g., `double d1, double d2`).
    - Line 8 is not legal. It contains an oddly placed semicolon. To analyze, consider separating the code into individual lines and checking for valid declarations.

==**In summary, for multiple variable declarations in the same line, variables must share the same type declaration**==, and oddly placed semicolons can affect the legality of the code.
## Initializing Variables

Before you can use a variable, it needs a value.
### Creating Local Variables

==**A local variable is a variable defined within a constructor, method, or initializer block.**==
### Final Local Variables

The `final` keyword can be applied to local variables and is equivalent to declaring constants in other languages

```java
5: final int y = 10;
6: int x = 20;
7: y = x + 10; // DOES NOT COMPILE
```

The final modifier can also be applied to local variable references.

```java
5: final int[] favoriteNumbers = new int[10];
6: favoriteNumbers[0] = 10;
7: favoriteNumbers[1] = 20;
8: favoriteNumbers = null; // DOES NOT COMPILE
```

The compiler error isn’t until line 8, when we try to change the value of the reference `favoriteNumbers`.

---
```java
void sampleKeywordsForLocalVariables() {  
  
     private int secret = 10; // DOES NOT COMPILE  
     public int number = 100; // DOES NOT COMPILE  
     static int size = 20 ; // DOES NOT COMPILE  
     abstract int age = 25; // DOES NOT COMPILE  
     volatile int counter = 10; // DOES NOT COMPILE  
     transient int life = 50;  
  
    final int valid = 200;  
  
}
```

---
### Uninitialized Local Variables

==**Local variables do not have a default value and must be initialized before use.**== Furthermore, the compiler will report an error if you try to read an uninitialized value.

```java
4: public int notValid() {
	5: int y = 10;
	6: int x;
	7: int reply = x + y; // DOES NOT COMPILE
	8: return reply;
9: }
```

The compiler is smart enough to recognize variables that have been initialized after their declaration but before they are used.

```java
public int valid() {
	int y = 10;
	int x; // x is declared here
	x = 3; // x is initialized here
	int z; // z is declared here but never initialized or used
	int reply = x + y;
	return reply;
}
```

The compiler is also smart enough to recognize initializations that are more complex.

```java
public void findAnswer(boolean check) {
	int answer;
	int otherAnswer;
	int onlyOneBranch;
	if (check) {
		onlyOneBranch = 1;
		answer = 1;
	} else {
		answer = 2;
	}
	System.out.println(answer);
	System.out.println(onlyOneBranch); // DOES NOT COMPILE
}
```

The `answer` variable is initialized in both branches of the if statement, so the compiler is perfectly happy. It knows that regardless of whether check is true or false, the value answer will be set to something before it is used. The `otherAnswer` variable is not initialized but never used, and the compiler is equally as happy. ==**The compiler is only concerned if you try to use uninitialized local variables; it doesn’t mind the ones you never use.**==

---
**On the exam, be wary of any local variable that is declared but not initialized in a single line. This is a common place on the exam that could result in a “Does not compile” answer. Be sure to check to make sure it’s initialized before it’s used on the exam.** #TIP 

---
### Passing Constructor and Method Parameters

**==Variables passed to a constructor or method are called constructor parameters or method parameters, respectively. These parameters are like local variables that have been pre-initialized.==**

```java
public void findAnswer(boolean check) {} 
```

```java
public void checkAnswer() {
	boolean value;
	findAnswer(value); // DOES NOT COMPILE
}
```

The call to `findAnswer()` does not compile because it tries to use a variable that is not initialized.
### Defining Instance and Class Variables

Variables that are not local variables are defined either as instance variables or as class variables.

- An instance variable, often called a field, is a value defined within a specific instance of an object. Let’s say we have a `Person` class with an instance variable name of type `String`.
	Each instance of the class would have its own value for name, such as *Elysia* or *Sarah*.
	==**Two instances could have the same value for name, but changing the value for one does not modify the other.**==

- A class variable is one that is defined on the class level and shared among all instances of the class. It can even be publicly accessible to classes outside the class and doesn’t require an instance to use. ==**You can tell a variable is a class variable because it has the keyword `static` before it.**==

==**Instance and class variables do not require you to initialize them. As soon as you declare these variables, they are given a default value.**== The compiler doesn’t know what value to use and so wants the simplest value it can give the type: `null` for an object, `zero` for the numeric types, and `false` for a `boolean`

![[Pasted image 20240114005317.png]]
### Inferring the Type with `var`

have the option of using the keyword var instead of the type when declaring local variables under certain conditions

```java
public class Zoo {
	public void whatTypeAmI() {
		var name = "Hello";
		var size = 7;
	}
}
```

The formal name of this feature is ==**local variable type inference**==  You can only use this feature for
local variables. The exam may try to trick you with code like this:

```java
public class VarKeyword {
	var tricky = "Hello"; // DOES NOT COMPILE
}
```

The variable `tricky` is an instance variable. Local variable type inference works with local variables and not instance variables. 
### Type Inference of ``var``

When you type `var`, you are instructing the compiler to determine the type for you The compiler looks at the code on the line of the declaration and uses it to infer the type.

```java
7: public void reassignment() {
	8: var number = 7;
	9: number = 4;
	10: number = "five"; // DOES NOT COMPILE
11: }
```

---
**==In Java, ``var`` is still a specific type defined at compile time. It does not change type at runtime==.** #TIP

---
### Examples with ``var``

```java
3: public void doesThisCompile(boolean check) {
	4: var question;
	5: question = 1;
	6: var answer;
	7: if (check) {
		8: answer = 2;
	9: } else {
		10: answer = 3;
	11: }
	12: System.out.println(answer);
13: }
```

The code does not compile. ==**for local variable type inference, the compiler looks only at the line with the declaration.**==  the initial value used to determine the type needs to be part of the same statement.

```java
var y;   // Compilation error: cannot infer type for local variable y
y = 10;  // Type inference requires an initializer on the same line

```


```java
4: public void twoTypes() {
	5: int a, var b = 3; // DOES NOT COMPILE
	6: var n = null; // DOES NOT COMPILE
	int c = 2,  d = 3; // DOES COMPILE
7: }
```

Line 5 wouldn’t work even if you replaced ``var`` with a real type. All the types declared on a single line must be the same type and share the same declaration.

Line 6 is a single line. The compiler is being asked to infer the type of `null`. This could be any reference type. The only choice the compiler could make is `Object`. However  the designers of Java decided it would be better not to allow var for `null` than to have to guess at intent.

```java
4: public void twoTypes() {
	5: var a = 2, var b = 3; // DOES NOT COMPILE
	6: int x, int v = 3; // DOES NOT COMPILE 
	7: var a = 2; var b = 3; // DOES  COMPILE
8: }
```


---

**While a `var` cannot be initialized with a ``null`` value without a type, it can be reassigned a ``null`` value after it is declared, provided that the underlying data type is a reference type.**  #TIP 

---

```java
public int addition(var a, var b) { // DOES NOT COMPILE
	return a + b;
}
```

a and b are method parameters. These are not local variables. Be on the lookout for var used with constructors, method parameters, or instance variables. **var is only used for local variable type inference!**

==**one last rule  should be aware of:  `var` is not a reserved word and allowed to be used as an identifier. It is considered a reserved type name.  A reserved type name means it cannot be used to define a type, such as a ``class``, ``interface``, or ``enum``.**==

```java
package var;
public class Var {
	public void var() {
		var var = "var";
	}
	public void Var() {
		Var var = new Var();
	}
}
```

this code does compile. 

---
**Var Review**

1. ==**A `var` is used as a local variable in a constructor, method, or initializer block.**==   
 2. ==**A `var` cannot be used in constructor parameters, method parameters, instance variables, or class variables.**==   
 3. ==**A `var` is always initialized on the same line (or statement) where it is declared.**==    
 4. ==**The value of a `var` can change, but the type cannot.**==    
 5. ==**A `var` cannot be initialized with a ``null`` value without a type.**==    
 6. ==**A `var` is not permitted in a multiple-variable declaration.**==    
 7.  ==**A `var` is a reserved type name but not a reserved word, meaning it can be used as an identifier except as a class, interface, or enum name.**== 

```java

  
// A var is used as a local variable in a constructor, method, or initializer block.  
class Example {  
  
    public Example() {  
        var number = 10;  
    }  
  
    private void method() {  
        var name = "username";  
    }  
  
    {  
        var initialized = true;  
    }  
}  
  
// A var cannot be used in constructor parameters, method parameters, instance variables, or class variables.  
class Example2 {  
  
     private void notValid(var notAllowedHere) {} // DOES NOT COMPILE  
     public Example2(var notAllowedHere) {} // DOES NOT COMPILE  
     private var instanceVariableAsVarNotAllowed; // DOES NOT COMPILE  
     private static var staticVariableAsVarNotAllowed; // DOES NOT COMPILE  
}  
  
// A var is always initialized on the same line (or statement) where it is declared.  
class Example3 {  
  
    void method() {  
        var number = 10;  
  
        var sum  
                = 20;  
  
         var notValid; notValid =20; // DOES NOT COMPILE  
         var notValid2;  
    }  
}  
  
// The value of a var can change, but the type cannot.  
  
class Example4 {  
  
    void method() {  
        var number = 10;  
        number = 20;  
        number = 30;  
  
        final var sum = 100;  
        sum = 150; // DOES NOT COMPILE, final variable  
  
        var today = LocalDate.now();  
  
         today = LocalTime.now(); // DOES NOT COMPILE  
  
        var str = new StringBuilder("example content");  
         str = "another content"; // DOES NOT COMPILE  
    }  
}  
  
// A var cannot be initialized with a null value without a type.  
  
class Example5 {  
  
    void method() {  
  
        var object = null; // DOES NOT COMPILE  
  
        var content = (String) null;  
  
        var invalid = (null)String; // DOES NOT COMPILE  
        var size = 10;  
         size = null; // DOES NOT COMPILE  
  
        var age = (Integer) 50;  
        age = null;  
  
        var name = "username";  
        name = null;  
    }  
}  
  
// A var is not permitted in a multiple-variable declaration.  
class Example6 {  
  
    void method() {  
  
         var number = 100, size = 200; // DOES NOT COMPILE  
        int number2 = 100, size2 = 200;  
  
         var number3 = 100, var size3 = 200; // DOES NOT COMPILE  
         int number4 = 100, int number4 = 200; // DOES NOT COMPILE  
    }  
}  
  
// 7- A var is a reserved type name but not a reserved word,  
// meaning it can be used as an identifier except as a class, interface, or enum name.  
  
// 'var' is a restricted identifier and cannot be used for type declarations  
  
class var { // DOES NOT COMPILE  
  
    public var() {}  
  
    private void var() {}  
}  
  
 interface var {} // DOES NOT COMPILE  
  
 enum var {} // DOES NOT COMPILE
```

---
## Managing Variable Scope

```java
public void eat(int piecesOfCheese) {
	int bitesOfCheese = 1;
}
```

There are two variables with local scope. The `bitesOfCheese` variable is declared inside the method. The `piecesOfCheese` variable is a method parameter. Neither variable can be used outside of where it is defined.
### Limiting Scope

==**Local variables can never have a scope larger than the method they are defined in.**== However, they can have a smaller scope.

```java
3: public void eatIfHungry(boolean hungry) {
4: if (hungry) {
5: int bitesOfCheese = 1;
6: } // bitesOfCheese goes out of scope here
7: System.out.println(bitesOfCheese); // DOES NOT COMPILE
8: }
```

When you see a set of braces `({})` in the code, it means you have entered a new block of code. Each block of code has its own scope. When there are multiple blocks, you match them from the inside out.

Remember that blocks can contain other blocks. These smaller contained blocks can reference variables defined in the larger scoped blocks, but not vice versa.

```java
16: public void eatIfHungry(boolean hungry) {
	17: if (hungry) {
	18: int bitesOfCheese = 1;
		19: {
			20: var teenyBit = true;
			21: System.out.println(bitesOfCheese);
		22: }
	23: }
	24: System.out.println(teenyBit); // DOES NOT COMPILE
25: }
```

The variable defined on line 18 is in scope until the block ends on line 23. Using it in the smaller block from lines 19 to 22 is fine. The variable defined on line 20 goes out of scope on line 22. Using it on line 24 is not allowed.
### Tracing Scope

which line each of the five local variables goes into and out of scope:

```java
11: public void eatMore(boolean hungry, int amountOfFood) { // Method
	12: int roomInBelly = 5;
	13: if (hungry) { // if
		14: var timeToEat = true;
		15: while (amountOfFood > 0) { // while
			16: int amountEaten = 2;
			17: roomInBelly = roomInBelly -amountEaten;
			18: amountOfFood = amountOfFood -amountEaten;
		19: } // while
	20: } // if
	21: System.out.println(amountOfFood);
22: } // Method
```

This method does compile. The first step in figuring out the scope is to identify the blocks of code. In this case, there are three blocks. You can tell this because there are three sets of braces.

| Block Type | First Line in Block | Last Line in Block |
|------------|----------------------|---------------------|
| `while`    | 15                   | 19                  |
| `if`       | 13                   | 20                  |
| Method     | 11                   | 22                  |

`hungry` and `amountOfFood` are method parameters, so they are available for the entire method. This means their scope is lines 11 to 22. The variable `roomInBelly` goes into scope on line 12 because that is where it is declared. It stays in scope for the rest of the method and goes out of scope on line 22. The variable `timeToEat` goes into scope on line 14 where it is declared. It goes out of scope on line 20 where the if block ends. Finally, the variable `amountEaten` goes into scope on line 16 where it is declared. It goes out of scope on line 19 where the while block ends.

==**Identifying blocks and variable scope needs to be second nature for the exam.**==
### Applying Scope to Classes

- ==**the rule for instance variables is easier: they are available as soon as they are defined and last for the entire lifetime of the object itself.**==

- ==**The rule for class, aka `static`, variables is even easier: they go into scope when declared like the other variable types. However, they stay in scope for the entire life of the program.**==

```java
1: public class Mouse {
	2: final static int MAX_LENGTH = 5; // End of the program - scope: 2 - 10
	3: int length; // End of the object - scope: 3 - 10
	4: public void grow(int inches) { // scope: 4 - 9
		5: if (length < MAX_LENGTH) {
			6: int newSize = length + inches; // scope: 6 - 8
			7: length = newSize;
		8: }
	9: }
10: }
```
### Reviewing Scope

- ==**Local variables: In scope from declaration to the end of the block**==
- ==**Method parameters: In scope for the duration of the method**==
- ==**Instance variables: In scope from declaration until the object is eligible for garbage collection**==
- ==**Class variables: In scope from declaration until the program ends**==

---
```java
public class ReviewingScope {  
  
    private String instanceVariable = "best object value";  
  
    private static String classVariable = "cool class";  
  
    private void method(int methodParameter) {  
  
        int localVariableX = 100;  
  
        var localVariableY = 200;  
  
        if (methodParameter > 10) {  
            int localVariableInTheIfBlock = 30;  
            System.out.println(localVariableInTheIfBlock);  
            System.out.println(localVariableX);  
            System.out.println(localVariableY);  
            System.out.println(methodParameter);  
            System.out.println(instanceVariable);  
            System.out.println(classVariable);  
        } else {  
            int localVariableInTheElseBlock = 50;  
            System.out.println(localVariableX);  
            System.out.println(localVariableY);  
            //System.out.println(localVariableInTheIfBlock); //DOES NOT COMPILE  
            System.out.println(methodParameter);  
            System.out.println(instanceVariable);  
            System.out.println(ReviewingScope.classVariable);  
        }  
  
        // System.out.println(localVariableInTheIfBlock); //DOES NOT COMPILE  
  
        System.out.println(instanceVariable);  
        System.out.println(classVariable);  
    }
```

---
## Destroying Objects

Java provides a garbage collector to automatically look for objects that aren’t needed anymore.  All Java objects are stored in your program memory’s heap. The heap, which is also referred to as the free store, represents a large pool of unused memory allocated to your Java application. If your program keeps instantiating objects and leaving them on the heap, eventually it will run out of memory and crash. garbage collection solves this problem.

### Understanding Garbage Collection

Garbage collection refers to the process of automatically freeing memory on the heap by deleting objects that are no longer reachable in your program. 

As a developer, the most interesting part of garbage collection is determining when the memory belonging to an object can be reclaimed. In Java and other languages, ==**eligible for garbage collection refers to an object’s state of no longer being accessible in a program and therefore able to be garbage collected.**==

Think of garbage-collection eligibility like shipping a package. You can take an item, seal it in a labeled box, and put it in your mailbox. This is analogous to making an item eligible for garbage collection. When the mail carrier comes by to pick it up, though, is not in your control 

Java includes a built-in method to help support garbage collection where you can suggest that garbage collection run.

```java
System.gc();
```

Java is free to ignore you. ==**This method is not guaranteed to do anything**==.

### Tracing Eligibility

How does the JVM know when an object is eligible for garbage collection? The JVM waits patiently and monitors each object until it determines that the code no longer needs that memory. An object will remain on the heap until it is no longer reachable. An object is no longer reachable when one of two situations occurs:

-  ==**The object no longer has any references pointing to it.**==
-  ==**All references to the object have gone out of scope.**==

---
**Objects vs. References**

Do not confuse a reference with the object that it refers to; they are two different entities.

- The reference is a variable that has a name and can be used to access the contents of an object. A reference can be assigned to another reference, passed to a method, or returned from a method. All references are the same size, no matter what their type is.

- An object sits on the heap and does not have a name. Therefore, you have no way to access an object except through a reference. Objects come in all different shapes and sizes and consume varying amounts of memory. An object cannot be assigned to another object, and an object cannot be passed to a method or returned from a method. ==**It is the object that gets garbage collected, not its reference.**==

			![[Pasted image 20240112123949.png]]

---

```java
1: public class Scope {
	2: public static void main(String[] args) {
		3: String one, two;
		4: one = new String("a");
		5: two = new String("b");
		6: one = two;
		7: String three = one;
		8: one = null;
	9: }
}
```

- Line 3: Declares two String variables, `one` and `two`.
- Lines 4-5: Creates two String objects ("a" and "b") on the heap and assigns them to `one` and `two`.
- Line 6: Makes `one` point to the same object as `two`.
- Line 7: Declares a new variable `three` and makes it point to the same object as `one`.
- Line 8: Sets `one` to `null`.
- Garbage Collection Eligibility:
    - Object with "a" becomes eligible for garbage collection on line 6 when the only arrow pointing to it is replaced.
    - Object with "b" remains eligible until the end of the method (line 9) since `three` is still referencing it.


---
**Code Formatting on the Exam** #TIP 

Not all questions will include package declarations and imports. Don’t worry about missing package statements or imports unless you are asked about them. The following are common cases where you don’t need to check the imports:

- ==**Code that begins with a class name**==
-  ==**Code that begins with a method declaration**==
- ==**Code that begins with a code snippet that would normally be inside a class or method**==
- ==**Code that has line numbers that don’t begin with 1**==
 
 You’ll see code that doesn’t have a method. When this happens, assume any necessary plumbing code like the main() method and class definition were written correctly. You’re just being asked if the part of the code you’re shown compiles when dropped into valid surrounding code. Finally, remember that extra whitespace doesn’t matter in Java syntax. The exam may use varying amounts of whitespace to trick you.

---

## Summary #OCP_Summary 

==**Java begins program execution with a `main()` method. The most common signature for this method run from the command line is `public static void main(String[] args)`. Arguments are passed in after the class name, as in java `NameOfClass` `firstArgument`. Arguments are indexed starting with 0.**==

==**Java code is organized into folders called packages. To reference classes in other packages, you use an `import` statement. A wildcard ending an import statement means you want to import all classes in that package. It does not include packages that are inside that one. The package` java.lang` is special in that it does not need to be imported.**==

==**For some class elements, order matters within the file. The package statement comes first if present. Then come the import statements if present. Then comes the class declaration. Fields and methods are allowed to be in any order within the class.**==

==**Primitive types are the basic building blocks of Java types. They are assembled into reference types. Reference types can have methods and be assigned a ``null`` value. Numeric literals are allowed to contain underscores `(_)` as long as they do not start or end the literal and are not next to a decimal point `(.)`. Wrapper classes are reference types, and there is one for each primitive. Text blocks allow creating a ``String`` on multiple lines using `"""`.**==

==**Declaring a variable involves stating the data type and giving the variable a name. Variables that represent fields in a class are automatically initialized to their corresponding 0, `null`, or `false` values during object instantiation. Local variables must be specifically initialized before they can be used. Identifiers may contain letters, numbers, currency symbols, or _. Identifiers may not begin with numbers. Local variable declarations may use the ``var`` keyword instead of the actual type. When using var, the type is set once at compile time and does not change.**==

==**Scope refers to that portion of code where a variable can be accessed. There are three kinds of variables in Java, depending on their scope: instance variables, class variables, and local variables. Instance variables are the non-static fields of your class. Class variables are the static fields within a class. Local variables are declared within a constructor, method, or initializer block.**==

==**Constructors create Java objects. A constructor is a method matching the class name and omitting the return type. When an object is instantiated, fields and blocks of code are initialized first. Then the constructor is run. Finally, garbage collection is responsible for removing objects from memory when they can never be used again. An object becomes eligible for garbage collection when there are no more references to it or its references have all gone out of scope.**==


## Exam Essentials #Essential

**Be able to write code using a main() method**. A `main()` method is usually written as `public static void main(String[] args)`. Arguments are referenced starting with `args[0]`. Accessing an argument that wasn’t passed in will cause the code to throw an exception.

**Understand the effect of using packages and imports**. Packages contain Java classes. Classes can be imported by class name or wildcard. Wildcards do not look at subdirectories. In the event of a conflict, class name imports take precedence. Package and import statements are optional. If they are present, they both go before the class declaration in that order.

**Be able to recognize a constructor.** A constructor has the same name as the class. It looks like a method without a return type.

**Be able to identify legal and illegal declarations and initialization**. Multiple variables can be declared and initialized in the same statement when they share a type. Local variables require an explicit initialization; others use the default value for that type. Identifiers may contain letters, numbers, currency symbols, or _, although they may not begin with numbers. Also, you cannot define an identifier that is just a single underscore character _. Numeric literals may contain underscores between two digits, such as 1_000, but not in other places, such as _100_.0_.

**Understand how to create text blocks.**  A text block begins with `"""` on the first line. On the next line begins the content. The last line ends with `""".` If `"""` is on its own line, a trailing line break is included.

**Be able to use `var` correctly.** A var is `var` for a local variable. A `var` is initialized on the same line where it is declared, and while it can change value, it cannot change type. A `var` cannot be initialized with a `null` value without a type, nor can it be used in multiple variable declarations.

**Be able to determine where variables go into and out of scope.** All variables go into scope when they are declared. Local variables go out of scope when the block they are declared in ends. Instance variables go out of scope when the object is eligible for garbage collection. Class variables remain in scope as long as the program is running.

**Know how to identify when an object is eligible for garbage collection.** Draw a diagram to keep track of references and objects as you trace the code. When no arrows point to a box (object), it is eligible for garbage collection.

## Review Questions

1. Which of the following are legal entry point methods that can be run from the command line? (Choose all that apply.)
A.  ``private static void main(String[] args)``
B.  ``public static final main(String[] args)``
C.  ``public void main(String[] args)``
D.  ``public static final void main(String[] args)``
E.  ``public static void main(String[] args)``
F.  ``public static main(String[] args)``

**My Answer: D, E
Correct Answer: D,E**

**D, E. Option E is the canonical main() method signature. You need to memorize it. Option D is an alternate form with the redundant final.**

---

Which answer options represent the order in which the following statements can be assembled into a program that will compile successfully? (Choose all that apply.)
```java
X: class Rabbit {}
Y: import java.util.*;
Z: package animals;
```
A.  X, Y, Z
B.  Y, Z, X
C.  Z, Y, X
D.  Y, X
E.  Z, X
F.  X, Z
G. None of the above

**My Answer: C,D  
Correct Answer: C,D,E**

**The package and import statements are both optional. If both are present, the order must be package, then import, and then class.**

---

3. Which of the following are true? (Choose all that apply.)
```java
public class Bunny {
public static void main(String[] x) {
Bunny bun = new Bunny();
} }
```

A.  Bunny is a class.
B.  bun is a class.
C.  main is a class.
D.  Bunny is a reference to an object.
E.  bun is a reference to an object.
F.  main is a reference to an object.
G.  The main() method doesn’t run because the parameter name is incorrect.

**My Answer: A,E  
Correct Answer: A,E**

**Bunny is a class, which can be seen from the declaration: public class Bunny. The variable bun is a reference to an object. The method main() is the standard entry point to a program.**

---

4. Which of the following are valid Java identifiers? (Choose all that apply.)
A.  `_`
B. ` _helloWorld$`
C.  `true`
D.  `java.lang`
E.  Public
F.  1980_s
G.  _Q2_

**My Answer: B,E,G 
Correct Answer: B,E,G**

---

5. Which statements about the following program are correct? (Choose all that apply.)

```java
2: public class Bear {
3: private Bear pandaBear;
4: private void roar(Bear b) {
5: System.out.println("Roar!");
6: pandaBear = b;
7: }
8: public static void main(String[] args) {
9: Bear brownBear = new Bear();
10: Bear polarBear = new Bear();
11: brownBear.roar(polarBear);
12: polarBear = null;
13: brownBear = null;
14: System.gc(); } }
```

A.  The object created on line 9 is eligible for garbage collection after line 13.
B.  The object created on line 9 is eligible for garbage collection after line 14.
C.  The object created on line 10 is eligible for garbage collection after line 12.
D.  The object created on line 10 is eligible for garbage collection after line 13.
E.  Garbage collection is guaranteed to run.
F.  Garbage collection might or might not run.
G.  The code does not compile.

**My Answer: A,D,F  
Correct Answer: A,D,F**

**Garbage collection is never guaranteed to run, making option F correct and option E incorrect. Next, the class compiles and runs without issue, so option G is incorrect. The Bear object created on line 9 is accessible until line 13 via the brownBear reference variable, which is option A. The Bear object created on line 10 is accessible via both the polarBear reference and the `brownBear.pandaBear` reference. After line 12, the object is still accessible via `brownBear.pandaBear.` After line 13, though, it is no longer accessible since `brownBear` is no longer accessible, which makes option D the final answer.**

---

6. Assuming the following class compiles, how many variables defined in the class or method are in scope on the line marked on line 14?
```java
1: public class Camel {
2: { int hairs = 3_000_0; }
3: long water, air=2;
4: boolean twoHumps = true;
5: public void spit(float distance) {
6: var path = "";
7: { double teeth = 32 + distance++; }
8: while(water > 0) {
9: int age = twoHumps ? 1 : 2;
10: short i=-1;
11: for(i=0; i<10; i++) {
12: var Private = 2;
13: }
14: // SCOPE
15: }
16: }
17: }
```

A. 2
B. 3
C. 4
D. 5
E. 6
F. 7
G. None of the above

**My Answer: D  
Correct Answer: F**

**To solve this problem, you need to trace the braces {} and see when variables go in and out of scope. The variables on lines 2 and 7 are only in scope for a single line block. The variable on line 12 is only in scope for the for loop. None of these are in scope on line 14.  By contrast, the three instance variables on lines 3 and 4 are available in all instance methods. Additionally, the variables on lines 6, 9, and 10 are available since the method and while loop are still in scope.**

---

7. Which are true about this code? (Choose all that apply.)

```JAVA
public class KitchenSink {
private int numForks;
public static void main(String[] args) {
int numKnives;
System.out.print("""
"# forks = " + numForks +
" # knives = " + numKnives +
# cups = 0""");
}
}
```

A. The output includes: # forks = 0.
B.  The output includes: # knives = 0.
C.  The output includes: # cups = 0.
D.  The output includes a blank line.
E.  The output includes one or more lines that begin with whitespace.
F.  The code does not compile.

**My Answer: F 
Correct Answer: C, E**

**The first thing to recognize is that this is a text block and the code inside the `"""` is just text. Options A and B are incorrect because the `numForks` and `numKnives` variables are not used. This is convenient since `numKnives` is not initialized and would not compile if it were referenced. Option C is correct as it is matching text. Option D is incorrect because the text block does not have a trailing blank line. Finally, option E is also an answer since " # knives is indented.**

---

8. Which of the following code snippets about `var` compile without issue when used in a method? (Choose all that apply.)

```java
A. var spring = null;
B. var fall = "leaves";
C. var evening = 2; evening = null;
D. var night = Integer.valueOf(3);
E. var day = 1/0;
F. var winter = 12, cold;
G. var fall = 2, autumn = 2;
H. var morning = ""; morning = null;
```

**My Answer: B,C,D,H  
Correct Answer: B,D,E,H**

**`var` cannot be initialized with a null value without a type, but it can be assigned a null value later if the underlying type is not a primitive. var cannot be used in a multiple-variable assignment.**

---

9. Which of the following are correct? (Choose all that apply.)
A.  An instance variable of type float defaults to 0.
B.  An instance variable of type char defaults to null.
C.  A local variable of type double defaults to 0.0.
D.  A local variable of type int defaults to null.
E.  A class variable of type String defaults to null.
F.  A class variable of type String defaults to the empty string "".
G.  None of the above.

**My Answer: B,F  
Correct Answer: E**

==**local variables don’t have default values.  primitives do not default to null.  reference types in class variables default to null.**==

---

10. Which of the following expressions, when inserted independently into the blank line, allow the code to compile? (Choose all that apply.)

```java
public void printMagicData() {
var magic = ???;
System.out.println(magic);
}
```

A.  3_1
B.  1_329_.0
C.  3_13.0_
D.  5_291._2
E.  2_234.0_0
F.  9___6
G.  _1_3_5_0

**My Answer: A,E,F  / Correct Answer: A,E,F**

---

11. Given the following two class files, what is the maximum number of imports that can be removed and have the code still compile?

```java
// Water.java
package aquarium;
public class Water { }

// Tank.java
package aquarium;
import java.lang.*;
import java.lang.System;
import aquarium.Water;
import aquarium.*;
public class Tank {
public void print(Water water) {
System.out.println(water); } }
```

A. 0
B. 1
C. 2
D. 3
E. 4
F. Does not compile

**My Answer: E  
Correct Answer: E**

**The first two imports can be removed because `java.lang` is automatically imported. The**
**following two imports can be removed because Tank and Water are in the same package,**

---

12. Which statements about the following class are correct? (Choose all that apply.)

```JAVA
1: public class ClownFish {
2: int gills = 0, double weight=2;
3: { int fins = gills; }
4: void print(int length = 3) {
5: System.out.println(gills);
6: System.out.println(weight);
7: System.out.println(fins);
8: System.out.println(length);
9: } }
```

A.  Line 2 generates a compiler error.
B.  Line 3 generates a compiler error.
C.  Line 4 generates a compiler error.
D.  Line 7 generates a compiler error.
E.  The code prints 0.
F.  The code prints 2.0.
G.  The code prints 2.
H.  The code prints 3.

**My Answer: A 
Correct Answer: A,C,D**

**Line 2 does not compile as only one type should be specified, making option A correct.  Line 4 does not compile because Java does not support setting default method parameter values, making option C correct. Finally, line 7 does not compile because fins is in scope and accessible only inside the instance initializer on line 3, making option D correct.**

---

13. Given the following classes, which of the following snippets can independently be inserted in place of INSERT IMPORTS HERE and have the code compile? (Choose all that apply.)

```java
package aquarium;
public class Water {
boolean salty = false;
}
package aquarium.jellies;
public class Water {
boolean salty = true;
}
package employee;
INSERT IMPORTS HERE
public class WaterFiller {
Water water;
}
```

A. import aquarium.*;
B. import `aquarium.Water`;
   import `aquarium.jellies.*`;
C. import aquarium.*;
   import `aquarium.jellies.Water`;
D. import aquarium.*;
   import `aquarium.jellies.*`;
E. import `aquarium.Water`;
   import `aquarium.jellies.Water`;
F. None of these imports can make the code compile.

**My Answer: A,B,C  
Correct Answer: A,B,C**

---

14. Which of the following statements about the code snippet are true? (Choose all that apply.)
```java
3: short numPets = 5L;
4: int numGrains = 2.0;
5: String name = "Scruffy";
6: int d = numPets.length();
7: int e = numGrains.length;
8: int f = name.length();
```

A. Line 3 generates a compiler error.
B. Line 4 generates a compiler error.
C. Line 5 generates a compiler error.
D. Line 6 generates a compiler error.
E. Line 7 generates a compiler error.
F. Line 8 generates a compiler error.

**My Answer: A,B,D,E 
Correct Answer: A,B,D,E**

**Line 3 does not compile because the L suffix makes the literal value a long, which cannot be stored inside a short directly, making option A correct. Line 4 does not compile because int is an integral type, but 2.0 is a double literal value, making option B correct. both primitives, and you can call methods only on reference types, not primitive values, making options D and E correct**

---

15. Which of the following statements about garbage collection are correct? (Choose all that apply.)

A. Calling `System.gc()` is guaranteed to free up memory by destroying objects eligible for garbage collection.
B. Garbage collection runs on a set schedule.
C. Garbage collection allows the JVM to reclaim memory for other objects.
D. Garbage collection runs when your program has used up half the available memory.
E. An object may be eligible for garbage collection but never removed from the heap.
F. An object is eligible for garbage collection once no references to it are accessible in the program.
G. Marking a variable final means its associated object will never be garbage collected.

**My Answer: C,F  
Correct Answer: C,E,F**

**In Java, there are no guarantees about when garbage collection will run. The JVM is free to ignore calls to `System.gc()`. the purpose of garbage collection is to reclaim used memory. Option E is also correct that an object may never be garbage collected, such as if the program ends  before garbage collection runs.** 

---

16. Which are true about this code? (Choose all that apply.)
```java
var blocky = """
squirrel \s
pigeon \
termite""";
System.out.print(blocky);
```

A. It outputs two lines.
B. It outputs three lines.
C. It outputs four lines.
D. There is one line with trailing whitespace.
E. There are two lines with trailing whitespace.
F. If we indented each line five characters, it would change the output.

**My Answer: B,D 
Correct Answer: A,D**

**here are two lines. One starts with squirrel, and the other starts with pigeon. Remember that a backslash means to skip the line break. Option D is also correct as \s means to keep whitespace. In a text block, incidental indentation is ignored**

---

17. What lines are printed by the following program? (Choose all that apply.)

```java
1: public class WaterBottle {
2: private String brand;
3: private boolean empty;
4: public static float code;
5: public static void main(String[] args) {
6: WaterBottle wb = new WaterBottle();
7: System.out.println("Empty = " + wb.empty);
8: System.out.println("Brand = " + wb.brand);
9: System.out.println("Code = " + code);
10: } }
```

A. Line 8 generates a compiler error.
B. Line 9 generates a compiler error.
C. Empty =
D. Empty = false
E. Brand =
F. Brand = null
G. Code = 0.0
H. Code = 0f

**My Answer: D,E,G 
Correct Answer: D,F,G**

**The code compiles and runs without issue, so options A and B are incorrect. A boolean field initializes to false, making option D correct with Empty = false being printed. Object references initialize to null, not the empty String, so option F is correct with Brand = null being printed.  Finally, the default value of floating-point numbers is 0.0. Although float values can be declared with an f suffix, they are not printed with an f suffix. For these reasons, option G is correct and Code = 0.0 is printed.**

---

18. Which of the following statements about var are true? (Choose all that apply.)

A. A var can be used as a constructor parameter.
B. The type of a var is known at compile time.
C. A var cannot be used as an instance variable.
D. A var can be used in a multiple variable assignment statement.
E. The value of a var cannot change at runtime.
F. The type of a var cannot change at runtime.
G. The word var is a reserved word in Java.

**My Answer: B,C,F 
Correct Answer: B,C,F**

---

19. Which are true about the following code? (Choose all that apply.)

```java
var num1 = Long.parseLong("100");
var num2 = Long.valueOf("100");
System.out.println(Long.max(num1, num2));
```

A. The output is 100.
B. The output is 200.
C. The code does not compile.
D. num1 is a primitive.
E. num2 is a primitive.

**My Answer: A  
Correct Answer: A,D**

==**The first is a long primitive and the second is a Long reference object,**==

---

20. Which statements about the following class are correct? (Choose all that apply.)

```java
1: public class PoliceBox {
2: String color;
3: long age;
4: public void PoliceBox() {
5: color = "blue";
6: age = 1200;
7: }
8: public static void main(String []time) {
9: var p = new PoliceBox();
10: var q = new PoliceBox();
11: p.color = "green";
12: p.age = 1400;
13: p = q;
14: System.out.println("Q1="+q.color);
15: System.out.println("Q2="+q.age);
16: System.out.println("P1="+p.color);
17: System.out.println("P2="+p.age);
18: } }
```

A. It prints Q1=blue.
B. It prints Q2=1200.
C. It prints P1=null.
D. It prints P2=1400.
E. Line 4 does not compile.
F. Line 12 does not compile.
G. Line 13 does not compile.
H. None of the above.

**My Answer: F,G  
Correct Answer: C**

**The key thing to notice is that line 4 does not define a constructor, but instead a method named `PoliceBox()`, since it has a return type of void. This method is never executed during the program run, and color and age are assigned the default values null and 0L, respectively. Lines 11 and 12 change the values for an object associated with p, but then, on line 13, the p variable is changed to point to the object associated with q, which still has the default values. For this reason, the program prints Q1=null, Q2=0, P1=null, and P2=0,**

---

21. What is the output of executing the following class?

```java
1: public class Salmon {
2: int count;
3: { System.out.print(count+"-");
}
4: { count++; }
5: public Salmon() {
6: count = 4;
7: System.out.print(2+"-");
8: }
9: public static void main(String[] args) {
10: System.out.print(7+"-");
11: var s = new Salmon();
12: System.out.print(s.count+"-");
} }
```

A. 7-0-2-1- 
B. 7-0-1- 
C. 0-7-2-1- 
D. 7-0-2-4- 
E. 0-7-1- 
F. The class does not compile because of line 3. 
G. The class does not compile because of line 4. 
H. None of the above.

**My Answer: D  
Correct Answer: D**

---

22. Given the following class, which of the following lines of code can independently replace INSERT CODE HERE to make the code compile? (Choose all that apply.)

```java
public class Price {
public void admission() {
INSERT CODE HERE
System.out.print(amount);
} }
```

A. int Amount = 0b11;
B. int amount = 9L;
C. int amount = 0xE;
D. int amount = 1_2.0;
E. double amount = 1_0_.0;
F. int amount = 0b101;
G. double amount = 9_2.1_2;
H. double amount = 1_2_.0_0;

**My Answer: A,C,F,G  
Correct Answer: C,F,G**

--- 

23. Which statements about the following class are true? (Choose all that apply.)

```java
1: public class River {
2: int Depth = 1;
3: float temp = 50.0;
4: public void flow() {
5: for (int i = 0; i < 1; i++) {
6: int depth = 2;
7: depth++;
8: temp--
;
9: }
10: System.out.println(depth);
11: System.out.println(temp); }
12: public static void main(String... s) {
13: new River().flow();
14: } }
```

A. Line 3 generates a compiler error.
B. Line 6 generates a compiler error.
C. Line 7 generates a compiler error.
D. Line 10 generates a compiler error.
E. The program prints 3 on line 10.
F. The program prints 4 on line 10.
G. The program prints 50.0 on line 11.
H. The program prints 49.0 on line 11.

**My Answer: A  
Correct Answer: A,D**

**The first compiler error is on line 3. The variable temp is declared as a float, but the assigned value is 50.0, which is a double without the F/f postfix. Since a double doesn’t fit inside a float, line 3 does not compile. Next, depth is declared inside the for loop and only has scope inside this loop. Therefore, reading the value on line 10 triggers a compiler error.**

---

# Chapter 2 - Operators #Chapter

## Understanding Java Operators

A Java operator is a special symbol that can be applied to a set of variables, values, or literals—referred to as operands—and that returns a result. The term operand, refers to the value or variable the operator is being applied to.

![[Pasted image 20240116141817.png]]

### Types of Operators

==**Java supports three flavors of operators: unary, binary, and ternary.**== These types of operators
can be applied to one, two, or three operands, respectively. 

Java operators are not necessarily evaluated from left-to-right order.

```java
int cookies = 4;
double reward = 3 + 2 * --cookies;
System.out.print("Zoo animal receives: "+reward+" reward points");
```

In this example, first decrement `cookies` to 3, then multiply the resulting value by 2, and finally add 3. The value then is automatically promoted from 9 to 9.0 and assigned to `reward`. The final values of `reward` and `cookies` are 9.0 and 3, respectively, with the following printed:

```java
Zoo animal receives: 9.0 reward points
```
### Operator Precedence

In mathematics, certain operators can override other operators and be evaluated first. ==**Determining which operators are evaluated in what order is referred to as operator precedence.**== In this manner, Java more closely follows the rules for mathematics.

```java
var perimeter = 2 * height + 2 * length;
// how the compiler evaluates this statement:
var perimeter = ((2 * height) + (2 * length));
```

The multiplication operator `(*)` has a higher precedence than the addition operator `(+)`, The assignment
operator `(=)` has the lowest order of precedence, so the assignment to the `perimeter` variable is performed last.

==**Unless overridden with parentheses, Java operators follow order of operation, listed in Table 2.1, by decreasing order of operator precedence.**== If two operators have the same level of precedence, then Java guarantees left-to-right evaluation for most operators other than the ones marked in the table.

![[Pasted image 20240116144727.png]]

## Applying Unary Operators

By definition, a unary operator is one that requires exactly one operand, or variable, to function. they often perform simple tasks, such as increasing a numeric variable by one or negating a `boolean` value.

| Operator Type         | Example      | Description                                           |
|------------------------|--------------|-------------------------------------------------------|
| Logical Complement     | `!a`         | Inverts a boolean’s logical value                     |
| Bitwise Complement     | `~b`         | Inverts all 0s and 1s in a number                     |
| Plus                   | `+c`         | Indicates a number is positive (assumed positive in Java unless accompanied by a negative unary operator) |
| Negation or Minus      | `-d`         | Indicates a literal number is negative or negates an expression |
| Increment              | `++e`        | Increments a value by 1                               |
| Increment (Postfix)    | `f++`        | Increments a value by 1 after its current value is used |
| Decrement              | `--f`        | Decrements a value by 1                               |
| Decrement (Postfix)    | `h--`        | Decrements a value by 1 after its current value is used |
| Cast                   | `(String)i`  | Casts a value to a specific type                      |
## Complement and Negation Operators

The logical complement operator `(!)` flips the value of a `boolean` expression. For example, if the value is true, it will be converted to false, and vice versa.

```java
boolean isAnimalAsleep = false;
System.out.print(isAnimalAsleep); // false
isAnimalAsleep = !isAnimalAsleep;
System.out.print(isAnimalAsleep); // true
```

For the exam, you also need to know about the **`bitwise complement operator (~)`**, which flips all of the 0s and 1s in a number. ==**It can only be applied to integer numeric types such as ``byte``, ``short``, ``char``, ``int``, and ``long``.**==

```java
int value = 3; // Stored as 0011
int complement = ~value; // Stored as 1100
System.out.println(value); // 3
System.out.println(complement); // -4
```

==**remember this rule: to find the bitwise complement of a number, multiply it by negative one and then subtract one.**==

```java
System.out.println(-1 * value -1); // -4
System.out.println(-1 * complement -1); // 3
```

the negation operator `(-)` reverses the sign of a numeric expression

```java
double zooTemperature = 1.21;
System.out.println(zooTemperature); // 1.21
zooTemperature = -zooTemperature;
System.out.println(zooTemperature); // -1.21
zooTemperature = -(-zooTemperature);
System.out.println(zooTemperature); // -1.21
```

Notice that in the last example we used parentheses, `()`, for the negation operator, `-`, to apply the negation twice. If we had instead written `--` , then it would have been interpreted as the decrement operator and printed -2.21.

Based on the description, it might be obvious that some operators require the variable or expression they’re  acting on to be of a specific type. For example, you cannot apply a negation operator `(-)` to a boolean expression, nor can you apply a logical complement operator `(!)` to a numeric expression.

```java
int pelican = !5; // DOES NOT COMPILE
boolean penguin = -true; // DOES NOT COMPILE
boolean peacock = !0; // DOES NOT COMPILE
```

---
 **Keep an eye out for questions on the exam that use numeric values (such as 0 or 1) with `boolean` expressions. Unlike in some other programming languages, in Java, 1 and `true` are not related in any way, just as 0 and `false` are not related.** #TIP 

---
### Increment and Decrement Operators

==**Increment and decrement operators, `++` and `--`, respectively, can be applied to numeric variables and have a high order of precedence compared to binary operators. In other words, they are often applied first in an expression.**==

Increment and decrement operators require special care because the order in which they are attached to their associated variable can make a difference in how an expression is processed.

| Operator Type      | Example | Description                                               |
|---------------------|---------|-----------------------------------------------------------|
| Pre-increment       | `++w`   | Increases the value by 1 and returns the new value        |
| Pre-decrement       | `--x`   | Decreases the value by 1 and returns the new value        |
| Post-increment      | `y++`   | Increases the value by 1 and returns the original value  |
| Post-decrement      | `z--`   | Decreases the value by 1 and returns the original value  |
```java
int parkAttendance = 0;
System.out.println(parkAttendance); // 0
System.out.println(++parkAttendance); // 1
System.out.println(parkAttendance); // 1
System.out.println(parkAttendance--); // 1
System.out.println(parkAttendance); // 0
```
## Working with Binary Arithmetic Operators

operators that take two operands, called binary operators. Binary operators are by far the most common operators in the Java language.  Binary operators are often combined in complex expressions with other binary operators; therefore, operator precedence is very important in evaluating expressions containing binary operators.

| Operator Type | Example  | Description                                              |
|---------------|----------|----------------------------------------------------------|
| Addition      | `a + b`  | Adds two numeric values                                  |
| Subtraction   | `c - d`  | Subtracts two numeric values                              |
| Multiplication| `e * f`  | Multiplies two numeric values                              |
| Division      | `g / h`  | Divides one numeric value by another                      |
| Modulus       | `i % j`  | Returns the remainder after division of one numeric value by another |

Arithmetic operators also include the unary operators, ++ and --

```java
int price = 2 * 5 + 3 * 4 -8; // First, you evaluate the 2 * 5 and 3 * 4, which reduces the expression to this:
int price = 10 + 12 -8;
```

---

**All of the arithmetic operators may be applied to any Java primitives, with the exception of `boolean`.**

---
### Adding Parentheses

*Unless overridden with parentheses* prior to presenting Table 2.1 on operator precedence. That’s because you can change the order of operation explicitly by wrapping parentheses around the sections you want evaluated first.

**Changing the Order of Operation**

```java
int price = 2 * ((5 + 3) * 4 -8);
int price = 2 * (8 * 4 -8);
int price = 2 * (32 -8);
int price = 2 * 24;
```

---
**When you encounter code in your professional career in which you are not sure about the order of operation, feel free to add optional parentheses. While often not required, they can improve readability, especially as you’ll see with ternary operators.**  #TIP 

---

**Verifying Parentheses Syntax**

When working with parentheses, you need to make sure they are always valid and balanced.

```java
long pigeon = 1 + ((3 * 5) / 3; // DOES NOT COMPILE
int blueJay = (9 + 2) + 3) / (2 * 4; // DOES NOT COMPILE
```

When reading from left to right, a new right parenthesis must match a previous left parenthesis. Likewise, all left parentheses must be closed by right parentheses before the end of the expression.

```java
short robin = 3 + [(4 * 2) + 4]; // DOES NOT COMPILE
```

This example does not compile because Java, unlike some other programming languages, does not allow brackets, [], to be used in place of parentheses.
### Division and Modulus Operators

The modulus operator, sometimes called the remainder operator, is simply the remainder when two numbers are divided.

```java
System.out.println(9 / 3); // 3
System.out.println(9 % 3); // 0

System.out.println(10 / 3); // 3
System.out.println(10 % 3); // 1

System.out.println(11 / 3); // 3
System.out.println(11 % 3); // 2

System.out.println(12 / 3); // 4
System.out.println(12 % 3); // 0
```

Be sure to understand ==**the difference between arithmetic division and modulus. For integer values, division results in the floor value of the nearest integer that fulfills the operation, whereas modulus is the remainder value.**==

---

**The modulus operation is not limited to positive integer values in Java; it may also be applied to negative integers and floating-point numbers. For example, if the divisor is 5, then the modulus value of a negative number is between -4 and 0.**

---

### Numeric Promotion

==**each primitive numeric type has a bit-length. You don’t need to know the exact size of these types for the exam, but you should know which are bigger than others.**==

==**Numeric Promotion Rules**==

1. ==**If two values have different data types, Java will automatically promote one of the values to the larger of the two data types.**==
2. ==**If one of the values is integral and the other is floating-point, Java will automatically promote the integral value to the floating-point value’s data type.**==
3. ==**Smaller data types, namely, `byte`, `short`, and `char`, are first promoted to int any time they’re used with a Java binary arithmetic operator with a variable (as opposed to a value), even if neither of the operands is int.**==
4. ==**After all promotion has occurred and the operands have the same data type, the resulting value will have the same data type as its promoted operands.**==

The last two rules are the ones most people have trouble with and the ones likely to trip you up on the exam. For the third rule, note that unary operators are excluded from this rule. For example, applying ++ to a short value results in a short value.

**Examples**

- What is the data type of x * y?
```java
int x = 1;
long y = 33;
var z = x * y;
```

In this case, we follow the first rule. Since one of the values is `int` and the other is `long`, and `long` is larger than `int`, the `int` value x is first promoted to a`long`long. The result z is then a `long` value.

- What is the data type of x + y?
```java
double x = 39.21;
float y = 2.1;
var z = x + y;
```

This is actually a trick question, as ==**the second line does not compile! Floating-point literals are assumed to be double unless post-fixed with an f, as in 2.1f.**== If the value of y was set properly to 2.1f, then the promotion would be similar to the previous example, with both operands being promoted to a `double`, and the result z would be a `double` value.

- What is the data type of x * y?
```java
short x = 10;
short y = 3;
var z = x * y;
```

On the last line, we must apply the third rule: that x and y will both be promoted to `int` before the binary multiplication operation, resulting in an output of type `int`. If you were to try to assign the value to a `short` variable z without casting, then the code would not compile. 

- What is the data type of w * x / y?
```java
short w = 14;
float x = 13;
double y = 30;
var z = w * x / y;
```

In this case, must apply all of the rules. First, w will automatically be promoted to `int` solely because it is a `short` and is being used in an arithmetic binary operation. The promoted w value will then be automatically promoted to a `float` so that it can be multiplied with x. The result of w * x will then be automatically promoted to a `double` so that it can be divided by y, resulting in a `double` value. 

When working with arithmetic operators in Java, you should always be aware of the data type of variables, intermediate values, and resulting values. You should apply operator precedence and parentheses and work outward, promoting data types along the way.
## Assigning Values

### Assignment Operator

An assignment operator is a binary operator that modifies, or assigns, the variable on the left side of the operator with the result of the value on the right side of the equation.  Unlike most other Java operators, the assignment operator is evaluated from right to left.

The simplest assignment operator is the `=` assignment

```java
int herd = 1;
```

==**Java will automatically promote from smaller to larger data types, on arithmetic operators, but it will throw a compiler exception if it detects that you are trying to convert from larger to smaller data types without casting.**==

| Operator     | Example         | Description                                      |
|--------------|-----------------|--------------------------------------------------|
| Assignment   | `int a = 50;`    | Assigns the value on the right to the variable on the left. |
### Casting Values

Casting is a unary operation where one data type is explicitly interpreted as another data type. ==**Casting is optional and unnecessary when converting to a larger or widening data type, but it is required when converting to a smaller or narrowing data type.**== Without casting, the compiler will generate an error when trying to put a larger data type inside a smaller one.

Casting is performed by placing the data type, enclosed in parentheses, to the left of the value you want to cast.

```java
int fur = (int)5;
int hair = (short) 2;
String type = (String) "Bird";
short tail = (short)(4 + 10);
long feathers = 10(long); // DOES NOT COMPILE
```

Spaces between the cast and the value are optional.  it is common for the right side to also be in parentheses. Since casting is a unary operation, it would only be applied to the 4 if we didn’t enclose 4 + 10 in parentheses.

On the one hand, it is convenient that the compiler automatically casts smaller data types to larger ones. On the other hand, it makes for great exam questions when they do the opposite to see whether you are paying attention

```java
float egg = 2.0 / 9; // DOES NOT COMPILE
int tadpole = (int)5 * 2L; // DOES NOT COMPILE
short frog = 3 -2.0; // DOES NOT COMPILE
```

All of these examples involve putting a larger value into a smaller data type. casting can also be applied to objects and references. In those cases, though, no conversion is performed. ==**Put simply, casting a numeric value may change the data type, while casting an object only changes the reference to the object, not the object itself.**==

**Reviewing Primitive Assignments**

```java
int fish = 1.0; // DOES NOT COMPILE
short bird = 1921222; // DOES NOT COMPILE
int mammal = 9f; // DOES NOT COMPILE
long reptile = 192_301_398_193_810_323; // DOES NOT COMPILE
```

The first statement does not compile because you are trying to assign a double 1.0 to an integer value.
The second statement does not compile because the literal value 1921222 is outside the range of short, and the compiler detects this. The third statement does not compile because the f added to the end of the number instructs the compiler to treat the number as a floating-point value, but the assignment is to an int. Finally the last statement does not compile because Java interprets the literal as an int and notices that the value is larger than int allows. The literal would need a postfix L or l to be considered a long.

**Applying Casting**

==**Remember, casting primitives is required any time you are going from a larger numerical data type to a smaller numerical data type, or converting from a floating-point number to an integral value.**==

```java
int fish = (int)1.0;
short bird = (short)1921222; // Stored as 20678
int mammal = (int)9f;
```

```java
long reptile = (long)192301398193810323; // DOES NOT COMPILE
```

**This still does not compile because the value is first interpreted as an int by the compiler and is out of range.** The following fixes this code without requiring casting:

```java
long reptile = 192301398193810323L;
```

---
**Overflow and Underflow** 

The second value, 1,921,222, is too large to be stored as a short, so numeric overflow occurs, and it becomes 20,678. **Overflow is when a number is so large that it will no longer fit within the data type, so the system “wraps around” to the lowest negative value and counts up from there, similar to how modulus arithmetic works.  There’s also an analogous underflow, when the number is too low to fit in the data type, such as storing -200 in a byte field.**

```java
System.out.print(2147483647+1); // -2147483648
```

Since 2147483647 is the maximum int value, adding any strictly positive value to it will cause it to wrap to the smallest negative number.

---

**Numeric Promotion Example**

```java
short mouse = 10;
short hamster = 3;
short capybara = mouse * hamster; // DOES NOT COMPILE
```

short values are automatically promoted to int when applying any arithmetic operator, with the resulting value being of type int. Trying to assign a short variable with an int value results in a compiler error, as Java thinks you are trying to implicitly convert from a larger data type to a smaller one.  can be fix by casting

```java
short mouse = 10;
short hamster = 3;
short capybara = (short)(mouse * hamster);
```
 
 By casting a larger value into a smaller data type, you instruct the compiler to ignore its default behavior. In other words, you are telling the compiler that you have taken additional steps to prevent overflow or underflow. It is also possible that in your particular application and scenario, overflow or underflow would result in acceptable values.

Last but not least, casting can appear anywhere in an expression, not just on the assignment.

```java
short mouse = 10;
short hamster = 3;
short capybara = (short)mouse * hamster; // DOES NOT COMPILE
```

casting was a unary operation. That means the cast in the last line is applied to mouse, and mouse alone. After the cast is complete, both operands are promoted to int since they are used with the binary multiplication operator `(*)`, making the result an int and causing a compiler error.

```java
short capybara = 1 + (short)(mouse * hamster); // DOES NOT COMPILE
```

casting is performed successfully, but the resulting value is automatically promoted to int because it is used with the binary arithmetic operator `(+)`.
### Casting Values vs. Variables

==**the compiler doesn’t require casting when working with literal values that fit into the data type.**==

```java
byte hat = 1;
byte gloves = 7 * 10;
short scarf = 5;
short boots = 2 + 1;
```

```java
short boots = 2 + hat; // DOES NOT COMPILE
byte gloves = 7 * 100; // DOES NOT COMPILE
```

The first statement does not compile because hat is a variable, not a value, and both operands are automatically promoted to int. When working with values, the compiler had enough information to determine the writer’s intent. When working with variables, though, there is ambiguity about how to proceed, so the compiler reports an error.

The second expression does not compile because 700 triggers an overflow for byte, which has a maximum value of 127.

### Compound Assignment Operators

| Operator               | Example      | Description                                                                      |
|------------------------|--------------|----------------------------------------------------------------------------------|
| Addition assignment    | `a += 5`      | Adds the value on the right to the variable on the left and assigns the sum to the variable.  |
| Subtraction assignment | `b -= 0.2`    | Subtracts the value on the right from the variable on the left and assigns the difference to the variable. |
| Multiplication assignment | `c *= 100` | Multiplies the value on the right with the variable on the left and assigns the product to the variable. |
| Division assignment    | `d /= 4`      | Divides the variable on the left by the value on the right and assigns the quotient to the variable. |
Compound operators are really just glorified forms of the simple assignment operator, with a built-in arithmetic or logical operation that applies the left and right sides of the statement and stores the resulting value in the variable on the left side of the statement. 

```java
int camel = 2, giraffe = 3;
camel = camel * giraffe; // Simple assignment operator
camel *= giraffe; // Compound assignment operator
```

The left side of the compound operator can be applied only to a variable that is already defined and cannot be used to declare a new variable.
==**Compound operators are useful for more than just shorthand—they can also save you from having to explicitly cast a value.**==

```java
long goat = 10;
int sheep = 5;
sheep = sheep * goat; // DOES NOT COMPILE
```

We are trying to assign a ``long`` value to an ``int`` variable. This last line could be fixed with an explicit cast to (int), but there’s a better way using the compound assignment operator:

```java
long goat = 10;
int sheep = 5;
sheep *= goat;
```

The compound operator will first cast sheep to a long, apply the multiplication of two long values, and then cast the result to an int. Unlike the previous example, in which the compiler reported an error, the compiler will automatically cast the resulting value to the data type of the value on the left side of the compound operator.
### Return Value of Assignment Operators

One final thing to know about assignment operators is that ==**the result of an assignment is an expression in and of itself equal to the value of the assignment.**==

```java
long wolf = 5;
long coyote = (wolf=3);
System.out.println(wolf); // 3
System.out.println(coyote); // 3
```

The key here is that `(wolf=3)` does two things. First, it sets the value of the variable ``wolf`` to be 3. Second, it returns a value of the assignment, which is also 3.

```java
boolean healthy = false;
if(healthy = true)
System.out.print("Good!");
```

While this may look like a test if healthy is true, it’s actually assigning healthy a value of true. The result of the assignment is the value of the assignment, which is true, resulting in this snippet printing Good!
## Comparing Values

The last set of binary operators revolves around comparing values. They can be used to check if two values are the same, check if one numeric value is less than or greater than another, and perform ``Boolean`` arithmetic.
## Equality Operators

Determining equality in Java can be a nontrivial endeavor as there’s a semantic difference between “two objects are the same” and “two objects are equivalent.” It is further complicated by the fact that for numeric and boolean primitives, there is no such distinction.

The equals operator `(==)` and not equals operator `(!=)` compare two operands and return a boolean value determining whether the expressions or values are equal or not equal, respectively.

| Operator   | Example | Apply to Primitives                                     | Apply to Objects                                      |
|------------|---------|---------------------------------------------------------|--------------------------------------------------------|
| Equality   | a == 10 | Returns true if the two values represent the same value | Returns true if the two values reference the same object |
| Inequality | b != 3.14 | Returns true if the two values represent different values | Returns true if the two values do not reference the same object |
==**The equality operator can be applied to numeric values, `boolean` values, and objects (including `String` and `null`). When applying the equality operator, you cannot mix these types.**==

```java
boolean monkey = true == 3; // DOES NOT COMPILE
boolean ape = false != "Grape"; // DOES NOT COMPILE
boolean gorilla = 10.2 == "Koko"; // DOES NOT COMPILE
```

==**Pay close attention to the data types when you see an equality operator on the exam.**==

```java
boolean bear = false;
boolean polar = (bear = true);
System.out.println(polar); // true
```

In this example, though, the expression is assigning the value of `true` to `bear`, and on assignment operators, the assignment itself has the value of the assignment. Therefore, polar is also assigned a value of `true`, and the output is `true`.

==**For object comparison, the equality operator is applied to the references to the objects, not the objects they point to. Two references are equal if and only if they point to the same object or both point to ``null``.**==

```java
var monday = new File("schedule.txt");
var tuesday = new File("schedule.txt");
var wednesday = tuesday;
System.out.println(monday == tuesday); // false
System.out.println(tuesday == wednesday); // true
```

Even though all of the variables point to the same file information, only two references, `tuesday` and `wednesday`, are equal in terms of `==` since they point to the same object.

==**In some languages, comparing ``null`` with any other value is always false, although this is not the case in Java.**==

```java
System.out.print(null == null); // true
```
### Relational Operators

compare two expressions and return a `boolean` value. 

| Operator          | Example             | Description                                                |
|-------------------|---------------------|------------------------------------------------------------|
| Less than         | `a < 5`             | Returns true if the value on the left is strictly less than the value on the right |
| Less than or equal to | `b <= 6`         | Returns true if the value on the left is less than or equal to the value on the right |
| Greater than      | `c > 9`             | Returns true if the value on the left is strictly greater than the value on the right |
| Greater than or equal to | `3 >= d`      | Returns true if the value on the left is greater than or equal to the value on the right |
| Type comparison   | `e instanceof String` | Returns true if the reference on the left side is an instance of the type on the right side (class, interface, record, enum, annotation) |

**Numeric Comparison Operators**

The first four relational operators in Table 2.8 apply only to numeric values. ==**If the two numeric operands are not of the same data type, the smaller one is promoted**==

```java
int gibbonNumFeet = 2, wolfNumFeet = 4, ostrichNumFeet = 2;
System.out.println(gibbonNumFeet < wolfNumFeet); // true
System.out.println(gibbonNumFeet <= wolfNumFeet); // true
System.out.println(gibbonNumFeet >= ostrichNumFeet); // true
System.out.println(gibbonNumFeet > ostrichNumFeet); // false
```

**`instanceof` Operator**

It is useful for determining whether an arbitrary object is a member of a particular class or interface at runtime.
For now, all you need to know is objects can be passed around using a variety of references. For example, all classes inherit from `java.lang.Object`. This means that any instance can be assigned to an Object reference.

```java
Integer zooTime = Integer.valueOf(9);
Number num = zooTime;
Object obj = zooTime;
```

In this example, only one object is created in memory, but there are three different references to it because `Integer` inherits both `Number` and `Object`. This means that you can call instanceof on any of these references with three different data types, and it will return true for each of them.

```java
public void openZoo(Number time) {}
```

Now, want the function to add O'clock to the end of output if the value is a whole number type, such as an Integer; otherwise, it just prints the value.

```java
public void openZoo(Number time) {
if (time instanceof Integer)
System.out.print((Integer)time + " O'clock");
else
System.out.print(time);
}
```

It is common to use casting with instanceof when working with objects that can be various different types, since casting gives you access to fields available only in the more specific classes. **==It is considered a good coding practice to use the instanceof operator prior to casting from one object to a narrower type.==**

**Invalid ``instanceof``**

One area the exam might try to trip you up on is using `instanceof` with incompatible types. For example, `Number` cannot possibly hold a ``String`` value, so the following causes a compilation error:

```java
public void openZoo(Number time) {
if(time instanceof String) // DOES NOT COMPILE
System.out.print(time);
}
```

**``null`` and the ``instanceof`` operator**
==**calling instanceof on the null literal or a null reference always returns false.**==

```java
System.out.print(null instanceof Object); // false
Object noObjectHere = null;
System.out.print(noObjectHere instanceof String); // false
```
### Logical Operators

The logical operators, `(&)`, `(|)`, and `(^)`, may be applied to both numeric and boolean data types;  ==**When they’re applied to boolean data types, they’re referred to as logical operators. Alternatively, when they’re applied to numeric data types, they’re referred to as bitwise operators**==, as they perform bitwise comparisons of the bits that compose the number. 

| Operator              | Example     | Description                                                    |
|-----------------------|-------------|----------------------------------------------------------------|
| Logical AND           | `a & b`     | Value is true only if both values are true.                    |
| Logical inclusive OR  | `c \| d`    | Value is true if at least one of the values is true.           |
| Logical exclusive OR  | `e ^ f`     | Value is true only if one value is true and the other is false.|
![[Pasted image 20240118220950.png]]


- ==**AND is only true if both operands are true.**==
- ==**Inclusive OR is only false if both operands are false.**==
- ==**Exclusive OR is only true if the operands are different.**==

```java
boolean resting = eyesClosed | breathingSlowly;
boolean asleep = eyesClosed & breathingSlowly;
boolean awake = eyesClosed ^ breathingSlowly;
System.out.println(resting); // true
System.out.println(asleep); // true
System.out.println(awake); // false
```
### Conditional Operators

| Operator          | Example    | Description                                                                      |
|-------------------|------------|----------------------------------------------------------------------------------|
| Conditional AND   | `a && b`   | Value is true only if both values are true. If the left side is false, then the right side will not be evaluated. |
| Conditional OR    | `c \|\| d` | Value is true if at least one of the values is true. If the left side is true, then the right side will not be evaluated. |
The conditional operators, often called short-circuit operators, are nearly identical to the logical operators, `&` and `|`, ==**except that the right side of the expression may never be evaluated if the final result can be determined by the left side of the expression.**==

```java
int hour = 10;
boolean zooOpen = true || (hour < 4);
System.out.println(zooOpen); // true
```

Since we know the left side is true, there’s no need to evaluate the right side, since no value of hour will ever make this code print `false`. In other words, hour could have been -10 or 892; the output would have been the same.
### Avoiding a `NullPointerException`

A more common example of where conditional operators are used is checking for `null` objects before performing an operation.

```java
if(duck!=null & duck.getAge()<5) { // Could throw a NullPointerException
// Do something
}
```
 
 The issue is that the logical `AND (&)` operator evaluates both sides of the expression. We could add a second if statement, but this could get unwieldy if we have a lot of variables to check. An easy-to- read solution is to use the conditional `AND` operator `(&&)`:

```java
if(duck!=null && duck.getAge()<5) {
// Do something
}
```
### Checking for Unperformed Side Effects

==**Be wary of short-circuit behavior on the exam, as questions are known to alter a variable on the right side of the expression that may never be reached. This is referred to as an unperformed side effect.**==

```java
int rabbit = 6;
boolean bunny = (rabbit >= 6) || (++rabbit <= 7);
System.out.println(rabbit);
```

Because `rabbit >= 6` is `true`, the increment operator on the right side of the expression is never evaluated, so the output is 6.

## Making Decisions with the Ternary Operator

It is notable in that it is the only operator that takes three operands.
```java
booleanExpression ? expression1 : expression2
```

==**The first operand must be a boolean expression, and the second and third operands can be any expression that returns a value.** ==The ternary operation is really a condensed form of a combined if and else statement that returns a value.

```java
for an owl:
int owl = 5;
int food;
if(owl < 2) {
food = 3;
} else {
food = 4;
}
System.out.println(food); // 4
```

```java
int owl = 5;
int food = owl < 2 ? 3 : 4;
System.out.println(food); // 4
```

These two code snippets are equivalent. Note that it is often helpful for readability to add parentheses around the expressions in ternary operations, although doing so is certainly not required.

```java
int food1 = owl < 4 ? owl > 2 ? 3 : 4 : 5;
int food2 = (owl < 4 ? ((owl > 2) ? 3 : 4) : 5);
```

For the exam, you should know that there is no requirement that second and third expressions in ternary operations have the same data types, although it does come into play when combined with the assignment operator.

```java
int stripes = 7;
System.out.print((stripes > 5) ? 21 : "Zebra");
int animal = (stripes < 9) ? 3 : "Horse"; // DOES NOT COMPILE
```

Both expressions evaluate similar `boolean` values and return an `int` and a `String`, although only the first one will compile. `System.out.print()` does not care that the expressions are completely different types, because it can convert both to Object values and call `toString()` on them. On the other hand, the compiler does know that "Horse" is of the wrong data type and cannot be assigned to an int; therefore, it does not allow the code to be compiled.

---
**Ternary Expression and Unperformed Side Effects** #TIP 

ternary expression can contain an unperformed side effect, as only one of the expressions on the right side will be evaluated at runtime.

```java
int sheep = 1;
int zzz = 1;
int sleep = zzz<10 ? sheep++ : zzz++;
System.out.print(sheep + "," + zzz); // 2,1
```

Notice that since the left-hand `boolean` expression was true, only sheep was incremented.

```java
int sheep = 1;
int zzz = 1;
int sleep = sheep>=10 ? sheep++ : zzz++;
System.out.print(sheep + "," + zzz); // 1,2
```

Now that the left-hand boolean expression evaluates to false, only `zzz` is incremented.

---

## Summary  #OCP_Summary 

==**This chapter provides a comprehensive overview of Java operators, encompassing unary, binary, and ternary operators. Familiarity with these operators is crucial, and if any are not yet well-understood, a thorough study is recommended. A solid grasp of how to utilize the various Java operators covered in this chapter, coupled with an understanding of operator precedence and the impact of parentheses on expression interpretation, is essential.**==

==**During the exam, seemingly unrelated questions may actually test knowledge of specific operators, potentially causing compilation failures. Always scrutinize numeric operators, verifying that appropriate data types are used and match where necessary. Since operators are pervasive in exam code samples, a strong comprehension of this chapter enhances preparedness for the OCP**==

## Exam Essentials #Essential 

**Be able to recognize which operators are associated with which data types.**  This chapter covered a wide variety of operator symbols. Go back and review them several times so that you are familiar with them throughout the rest of the book.

**Be able to recognize which operators are associated with which data types.** Some operators may be applied only to numeric primitives, some only to boolean values, and some only to objects. It is important that you notice when an operator and operand(s) are mismatched, as this issue is likely to come up in a couple of exam questions.

**Understand when casting is required or numeric promotion occurs.** Whenever you mix operands of two different data types, the compiler needs to decide how to handle the resulting data type. ==**When you’re converting from a smaller to a larger data type, numeric promotion is automatically applied. When you’re converting from a larger to a smaller data type casting is required.**==

**Understand Java operator precedence.** Most Java operators you’ll work with are binary, but the number of expressions is often greater than two. Therefore, you must understand the order in which Java will evaluate each operator symbol.

**Be able to write code that uses parentheses to override operator precedence.** can use parentheses in your code to manually change the order of precedence.

## Review Questions

1. Which of the following Java operators can be used with boolean variables? (Choose all that apply.)
A. ==
B. +
C. --
D. !
E. %
F. ~
G. Cast with (boolean)

**My Answer:  A,D,G**
**Correct Answer: A,D,G**

**Option F is a bitwise complement operator and can only be applied to integer values. Finally,**
**option G is correct, as you can cast a boolean variable since boolean is a type.**

---

2. What data type (or types) will allow the following code snippet to compile? (Choose all that apply.)

```java
byte apples = 5;
short oranges = 10;
_____ bananas = apples + oranges;
```

A. int
B. long
C. boolean
D. double
E. short
F. byte

**My Answer : A**
**Correct Answer: A,B,D**

**The expression apples + oranges is automatically promoted to int, so int and data types that can be promoted automatically from int will work. Options A, B, and D are such data types.** 

---

3. What change, when applied independently, would allow the following code snippet to compile? (Choose all that apply.)

```java
3: long ear = 10;
4: int hearing = 2 * ear;
```

A. No change; it compiles as is.
B. Cast ear on line 4 to int.
C. Change the data type of ear on line 3 to short.
D. Cast 2 * ear on line 4 to int.
E. Change the data type of hearing on line 4 to short.
F. Change the data type of hearing on line 4 to long.

**My Answer : B,C,D,F**
**Correct Answer: B,C,D,F**

---

4. What is the output of the following code snippet?

```java
3: boolean canine = true, wolf = true;
4: int teeth = 20;
5: canine = (teeth != 10) ^ (wolf=false);
6: System.out.println(canine+", "+teeth+", "+wolf);
```

A. true, 20, true
B. true, 20, false
C. false, 10, true
D. false, 20, false
E. The code will not compile because of line 5.
F. None of the above.

**My Answer : D**
**Correct Answer: B**

---

5. Which of the following operators are ranked in increasing or the same order of precedence? Assume the + operator is binary addition, not the unary form. (Choose all that apply.)

`A. +, *, %, --`
`B.`
`++, (int), *`
`C. =, ==, !`
`D. (short), =, !, *`
`E. *, /, %, +, ==`
`F. !, ||, &`
`G. ^, +, =, +=`

**My Answer : A,C**
**Correct Answer: A,C**



---

6. What is the output of the following program?

```java
1: public class CandyCounter {
2: static long addCandy(double fruit, float vegetables) {
3: return (int)fruit+vegetables;
4: }
5:
6: public static void main(String[] args) {
7: System.out.print(addCandy(1.4, 2.4f) + ", ");
8: System.out.print(addCandy(1.9, (float)4) + ", ");
9: System.out.print(addCandy((long)(int)(short)2, (float)4)); } }
```
A. 4, 6, 6.0
B. 3, 5, 6
C. 3, 6, 6
D. 4, 5, 6
E. The code does not compile because of line 9.
F. None of the above.

**My Answer : F**
**Correct Answer: F**

**The code does not compile because line 3 contains a compilation error. The cast (int) is applied to fruit, not the expression `fruit+vegetables`. Since the cast operator has a higher operator precedence than the addition operator, it is applied to fruit, but the expression is promoted to a float, due to vegetables being float. The result cannot be returned as long in the `addCandy()` method without a cast. For this reason, option F is correct. If parentheses were added around `fruit+vegetables`, then the output would be 3, 5, 6, and option B would be correct. Remember that ==casting floating-point numbers to integral values results in truncation, not rounding.==**

---

7. What is the output of the following code snippet?

```java
int ph = 7, vis = 2;
boolean clear = vis > 1 & (vis < 9 || ph < 2);
boolean safe = (vis > 2) && (ph++ > 1);
boolean tasty = 7 <= -- ph;
System.out.println(clear + "-" + safe + "-" + tasty);
```

A. true-true-true
B. true-true-false
C. true-false-true
D. true-false-false
E. false-true-true
F. false-true-false
G. false-false-true
H. false-false-false

**My Answer : H**
**Correct Answer: D**

---

8. What is the output of the following code snippet?

```java
4: int pig = (short)4;
5: pig = pig++;
6: long goat = (int)2;
7: goat -= 1.0;
8: System.out.print(pig + " -" + goat);
```

A. 4 -1
B. 4 -2
C. 5 -1
D. 5 -2
E. The code does not compile due to line 7.
F. None of the above.

**My Answer : E**
**Correct Answer: A**

**Line 7 does not produce a compilation error since ==the compound operator applies casting automatically==.**

---

9. What are the unique outputs of the following code snippet? (Choose all that apply.)

```java
int a = 2, b = 4, c = 2;
System.out.println(a > 2 ? -- c: b++);
System.out.println(b = (a!=c ? a : b++));
System.out.println(a > b ? b < c ? b : 2 : 1);
```

A. 1
B. 2
C. 3
D. 4
E. 5
F. 6
G. The code does not compile.

**My Answer : A**
**Correct Answer: A,D,E**

---

10. What are the unique outputs of the following code snippet? (Choose all that apply.)

```java
short height = 1, weight = 3;
short zebra = (byte) weight * (byte) height;
double ox = 1 + height * 2 + weight;
long giraffe = 1 + 9 % height + 1;
System.out.println(zebra);
System.out.println(ox);
System.out.println(giraffe);
```

A. 1
B. 2
C. 3
D. 4
E. 5
F. 6
G. The code does not compile.

**My Answer : G**
**Correct Answer: G**
 
 **The code does not compile due to an error on the second line. Even though both height and weight are cast to byte, the multiplication operator automatically promotes them to int, resulting in an attempt to store an int in a short variable**

---

11. What is the output of the following code?

```java
11: int sample1 = (2 * 4) % 3;
12: int sample2 = 3 * 2 % 3;
13: int sample3 = 5 * (1 % 2);
14: System.out.println(sample1 + ", " + sample2 + ", " + sample3);
```

A. 0, 0, 5
B. 1, 2, 10
C. 2, 1, 5
D. 2, 0, 5
E. 3, 1, 10
F. 3, 2, 6
G. The code does not compile.

**My Answer : D**
**Correct Answer: D**

---

12. The _________ operator increases a value and returns the original value, while the _______ operator decreases a value and returns the new value.
A. post-increment, post-increment
B. pre-decrement, post-decrement
C. post-increment, post-decrement
D. post-increment, pre-decrement
E. pre-increment, pre-decrement
F. pre-increment, post-decrement

**My Answer : C**
**Correct Answer: D**

---

13. What is the output of the following code snippet?

```java
boolean sunny = true, raining = false, sunday = true;
boolean goingToTheStore = sunny & raining ^ sunday;
boolean goingToTheZoo = sunday && !raining;
boolean stayingHome = !(goingToTheStore && goingToTheZoo);
System.out.println(goingToTheStore + "-" + goingToTheZoo + "-" +stayingHome);
```

A. true-false-false
B. false-true-false
C. true-true-true
D. false-true-true
E. false-false-false
F. true-true-false
G. None of the above

**My Answer : F**
**Correct Answer: F**

---

14. Which of the following statements are correct? (Choose all that apply.)

A. The return value of an assignment operation expression can be void.
B. The inequality operator (!=) can be used to compare objects.
C. The equality operator (`==`) can be used to compare a boolean value with a numeric
value.
D. During runtime, the & and | operators may cause only the left side of the expression to
be evaluated.
E. The return value of an assignment operation expression is the value of the newly
assigned variable.
F. In Java, 0 and false may be used interchangeably.
G. The logical complement operator (!) cannot be used to flip numeric values.

**My Answer : B,E,G**
**Correct Answer: B,E,G**

---

15. Which operators take three operands or values? (Choose all that apply.)

A. =
B. &&
C. *=
D. ? :
E. &
F. ++
G. /

**My Answer : D**
**Correct Answer: D**

---

16. How many lines of the following code contain compiler errors?

```java
int note = 1 * 2 + (long)3;
short melody = (byte)(double)(note *= 2);
double song = melody;
float symphony = (float)((song == 1_000f) ? song * 2L : song);
```

A. 0
B. 1
C. 2
D. 3
E. 4

**My Answer : C**
**Correct Answer: B**

**The first line contains a compilation error. The value 3 is cast to long. The 1 * 2 value is evaluated as int but promoted to long when added to the 3. Trying to store a long value in an int variable triggers a compiler error. The other lines do not contain any compilation errors, as they store smaller values in larger or same-size data types**

---

17. Given the following code snippet, what are the values of the variables after it is executed? (Choose all that apply.)

```java
int ticketsTaken = 1;
int ticketsSold = 3;
ticketsSold += 1 + ticketsTaken++;
ticketsTaken *= 2;
ticketsSold += (long)1;
```

A. ticketsSold is 8.
B. ticketsTaken is 2.
C. ticketsSold is 6.
D. ticketsTaken is 6.
E. ticketsSold is 7.
F. ticketsTaken is 4.
G. The code does not compile.

**My Answer : G**
**Correct Answer: C,F**

**Note the last line does not trigger a compilation error as the compound operator automatically casts the right-hand operand.**

---

18. Which of the following can be used to change the order of operation in an expression? (Choose all that apply.)
A. [ ]
B. < >
C. ( )
D. \ /
E. { }
F. " "

**My Answer : C**
**Correct Answer: C**

---

19. What is the result of executing the following code snippet? (Choose all that apply.)

```JAVA
3: int start = 7;
4: int end = 4;
5: end += ++start;
6: start = (byte)(Byte.MAX_VALUE + 1);
```

A. start is 0.
B. start is -128.
C. start is 127.
D. end is 8.
E. end is 11.
F. end is 12.
G. The code does not compile.
H. The code compiles but throws an exception at runtime.

**My Answer : B,F**
**Correct Answer: B,F**

---

20. Which of the following statements about unary operators are true? (Choose all that apply.)
A. Unary operators are always executed before any surrounding numeric binary or ternary operators.
B. The -operator can be used to flip a boolean value.
C. The pre-increment operator (++) returns the value of the variable before the increment is applied.
D. The post-decrement operator (-- )returns the value of the variable before the decrement is applied.
E. The ! operator cannot be used on numeric values.
F. None of the above

**My Answer : A,D,E**
**Correct Answer: A,D,E**

---

21.  What is the result of executing the following code snippet?
```java
int myFavoriteNumber = 8;
int bird = ~myFavoriteNumber;
int plane = -myFavoriteNumber;
var superman = bird == plane ? 5 : 10;
System.out.println(bird + "," + plane + "," + --superman);
```

A. -7,-
8,9
B. -7,-
8,10
C. -8,-
8,4
D. -8,-
8,5
E. -9,-
8,9
F. -9,-
8,10
G. None of the above

**My Answer : E**
**Correct Answer: E**

---

# Chapter 3 - Making Decisions #Chapter

## Creating Decision-Making Statements

### Statements and Blocks

a Java statement is a complete unit of execution in Java, terminated with a semicolon `(;)`. 
*Control flow* statements break up the flow of execution by using decision-making, looping, and branching, allowing the application to selectively execute particular segments of code.

a block of code in Java is a group of zero or more statements between balanced braces `({})` and can be used anywhere a single statement is allowed.

```java
// Single statement
patrons++;

// Statement inside a block
{
	patrons++;
}
```

A statement or block often serves as the target of a decision-making statement.

```java
// Single statement
if(ticketsTaken > 1)
	patrons++;
// Statement inside a block
if(ticketsTaken > 1)
{
	patrons++;
}
```

the target of a decision-making statement can be a single statement or block of statements.

---
**While both of the previous examples are equivalent, stylistically using blocks is often preferred, even if the block has only one statement. The second form has the advantage that you can quickly insert new lines of code into the block, without modifying the surrounding structure.**

---

### The `if` Statement

==**The `if` statement, execute a particular block of code if and only if a `boolean` expression evaluates to `true` at runtime.**==

```java
if(hourOfDay < 11)
	System.out.println("Good Morning");

if(hourOfDay < 11) {
	System.out.println("Good Morning");
	morningGreetingCount++;
}
```

---
**Watch Indentation and Braces**  #TIP
**One area where the exam writers will try to trip you up is if statements without braces `({})`. For example, take a look at this slightly modified form of our example:**

```java
if(hourOfDay < 11)
	System.out.println("Good Morning");
morningGreetingCount++;
```
 
 **Based on the indentation, you might be inclined to think the variable `morningGreetingCount` is only going to be incremented if `hourOfDay` is less than 11, but that’s not what this code does. It will execute the print statement only if the condition is met, but it will always execute the increment operation.** 

**in Java, unlike some other programming languages, tabs are just whitespace and are not evaluated as part of the execution. When you see a control flow statement in a question, be sure to trace the open and close braces of the block, ignoring any indentation you may come across.**

---
### The `else` Statement

```java
if(hourOfDay < 11) {
	System.out.println("Good Morning");
}
if(hourOfDay >= 11) {
	System.out.println("Good Afternoon");
}
```

**redundant**

```java
if(hourOfDay < 11) {
	System.out.println("Good Morning");
} else System.out.println("Good Afternoon");
```

code is truly branching between one of the two possible options, with the `boolean` evaluation happening only once. The `else` operator takes a statement or block of statements, in the same manner as the `if` statement. Similarly, we can append additional if statements to an else block to arrive at a more refined

```java
if(hourOfDay < 11) {
	System.out.println("Good Morning");
} else if(hourOfDay < 15) {
	System.out.println("Good Afternoon");
} else {
	System.out.println("Good Evening");
}
```

---
**Verifying That the if Statement Evaluates to a Boolean Expression**

**Another common way the exam may try to lead you astray is by providing code where the `boolean` expression inside the if statement is not actually a boolean expression**

```java
int hourOfDay = 1;
if(hourOfDay) { // DOES NOT COMPILE
	...
}
```

---
### Shortening Code with Pattern Matching

Pattern matching is reduce the boilerplate in your code.  A lot of the newer enhancements to the Java language focus on reducing boilerplate code.

```java
void compareIntegers(Number number) {
	if(number instanceof Integer) {
		Integer data = (Integer)number;
		System.out.print(data.compareTo(5));
	}
}
```

The cast is needed since the `compareTo()` method is defined on ``Integer``, but not on ``Number``. 

```java
void compareIntegers(Number number) {
	if(number instanceof Integer data) { 
		System.out.print(data.compareTo(5));
	}
}
```

==**The variable data in this example is referred to as the pattern variable**==. Notice that this code also avoids any potential `ClassCastException` because the cast operation is executed only if the implicit ``instanceof`` operator returns true.

==**The pattern variables are those that store data from the target only if the predicate returns `true` which is `instanceof`**==

---

**Reassigning Pattern Variables**

**While possible, it is a bad practice to reassign a pattern variable since doing so can lead to ambiguity about what is and is not in scope.**

```java
if(number instanceof Integer data) {
	data = 10;
}
```

**The reassignment can be prevented with a `final` modifier, but it is better not to reassign the variable at all.**

```java
if(number instanceof final Integer data) {
	data = 10; // DOES NOT COMPILE
}
```

---
#### Pattern Variables and Expressions

```java
void printIntegersGreaterThan5(Number number) {
	if(number instanceof Integer data && data.compareTo(5)>0)
		System.out.print(data);
}
```

We can apply a number of filters, or patterns, so that the if statement is executed only in specific circumstances. ==**Notice that we’re using the pattern variable in an expression in the same line in which it is declared.**==
#### Subtypes

==**The type of the pattern variable must be a subtype of the variable on the left side of the expression. It also cannot be the same type. This rule does not exist for traditional `instanceof` operator expressions**==, though

```java
Integer value = 123;
if(value instanceof Integer) {}
if(value instanceof Integer data) {} // DOES NOT COMPILE
```

While the second line compiles, ==**the last line does not compile because pattern matching requires that the pattern variable type Integer be a strict subtype of Integer.**==


---
**Limitations of Subtype Enforcement**

The compiler has some limitations on enforcing pattern matching types when we mix classes and interfaces. For example, given the non-final class Number and interface List, this does compile even though they are unrelated:

```java
Number value = 123;
if(value instanceof List) {}
if(value instanceof List data) {}
```

```java
private static void patternMatchingMethodSample(Animal animal) {  
	if (animal instanceof Bird obj) {  
		System.out.println("Bird object!");  
	} else if (animal instanceof Dog obj) {  
		System.out.println("Dog object!");  
	} else if (animal instanceof Cat obj) {  
		System.out.println("Cat object!");  
	}//else if (animal instanceof Animal obj) { } // DOES NOT COMPILE  
	else if (animal instanceof Walkable obj) {  
		System.out.println("Walkable obj");  
	}    }}  
  
interface Flyable {  
  
}  
  
interface Walkable {  
}  
  
class Bird extends Animal implements Flyable {  
  
}  
  
class Chicken extends Bird implements Walkable {  
}  
  
final class Cat extends Animal {  
}  
  
class Dog extends Animal {  
}  
  
class Animal {  
}  
  
class Horse extends Animal implements Walkable {  
}
```

---
#### Flow Scoping

The compiler applies flow scoping when working with pattern matching. ==**Flow scoping means the variable is only in scope when the compiler can definitively determine its type.**==  Flow scoping is unlike any other type of scoping in that it is not strictly hierarchical like instance, class, or local scoping. It is determined by the compiler based on the branching and flow of the program.

```java
void printIntegersOrNumbersGreaterThan5(Number number) {
	if(number instanceof Integer data || data.compareTo(5)>0) // DOES NOT COMPILE
		System.out.print(data);
}
```

If the input does not inherit ``Integer``, the data variable is undefined. Since the compiler cannot guarantee that data is an instance of ``Integer``, data is not in scope, and the code does not compile. 

```java
void printIntegerTwice(Number number) {
if (number instanceof Integer data)
	System.out.print(data.intValue());
	System.out.print(data.intValue()); // DOES NOT COMPILE
}
```

Since the input might not have inherited Integer, data is no longer in scope after the if statement.

```java
void printOnlyIntegers(Number number) {
if (!(number instanceof Integer data))
	return;
System.out.print(data.intValue());
}
```

**==this code does compile! The method returns if the input does not inherit ``Integer``. This means that when the last line of the method is reached, the input must inherit ``Integer``, and therefore data stays in scope even after the if statement ends.==**

---
**Flow Scoping and else Branches**

**Another way to think about it is to rewrite the logic to something equivalent that uses an `else` statement:**

```java
void printOnlyIntegers(Number number) {
	if (!(number instanceof Integer data))
		return;
	else
		System.out.print(data.intValue());
	}
```

**go one step further and reverse the if and else branches by inverting the boolean expression:**

```java
void printOnlyIntegers(Number number) {
	if (number instanceof Integer data)
		System.out.print(data.intValue());
	else
		return;
	}
```

**new code is equivalent to our original and better demonstrates how the compiler was able to determine that data was in scope only when number is an Integer.**

```java
public static boolean bigEnoughRect(Shape s) {
    if (!(s instanceof Rectangle r)) {
        // This block checks whether the object "s" is of type "Rectangle".
        // If not, it enters this block.
        
        // Inside this block, it is not possible to use the pattern variable "r"
        // because the pattern matching expression (s instanceof Rectangle) is false,
        // and the "r" pattern variable is only valid in the matching case.
        
        return false; // Return false if the object is not of type "Rectangle".
    }

    // If the above condition is true, we reach this point.
    // This means that the object "s" is of type "Rectangle" and the pattern variable "r" is valid from this point onward.

    // Now, we can use the "r" pattern variable because at this point, the expression "s instanceof Rectangle" is true.
    // The "r" pattern variable represents the "s" object, which is now of type "Rectangle".

    return r.length() > 5;
}
```

```java
public static boolean bigEnoughRect(Shape s) {
        if (s instanceof Rectangle r) {
            r = (Rectangle) s; // Assign value inside the if block
        } else {
	        return false;
        }
        // You can use r here.
        return r.length() > 5; 
    }
```

---

==**In particular, it is possible to use a pattern variable outside of the if statement, but only when the compiler can definitively determine its type.**==
## Applying `switch` Statements

```java
public void printDayOfWeek(int day) {
if(day == 0)
System.out.print("Sunday");
else if(day == 1)
System.out.print("Monday");
else if(day == 2)
System.out.print("Tuesday");
else if(day == 3)
System.out.print("Wednesday");
...
}
```

code that is long, difficult to read, and often not fun to maintain

###  The `switch` Statement 

A ``switch`` statement is a complex decision-making structure in which a single value is evaluated and flow is redirected to the first matching branch, known as a case statement. If no such case statement is found that matches the value, an optional default statement will be called. If no such default option is available, the entire switch statement will be skipped.

![[Pasted image 20240126183854.png]]

**Because `switch` statements can be longer than most decision-making statements, the exam may present invalid `switch` syntax to see whether you are paying attention.**

---
**Combining case Values**

**Starting with Java 14, case values can now be combined:**

```java
switch(animal) {
	case 1,2: System.out.print("Lion");
	case 3: System.out.print("Tiger");
}
```

---

```java
int month = 5;
switch month { // DOES NOT COMPILE
	case 1: System.out.print("January");
}

switch(month) // DOES NOT COMPILE
	case 1: System.out.print("January");

switch(month) {
	case 1: 2: System.out.print("January"); // DOES NOT COMPILE
}
```

- **==The first switch statement does not compile because it is missing parentheses around the switch variable.==** 
- **==The second statement does not compile because it is missing braces around the switch body.==**
- **==The third statement does not compile because a comma `(,)` should be used to separate combined case statements, not a colon `(:)`.==**
- ==**a switch statement is not required to contain any case statements.**==

```java
switch(month) {} // Perfectly Valid !!!
```

```java
public void printDayOfWeek(int day) {
	switch(day) {
	case 0:
		System.out.print("Sunday");
		break;
	case 1:
		System.out.print("Monday");
		break;
	case 2:
		System.out.print("Tuesday");
		break;
	case 3:
		System.out.print("Wednesday");
		break;
	case 4:
		System.out.print("Thursday");
		break;
	case 5:
		System.out.print("Friday");
		break;
	case 6:
		System.out.print("Saturday");
		break;
	default:
		System.out.print("Invalid value");
		break;
	} 
}
```

### Exiting with `break` Statements

`break` statement terminates the ``switch`` statement and returns flow control to the enclosing process. Put simply, it ends the ``switch`` statement immediately.

The ``break`` statements are optional, but without them the code will execute every branch following a matching case statement, including any default statements it finds. Without ``break`` statements in each branch, the order of case and default statements is now extremely important.

```java
switch(month) {
case 1, 2, 3: System.out.print("Winter");
case 4, 5, 6: System.out.print("Spring");
default: System.out.print("Unknown");
case 7, 8, 9: System.out.print("Summer");
case 10, 11, 12: System.out.print("Fall");
} }
```

the output: 
```text
WinterSpringUnknownSummerFall
```

---
**The exam creators are fond of ``switch`` examples that are missing ``break`` statements! When evaluating ``switch`` statements on the exam, always consider that multiple branches may be visited in a single execution.** #TIP 

---
### Selecting ``switch`` Data Types

a switch statement has a target variable that is not evaluated until runtime. The type of this target can include select primitive data types (``int, byte, short, char``) and their associated wrapper classes (``Integer, Byte, Short, Character``)
The following all data types supported by switch statements

- ==**``int`` and ``Integer``**==
- ==**``byte`` and ``Byte``**==
- ==**``short`` and ``Short``**==
- ==**``char`` and ``Character``**==
- ==**``String``**==
- ==**``enum`` values**==
- ==**``var`` (if the type resolves to one of the preceding types)**==

---
**``boolean``, ``long``, ``float``, and ``double`` are excluded from ``switch`` statements, as are their associated ``Boolean``, ``Long``, ``Float``, and ``Double`` classes. The reasons are varied, such as boolean having too small a range of values and floating-point numbers having quite a wide range of values. For the exam, though, you just need to know that they are not permitted in switch statements.**

---
### Determining Acceptable Case Values

Not just any variable or value can be used in a case statement. First, ==**the values in each case statement must be compile-time constant values of the same data type as the switch value. This means you can use only literals, enum constants, or final constant variables of the same data type.**== By final constant, we mean that the variable must be marked with the final modifier and initialized with a literal value in the same expression in which it is declared.

```java
final int getCookies() { return 4; }
void feedAnimals() {
final int bananas = 1;
int apples = 2;
int numberOfAnimals = 3;
final int cookies = getCookies();
switch(numberOfAnimals) {
case bananas:
case apples: // DOES NOT COMPILE
case getCookies(): // DOES NOT COMPILE
case cookies : // DOES NOT COMPILE
case 3 * 5 :
} }
```

- The ``bananas`` variable is marked ``final``, and its value is known at compile-time, so it is valid. 
- The `apples` variable is not marked ``final``, even though its value is known, so it is not permitted.
- The next two case statements, with values ``getCookies()`` and ``cookies``, do not compile because methods are not evaluated until runtime, so they cannot be used as the value of a case statement, even if one of the values is stored in a final variable
- The last case statement, with value ``3 * 5``, does compile, as expressions are allowed as case values, provided the value can be resolved at compile-time.
- ==**They also must be able to fit in the ``switch`` data type without an explicit cast.**==
- ==**The data type for case statements must match the data type of the ``switch`` variable.**==
### The ``switch`` Expression

A ``switch`` expression is a much more compact form of a ``switch`` statement, ==**capable of returning a value**==.
Because a ``switch`` expression is a compact form, there’s a lot going on. For starters, we can now assign the result of a ``switch`` expression to a variable result. ==**For this to work, all case and default branches must return a data type that is compatible with the assignment.**== The ``switch`` expression supports two types of branches: an expression and a block. Each has different syntactical rules on how it must be created.

![[Pasted image 20240126193026.png]]

Like a traditional ``switch`` statement, a ``switch`` expression supports zero or many case branches and an optional ``default`` branch. Both also support the new feature that allows case values to be combined with a single case statement using commas. Unlike a traditional ``switch`` statement, though, ``switch`` expressions have special rules around when the ``default`` branch is required.

---

**that ``->`` is the arrow operator. While the arrow operator is commonly used in lambda expressions, when it is used in a ``switch`` expression, the case branches are not lambdas.**

---

```java
public void printDayOfWeek(int day) {
	var result = switch(day) {
		case 0 -> "Sunday";
		case 1 -> "Monday";
		case 2 -> "Tuesday";
		case 3 -> "Wednesday";
		case 4 -> "Thursday";
		case 5 -> "Friday";
		case 6 -> "Saturday";
		default -> "Invalid value";
	};
	System.out.print(result);
}
```

==**Notice that a semicolon is required after each ``switch`` expression.**== 

```java
var result = switch(bear) {
	case 30 -> "Grizzly"
	default -> "Panda"
}
```
**Does not compile**

Each case or ``default`` expression requires a semicolon as well as the assignment itself.

```java
var result = switch(bear) {
	case 30 -> "Grizzly";
	default -> "Panda";
};
```

case statements can take multiple values, separated by commas.

```java
public void printSeason(int month) {
	switch(month) {
		case 1, 2, 3 -> System.out.print("Winter");
		case 4, 5, 6 -> System.out.print("Spring");
		case 7, 8, 9 -> System.out.print("Summer");
		case 10, 11, 12 -> System.out.print("Fall");
	} 
}
```

---

**Most of the time, a ``switch`` expression returns a value, although ``printSeason()`` demonstrates one in which the return type is ``void``. Since the type is ``void``, it can’t be assigned to a variable. On the exam, you are more likely to see a ``switch`` expression that returns a value, but you should be aware that it is possible.**

---

All of the previous rules around ``switch`` data types and case values still apply, although we have some new rules.

1. ==**All of the branches of a ``switch`` expression that do not ``throw`` an exception must return a consistent data type (if the ``switch`` expression returns a value).**==
2. ==**If the ``switch`` expression returns a value, then every branch that isn’t an expression must ``yield`` a value.**==
3. ==**A default branch is required unless all cases are covered or no value is returned.**==
#### Returning Consistent Data Types

You can’t return incompatible or random data types.
```java
int measurement = 10;
int size = switch(measurement) {
	case 5 -> 1;
	case 10 -> (short)2;
	default -> 5;
	case 20 -> "3"; // DOES NOT COMPILE
	case 40 -> 4L; // DOES NOT COMPILE
	case 50 -> null; // DOES NOT COMPILE
};
```

Notice that the second case expression returns a ``short``, but that can be implicitly cast to an ``int``. In this manner, ==**the values have to be consistent with size, but they do not all have to be the same data type**.==
#### Applying a case Block

A ``switch`` expression supports both an expression and a block in the case and default branches. Like a regular block, a case block is one that is surrounded by braces ``({})``. It also includes a ``yield`` statement if the switch expression returns a value.

```java
int fish = 5;
int length = 12;
var name = switch(fish) {
	case 1 -> "Goldfish";
	case 2 -> {yield "Trout";}
	case 3 -> {
		if(length > 10) yield "Blobfish";
		else yield "Green";
	}
	default -> "Swordfish";
};
```

The ``yield`` keyword is equivalent to a return statement within a ``switch`` expression and is used to avoid ambiguity about whether you meant to exit the block or method around the switch expression.

==**``switch`` expressions, ``yield`` statements are NOT OPTIONAL if the switch statement RETURNS a value.**==

```java
10: int fish = 5;
11: int length = 12;
12: var name = switch(fish) {
	13: case 1 -> "Goldfish";
	14: case 2 -> {} // DOES NOT COMPILE
	15: case 3 -> {
		16: if(length > 10) yield "Blobfish";
	17: } // DOES NOT COMPILE
	18: default -> "Swordfish";
19: };
```

- Line 14 does not compile because it does not return a value using ``yield``.
- Line 17 also does not compile. While the code returns a value for length greater than 10, it does not return a value if length is less than or equal to 10.

It does not matter that length is set to be 12; all branches must ``yield`` a value within the case block.

---
**Watch Semicolons in ``switch`` Expressions**
**Unlike a regular ``switch`` statement, a ``switch`` expression can be used with the assignment operator and requires a semicolon when doing so. Furthermore, semicolons are required for case expressions but cannot be used with case blocks.**

```java
var name = switch(fish) {
case 1 -> "Goldfish" // DOES NOT COMPILE (missing semicolon)
case 2 -> {yield "Trout";}; // DOES NOT COMPILE (extra semicolon)
...
} // DOES NOT COMPILE (missing semicolon)
```

---
#### Covering All Possible Values

The last rule about ``switch`` expressions is probably the one the exam is most likely to try to trick you on: a ``switch`` expression that returns a value must handle all possible input values. when it does not return a value, it is optional.

```java
String type = switch(canis) { // DOES NOT COMPILE
	case 1 -> "dog";
	case 2 -> "wolf";
	case 3 -> "coyote";
};
```

There’s no case branch to cover 5 (or 4, -1, 0, etc.), so should the ``switch`` expression return ``null``, the empty string, undefined, or some other value? When adding ``switch`` expressions to the Java language, the authors decided this behavior would be unsupported. Every ``switch`` expression must handle all possible values of the ``switch`` variable.

==**there are two ways to address this:**==
- ==**Add a ``default`` branch.**==
- ==**If the ``switch`` expression takes an ``enum`` value, add a case branch for every possible ``enum`` value.**==

In practice, the first solution is the one most often used. For enums, the second solution works well when the number of enum values is relatively small.

```java
enum Season {WINTER, SPRING, SUMMER, FALL}
String getWeather(Season value) {
	return switch(value) {
		case WINTER -> "Cold";
		case SPRING -> "Rainy";
		case SUMMER -> "Hot";
		case FALL -> "Warm";
	};
}
```

Since all possible permutations of ``Season`` are covered, a ``default`` branch is not required in this ``switch`` expression.

---
**What happens if you use an ``enum`` with three values and later someone adds a fourth value? Any ``switch`` expressions that use the enum without a default branch will suddenly fail to compile. If this was done frequently, you might have a lot of code to fix! For this reason, ==consider including a default branch in every ``switch`` expression, even those that involve ``enum`` values==.** #TIP 

---
## Writing `while` Loops

A loop is a repetitive control structure that can execute a statement of code multiple times in succession. By using variables that can be assigned new values, each repetition of the statement may be different.

```java
int counter = 0;
while (counter < 10) {
double price = counter * 10;
System.out.println(price);
counter++;
}
```

### The ``while`` Statement

The simplest repetitive control structure in Java is the ``while`` statement, Like all repetition control structures, it has a termination condition, implemented as a ``boolean`` expression, that will continue as long as the expression evaluates to ``true``.

a ``while`` loop is similar to an ``if`` statement in that it is composed of a boolean expression and a statement, or a block of statements. During execution, the boolean expression is evaluated before each iteration of the loop and exits if the evaluation returns false.

```java
int roomInBelly = 5;
public void eatCheese(int bitesOfCheese) {
	while (bitesOfCheese > 0 && roomInBelly > 0) {
		bitesOfCheese--;
		roomInBelly--;
	}
	System.out.println(bitesOfCheese+" pieces of cheese left");
}
```

==**One thing to remember is that a ``while`` loop may terminate after its first evaluation of the ``boolean`` expression**==

```java
int full = 5;
while(full < 5) {
	System.out.println("Not full!");
	full++;
}
```

On the first iteration of the loop, the condition is reached, and the loop exits. imply put, the body of the loop may not execute at all or may execute many times.
### The ``do/while`` Statement

==**Unlike a ``while`` loop, though, a ``do/while`` loop guarantees that the statement or block will be executed at least once.**==

```java
int lizard = 0;
do {
	lizard++;
} while(false);
System.out.println(lizard); // 1
```

Java will execute the statement block first and then check the loop condition. Even though the loop exits right away, the statement block is still executed once, and the program prints 1.
### Infinite Loops
 
 ==**The single most important thing you should be aware of when you are using any repetition control structures is to make sure they always terminate!**== Failure to terminate a loop can lead to numerous problems in practice, including overflow exceptions, memory leaks, slow performance, and even bad data.

```java
int pen = 2;
int pigs = 5;
while(pen < 10)
	pigs++;
```

The result is that the loop will never end, creating what is commonly referred to as an infinite loop. An infinite loop is a loop whose termination condition is never reached during runtime.  

Anytime you write a loop, you should examine it to determine whether the termination condition is always eventually met under some condition. make sure the loop condition, or the variables the condition is dependent on, are changing between executions. Then, ensure that the termination condition will be eventually reached in all circumstances.
## Constructing ``for`` Loops

A basic ``for`` loop has the same conditional boolean expression and statement, or block of statements, as the ``while`` loops, as well as two new sections: an ***initialization block*** and an ***update statement.***

==**Each of the three sections is separated by a semicolon. In addition, the initialization and update sections may contain multiple statements, separated by commas.**==

Variables declared in the initialization block of a for loop have limited scope and are accessible only within the for loop. Be wary of any exam questions in which a variable is declared within the initialization block of a for loop and then read outside the loop.

```java
for(int i=0; i < 10; i++)
	System.out.println("Value is: "+i);
System.out.println(i); // DOES NOT COMPILE
```

Alternatively, variables declared before the ``for`` loop and assigned a value in the initialization block may be used outside the ``for`` loop because their scope precedes the creation of the for loop.

```java
int i;
for(i=0; i < 10; i++)
	System.out.println("Value is: "+i);
System.out.println(i);
```

```java
for(int i = 0; i < 5; i++) {
	System.out.print(i + " ");
}
```
 
 The local variable ``i`` is initialized first to 0. The variable ``i`` is only in scope for the duration of the loop and is not available outside the loop once the loop has completed. Like a while loop, the boolean condition is evaluated on every iteration of the loop before the loop executes. Since it returns true, the loop executes and outputs 0 followed by a space. Next, the loop executes the update section, which in this case increases the value of ``i`` to 1. The loop then evaluates the boolean expression a second time, and the process repeats multiple times, printing the following:

```text
0 1 2 3 4
```
#### Printing Elements in Reverse

```java
for (var counter = 4; counter >= 0; counter--)
{
	System.out.print(counter + " ");
}
```

---

**For the exam, you are going to have to know how to read forward and backward ``for`` loops. When you see a ``for`` loop on the exam, pay close attention to the loop variable and operations if the decrement operator, ``--`` , is used. While incrementing from 0 in a ``for`` loop is often straightforward, decrementing tends to be less intuitive. In fact, if you do see a for loop with a decrement operator on the exam, you should assume they are trying to test your knowledge of loop operations.** 

---
#### Working with ``for`` Loops

**1. Creating an Infinite Loop**

```java
for( ; ; )
	System.out.println("Hello World");
```

it will in fact compile and run without issue. It is actually an infinite loop that will print the same statement repeatedly.

**2. Adding Multiple Terms to the for Statement**

```java
int x = 0;
for(long y = 0, z = 4; x < 5 && y < 10; x++, y++) {
System.out.print(y + " "); }
System.out.print(x + " ");
```

This code demonstrates three variations of the for loop

- ==**First, you can declare a variable, such as x in this example, before the loop begins and use it after it completes.**==
- ==**Second, your initialization block, boolean expression, and update statements can include extra variables that may or may not reference each other**==
- ==**Finally, the update statement can modify multiple variables.**==

**3. Redeclaring a Variable in the Initialization Block**

```java
int x = 0;
for(int x = 4; x < 5; x++) // DOES NOT COMPILE
System.out.print(x + " ");
```

It does not compile because of the initialization block. The difference is that x is repeated in the initialization block after already being declared before the loop, resulting in the compiler stopping because of a duplicate variable declaration. 

**4. Using Incompatible Data Types in the Initialization Block**

```java
int x = 0;
for(long y = 0, int z = 4; x < 5; x++) // DOES NOT COMPILE
	System.out.print(y + " ");
```

**==The variables in the initialization block must all be of the same type==**. In the multiple-terms example, y and z were both long, so the code compiled without issue; but in this example, they have different types, so the code will not compile.

**5. Using Loop Variables Outside the Loop**

```java
for(long y = 0, x = 4; x < 5 && y < 10; x++, y++)
System.out.print(y + " ");
System.out.print(x); // DOES NOT COMPILE
```

If you notice, x is defined in the initialization block of the loop and then used after the loop terminates. Since x was only scoped for the loop, using it outside the loop will cause a compiler error.
### The ``for-each`` Loop

The ``for-each`` loop is a specialized structure designed to iterate over arrays and various Collections Framework classes

==**The ``for-each`` loop declaration is composed of an initialization section and an object to be iterated over. The right side of the for-each loop must be one of the following:**==

- ==**A built-in Java array**==  
- ==**An object whose type implements`` java.lang.Iterable``**==

For the exam, you should know that this does not include all of the Collections Framework classes or interfaces, but only those that implement or extend that Collection interface. For example, Map is not supported in a for-each loop, although Map does include methods that return Collection instances.

The left side of the ``for-each`` loop must include a declaration for an instance of a variable whose type is compatible with the type of the array or collection on the right side of the statement. On each iteration of the loop, the named variable on the left side of the statement is assigned a new value from the array or collection on the right side of the statement.

```java
public void printNames(String[] names) {
	for(int counter=0; counter<names.length; counter++)
		System.out.println(names[counter]);
}

public void printNames(String[] names) {
	for(var name : names)
		System.out.println(name);
}
```

Like using a ``for`` loop in place of a ``while`` loop, ``for-each`` loops are meant to reduce boilerplate code, making code easier to read/write, and freeing you to focus on the parts of your code that really matter.

==**on each iteration, a ``for-each`` loop assigns a variable with the same type as the generic argument.**==

```java
String birds = "Jay";
for(String bird : birds) // DOES NOT COMPILE
	System.out.print(bird + " ");

String[] sloths = new String[3];
for(int sloth : sloths) // DOES NOT COMPILE
	System.out.print(sloth + " ");
```

- The first ``for-each`` loop does not compile because ``String`` cannot be used on the right side of the statement.
- The second example does not compile because the loop type on the left side of the statement is ``int`` and doesn’t match the expected type of ``String``.
## Controlling Flow with Branching

### Nested Loops

A nested loop is a loop that contains another loop, including ``while``, ``do/while``, ``for``, and ``for-each`` loops.

```java
int[][] myComplexArray = {{5,2,1,3},{3,9,8,9},{5,7,12,7}};
for(int[] mySimpleArray : myComplexArray) {
	for(int i=0; i<mySimpleArray.length; i++) {
		System.out.print(mySimpleArray[i]+"\t");
	}
	System.out.println();
}
```

```text
5 2 1 3
3 9 8 9
5 7 12 7
```

Nested loops can include ``while`` and ``do/while``

```java
int hungryHippopotamus = 8;
while(hungryHippopotamus>0) {
	do {
		hungryHippopotamus -=2;
	} while (hungryHippopotamus>5);
	hungryHippopotamus--;
	System.out.print(hungryHippopotamus+", ");
}
```

The first time this loop executes, the inner loop repeats until the value of ``hungryHippopotamus`` is 4. The value will then be decremented to 3, and that will be the output at the end of the first iteration of the outer loop.

On the second iteration of the outer loop, the inner do/while will be executed once, even though ``hungryHippopotamus`` is already not greater than 5. As you may recall, do/while statements always execute the body at least once. This will reduce the value to 1, which will be further lowered by the decrement operator in the outer loop to 0. Once the value reaches 0, the outer loop will terminate.

```text
3, 0,
```

### Adding Optional Labels

A label is an optional pointer to the head of a statement that allows the application flow to jump to it or break from it. It is a single identifier that is followed by a colon ``(:)``.

```java
int[][] myComplexArray = {{5,2,1,3},{3,9,8,9},{5,7,12,7}};
OUTER_LOOP: for(int[] mySimpleArray : myComplexArray) {
	INNER_LOOP: for(int i=0; i<mySimpleArray.length; i++) {
		System.out.print(mySimpleArray[i]+"\t");
	}
	System.out.println();
}
```

Labels follow the same rules for formatting as identifiers. For readability, they are commonly expressed using uppercase letters in snake_case with underscores between words. When dealing with only one loop, labels do not add any value, they are extremely useful in nested structures.
### The ``break`` Statement

``break`` statement transfers the flow of control out to the enclosing statement. The same holds true for a ``break`` statement that appears inside of a ``while``, ``do/while``, or for loop, as it will end the loop early

the ``break`` statement can take an optional label parameter. Without a label parameter, the ``break`` statement will terminate the nearest inner loop it is currently in the process of executing. The optional label parameter allows us to break out of a higher-level outer loop.

```java
public class FindInMatrix {
    public static void main(String[] args) {
        int[][] list = {{1, 13}, {5, 2}, {2, 2}};
        int searchValue = 2;
        int positionX = -1;
        int positionY = -1;

        PARENT_LOOP:
        for (int i = 0; i < list.length; i++) {
            for (int j = 0; j < list[i].length; j++) {
                if (list[i][j] == searchValue) {
                    positionX = i;
                    positionY = j;
                    break PARENT_LOOP;
                }
            }
        }

        if (positionX == -1 || positionY == -1) {
            System.out.println("Value " + searchValue + " not found");
        } else {
            System.out.println("Value " + searchValue + " found at: " +
                    "(" + positionX + "," + positionY + ")");
        }
    }
}

```

```text
Value 2 found at: (1,1)
```

the statement ``break PARENT_LOOP``. This statement will break out of the entire loop structure as soon as the first matching value is found.

```java
if(list[i][j]==searchValue) {
	positionX = i;
	positionY = j;
	break;
}
```

Instead of exiting when the first matching value is found, the program would now only exit the inner loop when the condition was met. In other words, the structure would find the first matching value of the last inner loop to contain the value

```text
Value 2 found at: (2,0)
```

```java
if(list[i][j]==searchValue) {
	positionX = i;
	positionY = j;
}
```

the code would search for the last value in the entire structure that had the matching value.

```text
Value 2 found at: (2,1)
```

### The ``continue`` Statement

the ``continue`` statement, a statement that causes flow to finish the execution of the ==**current loop iteration**==

==**While the ``break`` statement transfers control to the enclosing statement, the ``continue`` statement transfers control to the boolean expression that determines if the loop should continue.**== In other words, it ends the current iteration of the loop. Also, like the ``break`` statement, the ``continue`` statement is applied to the nearest inner loop under execution, using optional label statements to override this behavior.

```java
1: public class CleaningSchedule {
2:     public static void main(String[] args) {
3:         CLEANING: for(char stables = 'a'; stables<='d'; stables++) {
4:             for(int leopard = 1; leopard<4; leopard++) {
5:                 if(stables=='b' || leopard==2) {
6:                     continue CLEANING;
7:                 }
8:                 System.out.println("Cleaning: "+stables+","+leopard);
9:             }
10:         }
11:     }
12: }

```

```text
Cleaning: a,1
Cleaning: c,1
Cleaning: d,1
```

remove the ``CLEANING`` label in the ``continue`` statement so that control is returned to the inner loop instead of the outer. Line 6 becomes the following:

```java
6: continue;
```

This corresponds to the zookeeper cleaning all leopards except those labeled 2 or in stable b. The output is then the following:

```text
Cleaning: a,1
Cleaning: a,3
Cleaning: c,1
Cleaning: c,3
Cleaning: d,1
Cleaning: d,3
```

### The ``return`` Statement

creating methods and using ``return`` statements can be used as an alternative to using labels and ``break`` statements.

```java
public class FindInMatrixUsingReturn {
    private static int[] searchForValue(int[][] list, int v) {
        for (int i = 0; i < list.length; i++) {
            for (int j = 0; j < list[i].length; j++) {
                if (list[i][j] == v) {
                    return new int[]{i, j};
                }
            }
        }
        return null;
    }

    public static void main(String[] args) {
        int[][] list = {{1, 13}, {5, 2}, {2, 2}};
        int searchValue = 2;
        int[] results = searchForValue(list, searchValue);

        if (results == null) {
            System.out.println("Value " + searchValue + " not found");
        } else {
            System.out.println("Value " + searchValue + " found at: " +
                    "(" + results[0] + "," + results[1] + ")");
        }
    }
}
```

the code without labels and break statements a lot easier to read and debug. Also, making the search logic an independent function makes the code more reusable and the calling main() method a lot easier to read.

Just remember that return statements can be used to exit loops quickly and can lead to more readable code in practice, especially when used with nested loops.

### Unreachable Code

==**One facet of ``break``, ``continue``, and ``return`` that you should be aware of is that any code placed immediately after them in the same block is considered unreachable and will not compile.**==

```java
int checkDate = 0;
while(checkDate<10) {
	checkDate++;
	if(checkDate>100) {
		break;
		checkDate++; // DOES NOT COMPILE
	}
}
```

the compiler notices that you have statements immediately following the ``break`` and will fail to compile with “unreachable code” as the reason. The same is true for ``continue`` and ``return`` statements

```java
int minute = 1;
WATCH: while (minute > 2) {
    if (minute++ > 2) {
        continue WATCH;
         System.out.print(minute); // DOES NOT COMPILE
    }
}

int hour = 2;
switch (hour) {
    case 1:
        return; 
         hour++; // DOES NOT COMPILE
    case 2:
}
```

One thing to remember is that it does not matter if the loop or decision structure actually visits the line of code. For example, the loop could execute zero or infinite times at runtime. Regardless of execution, the compiler will report an error if it finds any code it deems unreachable, in this case any statements immediately following a break, continue, or return statement.
### Reviewing Branching

| Control Statement | Support Labels | Support Break | Support Continue | Support Yield |
|-------------------|----------------|---------------|-------------------|---------------|
| while             | Yes            | Yes           | Yes               | No            |
| do/while          | Yes            | Yes           | Yes               | No            |
| for               | Yes            | Yes           | Yes               | No            |
| switch            | Yes            | Yes           | No                | Yes           |

---

**Some of the most time-consuming questions you may see on the exam could involve nested loops with lots of branching. Unless you spot an obvious compiler error, we recommend skipping these questions and coming back to them at the end. Remember, all questions on the exam are weighted evenly!** #TIP 

---

## Summary #OCP_Summary 

**==This chapter presented how to make intelligent decisions in Java.**==

==**We covered basic decision-making constructs such as if, else, and switch statements and showed how to use them to change the path of the process at runtime. We also presented newer features in the Java language, including pattern matching and switch expressions, both designed to reduce boilerplate code.**==

==**We then moved our discussion to repetition control structures, starting with while and do/while loops.**==

==**Next, we covered the extremely convenient repetition control structures: the for and for-each loops. While their syntax is more complex than the traditional while or do/while loops, they are extremely useful in everyday coding and allow you to create complex expressions in a single line of code.**==

==**We concluded this chapter by discussing advanced control options and how flow can be enhanced through nested loops coupled with break, continue, and return statements.==**

## Exam Essentials #Essential 

- **Understand if and else decision control statements**. The if and else statements come up frequently throughout the exam in questions unrelated to decision control, so make sure you fully understand these basic building blocks of Java.

- **Apply pattern matching and flow scoping**. Pattern matching can be used to reduce boilerplate code involving an if statement, instanceof operator, and cast operation using a pattern variable. It can also include a pattern or filter after the pattern variable declaration. Pattern matching uses flow scoping in which the pattern variable is in scope as long as the compiler can definitively determine its type.

- **Understand switch statements and their proper usage**. You should be able to spot a poorly formed ``switch`` statement on the exam. The switch value and data type should be compatible with the case statements, and the values for the case statements must evaluate to compile-time constants. Finally, at runtime, a ``switch`` statement branches to the first matching ``case``, or ``default`` if there is no match, or exits entirely if there is no match and no default branch. The process then ``continues`` into any proceeding case or default statements until a break or return statement is reached.

- **Use switch expressions correctly**. Discern the differences between ``switch`` expressions and ``switch`` statements. Understand how to write switch expressions correctly, including proper use of semicolons, writing ``case`` expressions and blocks that ``yield`` a consistent value, and making sure all possible values of the switch variable are handled by the switch expression.

- **Write while loops**. Know the syntactical structure of all ``while`` and ``do/while`` loops. In particular, know when to use one versus the other.

- **Be able to use for loops**. You should be familiar with ``for`` and ``for-each`` loops and know how to write and evaluate them. Each loop has its own special properties and structures. You should know how to use for-each loops to iterate over lists and arrays.

- **Understand how break, continue, and return can change flow control**. Know how to change the flow control within a statement by applying a break, continue, or return statement. Also know which control statements can accept break statements and which can accept continue statements. Finally, you should understand how these statements work inside embedded loops or switch statements.


## Review Questions

1. Which of the following data types can be used in a switch expression? (Choose all that apply.)
A. enum
B. int
C. Byte
D. long
E. String
F. char
G. var
H. double

**My Answer: A,B,C,E,F,G**
**Correct Answer: A,B,C,E,F,G**


---

2. What is the output of the following code snippet? (Choose all that apply.)

```java
3: int temperature = 4;
4: long humidity = -temperature + temperature * 3;
5: if (temperature>=4)
6: if (humidity < 6) System.out.println("Too Low");
7: else System.out.println("Just Right");
8: else System.out.println("Too High");
```

A. Too Low
B. Just Right
C. Too High
D. A NullPointerException is thrown at runtime.
E. The code will not compile because of line 7.
F. The code will not compile because of line 8.

**My Answer: E,F**
**Correct Answer: B**

**The code compiles and runs without issue, Even though two consecutive else statements on lines 7 and 8 look a little odd, they are associated with separate if statements on lines 5 and 6, respectively**

---

3. Which of the following data types are permitted on the right side of a for-each expression? (Choose all that apply.)
A. Double``[][]``
B. Object
C. Map
D. List
E. String
F. char[]
G. Exception
H. Set

**My Answer: A,D,F,H**
**Correct Answer: A,D,F,H**

---

4. What is the output of calling ``printReptile(6)``?

```JAVA
void printReptile(int category) {
var type = switch(category) {
case 1,2 -> "Snake";
case 3,4 -> "Lizard";
case 5,6 -> "Turtle";
case 7,8 -> "Alligator";
};
System.out.print(type);
}
```

A. Snake
B. Lizard
C. Turtle
D. Alligator
E. TurtleAlligator
F. None of the above

**My Answer: C**
**Correct Answer: F**

**The code does not compile because the switch expression requires all possible case values to be handled, making option F correct. If a valid default statement was added, then the code would compile**

---

5. What is the output of the following code snippet?

```java
List<Integer> myFavoriteNumbers = new ArrayList<>();
myFavoriteNumbers.add(10);
myFavoriteNumbers.add(14);
for (var a : myFavoriteNumbers) {
System.out.print(a + ", ");
break;
}
for (int b : myFavoriteNumbers) {
continue;
System.out.print(b + ", ");
}
for (Object c : myFavoriteNumbers)
System.out.print(c + ", ");
```

A. It compiles and runs without issue but does not produce any output.
B. 10, 14,
C. 10, 10, 14,
D. 10, 10, 14, 10, 14,
E. Exactly one line of code does not compile.
F. Exactly two lines of code do not compile.
G. Three or more lines of code do not compile.
H. The code contains an infinite loop and does not terminate.

**My Answer: C**
**Correct Answer: E**

**The second for-each loop contains a continue followed by a print() statement. Because the continue is not conditional and always included as part of the body of the for-each loop, the print() statement is not reachable**

---

6. Which statements about decision structures are true? (Choose all that apply.)

A. A for-each loop can be executed on any Collections Framework object.
B. The body of a while loop is guaranteed to be executed at least once.
C. The conditional expression of a for loop is evaluated before the first execution of the loop body.
D. A switch expression that takes a String and assigns the result to a variable requires a default branch.
E. The body of a do/while loop is guaranteed to be executed at least once.
F. An if statement can have multiple corresponding else statements.

**My Answer: C,D,E**
**Correct Answer: C,D,E**

---

7. Assuming weather is a well-formed nonempty array, which code snippet, when inserted independently into the blank in the following code, prints all of the elements of ``weather``?

```java
private void print(int[] weather) {
for(???) {
System.out.println(weather[i]);
}
}
```

```
`A. int i=weather.length; i>0; i--
B. int i=0; i<=weather.length-1; ++i
C. var w : weather
D. int i=weather.length-1; i>=0; i--
E. int i=0, int j=3; i<weather.length; ++i
F. int i=0; ++i<10 && i<weather.length;
G. None of the above`
```

**My Answer: C,D,**
**Correct Answer: B,D**

---

8. What is the output of calling ``printType(11)``?

```java
31: void printType(Object o) {
32: if(o instanceof Integer bat) {
33: System.out.print("int");
34: } else if(o instanceof Integer bat && bat < 10) {
35: System.out.print("small int");
36: } else if(o instanceof Long bat || bat <= 20) {
37: System.out.print("long");
38: } default {
39: System.out.print("unknown");
40: }
41: }
```

A. int
B. small int
C. long
D. unknown
E. Nothing is printed.
F. The code contains one line that does not compile.
G. The code contains two lines that do not compile.
H. None of the above

**My Answer: G,**
**Correct Answer: G**

---

9. Which statements, when inserted independently into the following blank, will cause the code to print 2 at runtime? (Choose all that apply.)

```java
int count = 0;
BUNNY: for(int row = 1; row <=3; row++)
RABBIT: for(int col = 0; col <3 ; col++) {
if((col + row) % 2 == 0);
???
count++;
}
System.out.println(count);
```

A. break BUNNY
B. break RABBIT
C. continue BUNNY
D. continue RABBIT
E. break
F. continue
G. None of the above, as the code contains a compiler error.

**My Answer: B,E**
**Correct Answer: B,C,E**

**The code contains a nested loop and a conditional expression that is executed if the sum of col + row is an even number; otherwise, count is incremented**

---

10. Given the following method, how many lines contain compilation errors? (Choose all that apply.)

```JAVA
10: private DayOfWeek getWeekDay(int day, final int thursday) {
11: int otherDay = day;
12: int Sunday = 0;
13: switch(otherDay) {
14: default:
15: case 1: continue;
16: case thursday: return DayOfWeek.THURSDAY;
17: case 2,10: break;
18: case Sunday: return DayOfWeek.SUNDAY;
19: case DayOfWeek.MONDAY: return DayOfWeek.MONDAY;
20: }
21: return DayOfWeek.FRIDAY;
22: }
```

A. None, the code compiles without issue.
B. 1
C. 2
D. 3
E. 4
F. 5
G. 6
H. The code compiles but may produce an error at runtime.

**My Answer: H**
**Correct Answer: E**

**Line 15 does not compile, as continue cannot be used inside a switch statement like this.**
**Line 16 is not a compile-time constant since any int value can be passed as a parameter. Marking it final does not change this, so it doesn’t compile.**
**Line 18 does not compile because Sunday is not marked as final. Being effectively final is insufficient.**
**line 19 does not compile because DayOfWeek.MONDAY is not an int value. While switch statements do support enum values, each case statement must have the same data type as the switch variable otherDay, which is int**


---

11. What is the output of calling ``printLocation(Animal.MAMMAL)``?

```java
10: class Zoo {
11: enum Animal {BIRD, FISH, MAMMAL}
12: void printLocation(Animal a) {
13: long type = switch(a) {
14: case BIRD -> 1;
15: case FISH -> 2;
16: case MAMMAL -> 3;
17: default -> 4;
18: };
19: System.out.print(type);
20: } }
```

A. 3
B. 4
C. 34
D. The code does not compile because of line 13.
E. The code does not compile because of line 17.
F. None of the above

**My Answer: A**
**Correct Answer: A**

---

12. What is the result of the following code snippet?

```java
3: int sing = 8, squawk = 2, notes = 0;
4: while(sing > squawk) {
5: sing--;
6: squawk += 2;
7: notes += sing + squawk;
8: }
9: System.out.println(notes);
```

A. 11
B. 13
C. 23
D. 33
E. 50
F. The code will not compile because of line 7.

**My Answer: C**
**Correct Answer: C**

---

13. What is the output of the following code snippet?

```java
2: boolean keepGoing = true;
3: int result = 15, meters = 10;
4: do {
5: meters--
;
6: if(meters==8) keepGoing = false;
7: result -=
2;
8: } while keepGoing;
9: System.out.println(result);
```

A. 7
B. 9
C. 10
D. 11
E. 15
F. The code will not compile because of line 6.
G. The code does not compile for a different reason.

**My Answer: G**
**Correct Answer: G**

---

14. Which statements about the following code snippet are correct? (Choose all that apply.)

```java
for(var penguin : new int[2])
System.out.println(penguin);
var ostrich = new Character[3];
for(var emu : ostrich)
System.out.println(emu);
List<Integer> parrots = new ArrayList<Integer>();
for(var macaw : parrots)
System.out.println(macaw);
```

A. The data type of penguin is Integer.
B. The data type of penguin is int.
C. The data type of emu is undefined.
D. The data type of emu is Character.
E. The data type of macaw is List.
F. The data type of macaw is Integer.
G. None of the above, as the code does not compile.

**My Answer: B,D,F**
**Correct Answer: B,D,F**

---

15. What is the result of the following code snippet?

```java
final char a = 'A', e = 'E';
char grade = 'B';
switch (grade) {
default:
case a:
case 'B': 'C': System.out.print("great ");
case 'D': System.out.print("good "); break;
case e:
case 'F': System.out.print("not good ");
```

A. great
B. great good
C. good
D. not good
E. The code does not compile because the data type of one or more case statements does not match the data type of the switch variable.
F. None of the above

**My Answer: F**
**Correct Answer: F**

---

16. Given the following array, which code snippets print the elements in reverse order from how they are declared? (Choose all that apply.)

```java
char[] wolf = {'W', 'e', 'b', 'b', 'y'};
A.
int q = wolf.length;
for( ; ; ) {
System.out.print(wolf[--q]);
if(q==0) break;
}

B.
for(int m=wolf.length-1;
m>=0; --m)
System.out.print(wolf[m]);

C.
for(int z=0; z<wolf.length; z++)
System.out.print(wolf[wolf.length-z]);
D.

int x = wolf.length-1;
for(int j=0; x>=0 && j==0; x--)
System.out.print(wolf[x]);

E.
final int r = wolf.length;
for(int w = r-1;r>-1; w = r-1)
System.out.print(wolf[w]);

F.
for(int i=wolf.length; i>0; --i)
System.out.print(wolf[i]);

G. None of the above
```

**My Answer: A,D**
**Correct Answer: A,B,D**


---

17. What distinct numbers are printed when the following method is executed? (Choose all that apply.)

```java
private void countAttendees() {
int participants = 4, animals = 2, performers = -1;
while((participants = participants+1) < 10) {}
do {} while (animals++ <= 1);
for( ; performers<2; performers+=2) {}
System.out.println(participants);
System.out.println(animals);
System.out.println(performers);
}
```

A. 6
B. 3
C. 4
D. 5
E. 10
F. 9
G. The code does not compile.
H. None of the above

**My Answer: B,E**
**Correct Answer: B,E**

---

18. Which statements about pattern matching and flow scoping are correct? (Choose all that apply.)

A. Pattern matching with an if statement is implemented using the instance operator.
B. Pattern matching with an if statement is implemented using the instanceon operator.
C. Pattern matching with an if statement is implemented using the instanceof operator.
D. The pattern variable cannot be accessed after the if statement in which it is declared.
E. Flow scoping means a pattern variable is only accessible if the compiler can discern its type.
F. Pattern matching can be used to declare a variable with an else statement.

**My Answer: C,E**
**Correct Answer: C,E**

---

19. What is the output of the following code snippet?

```java
2: double iguana = 0;
3: do {
4: int snake = 1;
5: System.out.print(snake++ + " ");
6: iguana--
;
7: } while (snake <= 5);
8: System.out.println(iguana);
```

A. 1 2 3 4 -4.0
B. 1 2 3 4 -5.0
C. 1 2 3 4 5 -4.0
D. 0 1 2 3 4 5 -5.0
E. The code does not compile.
F. The code compiles but produces an infinite loop at runtime.
G. None of the above

**My Answer: E**
**Correct Answer: F**

**The variable snake is declared within the body of the do/while statement, so it is out of scope on line 7.**

---

20. Which statements, when inserted into the following blanks, allow the code to compile and run without entering an infinite loop? (Choose all that apply.)

```java
4: int height = 1;
5: L1: while(height++ <10) {
6: long humidity = 12;
7: L2: do {
8: if(humidity--% 12 == 0) ; ???
9: int temperature = 30;
10: L3: for( ; ; ) {
11: temperature++;
12: if(temperature>50) ; ???
13: }
14: } while (humidity > 4);
15: }
```

A. break L2 on line 8; continue L2 on line 12
B. continue on line 8; continue on line 12
C. break L3 on line 8; break L1 on line 12
D. continue L2 on line 8; continue L3 on line 12
E. continue L2 on line 8; continue L2 on line 12
F. None of the above, as the code contains a compiler error

**My Answer: B,E**
**Correct Answer: A,E**

**The most important thing to notice when reading this code is that the innermost loop is an infinite loop. Therefore, you are looking for solutions that skip the innermost loop entirely or that exit that loop.**

---

21. A minimum of how many lines need to be corrected before the following method will compile?
```java
21: void findZookeeper(Long id) {
22: System.out.print(switch(id) {
23: case 10 -> {"Jane"}
24: case 20 -> {yield "Lisa";};
25: case 30 -> "Kelly";
26: case 30 -> "Sarah";
27: default -> "Unassigned";
28: });
29: }
```

A. Zero
B. One
C. Two
D. Three
E. Four
F. Five

**My Answer: D**
**Correct Answer: E**

**Line 22 does not compile because Long is not a compatible type for a switch statement or expression. Line 23 does not compile because it is missing a semicolon after "Jane" and a yield statement. Line 24 does not compile because it contains an extra semicolon at the end. Finally, lines 25 and 26 do not compile because they use the same case value**

---

22. What is the output of the following code snippet? (Choose all that apply.)

```java
2: var tailFeathers = 3;
3: final var one = 1;
4: switch (tailFeathers) {
5: case one: System.out.print(3 + " ");
6: default: case 3: System.out.print(5 + " ");
7: }
8: while (tailFeathers > 1) {
9: System.out.print(--tailFeathers + " "); }
```

A. 3
B. 5 1
C. 5 2
D. 3 5 1
E. 5 2 1
F. The code will not compile because of lines 3–5.
G. The code will not compile because of line 6.

**My Answer: G**
**Correct Answer: E**

**The code compiles without issue var is supported in both switch and while loops, provided the compiler determines that the type is compatible with these statements. In addition, the variable one is allowed in a case statement because it is a final local variable, making it a compile-time constant.**

---

23. What is the output of the following code snippet?

```JAVA
15: int penguin = 50, turtle = 75;
16: boolean older = penguin >= turtle;
17: if (older = true) System.out.println("Success");
18: else System.out.println("Failure");
19: else if(penguin != 50) System.out.println("Other");
```

A. Success
B. Failure
C. Other
D. The code will not compile because of line 17.
E. The code compiles but throws an exception at runtime.
F. None of the above

**My Answer: D**
**Correct Answer: F**

**Line 19 starts with an else statement, but there is no preceding if statement that it matches. For this reason, line 19 does not compile, making option F the correct answer** 

---

24. Which of the following are possible data types for friends that would allow the code to compile? (Choose all that apply.)

```java
for(var friend in friends) {
	System.out.println(friend);
}
```

A. Set
B. Map
C. String
D. int[]
E. Collection
F. StringBuilder
G. None of the above

**My Answer: A,D,E**
**Correct Answer: G**

**The statement is not a valid for-each loop (or a traditional for loop) since it uses a nonexistent in keyword**

---

25. What is the output of the following code snippet?
```java
6: String instrument = "violin";
7: final String CELLO = "cello";
8: String viola = "viola";
9: int p = -1;
10: switch(instrument) {
11: case "bass" : break;
12: case CELLO : p++;
13: default: p++;
14: case "VIOLIN": p++;
15: case "viola" : ++p; break;
16: }
17: System.out.print(p);
```

A. -1
B. 0
C. 1
D. 2
E. 3
F. The code does not compile.

**My Answer: F**
**Correct Answer: D**

**The code compiles without issue, so option F is incorrect. The viola variable created on line 8 is never used and can be ignored. If it had been used as the case value on line 15, it would have caused a compilation error since it is not marked final. Since "violin" and "VIOLIN" are not an exact match, the default branch of the switch statement is executed at runtime. This execution path increments p a total of three times, bringing the final value of p to 2 and making option D the correct answer.**

---

26. What is the output of the following code snippet? (Choose all that apply.)

```java
9: int w = 0, r = 1;
10: String name = "";
11: while(w < 2) {
12: name += "A";
13: do {
14: name += "B";
15: if(name.length()>0) name += "C";
16: else break;
17: } while (r <=1);
18: r++; w++; }
19: System.out.println(name);
```

A. ABC
B. ABCABC
C. ABCABCABC
D. Line 15 contains a compilation error.
E. Line 18 contains a compilation error.
F. The code compiles but never terminates at runtime.
G. The code compiles but throws a NullPointerException at runtime.

**My Answer: B**
**Correct Answer: F**

**The code snippet does not contain any compilation errors, There is a problem with this code snippet, though. While it may seem complicated, the key is to notice that the variable r is updated outside of the do/while loop. This is allowed from a compilation standpoint, since it is defined before the loop, but it means the innermost loop never breaks the termination condition r <= 1. At runtime, this will produce an infinite loop the first time the innermost loop is entered**

---

27. What is printed by the following code snippet?

```java
23: byte amphibian = 1;
24: String name = "Frog";
25: String color = switch(amphibian) {
26: case 1 -> { yield "Red"; }
27: case 2 -> { if(name.equals("Frog")) yield "Green"; }
28: case 3 -> { yield "Purple"; }
29: default -> throw new RuntimeException();
30: };
31: System.out.print(color);
```

A. Red
B. Green
C. Purple
D. RedPurple
E. An exception is thrown at runtime.
F. The code does not compile.

**My Answer: F**
**Correct Answer: F**

---

28. What is the output of calling ``getFish("goldie")``?

```JAVA
40: void getFish(Object fish) {
41: if (!(fish instanceof String guppy))
42: System.out.print("Eat!");
43: else if (!(fish instanceof String guppy)) {
44: throw new RuntimeException();
45: }
46: System.out.print("Swim!");
47: }
```

A. Eat!
B. Swim!
C. Eat! followed by an exception.
D. Eat!Swim!
E. An exception is printed.
F. None of the above

**My Answer: F**
**Correct Answer: F**

**Based on flow scoping, guppy is in scope after lines 41–42 if the type is not a String. In this case, line 43 declares a variable guppy that is a duplicate of the previously defined local variable defined on line 41. For this reason, the code does not compile, and option F is correct.**

---

29. What is the result of the following code?

```java
1: public class PrintIntegers {
2: public static void main(String[] args) {
3: int y = -2;
4: do System.out.print(++y + " ");
5: while(y <= 5);
6: } }
```

A. -2 -1 0 1 2 3 4 5
B. -2 -1 0 1 2 3 4
C. -1 0 1 2 3 4 5 6
D. -1 0 1 2 3 4 5
E. The code will not compile because of line 5.
F. The code contains an infinite loop and does not terminate.

**My Answer: A**
**Correct Answer: C**

---

# Chapter 4 - Core APIs #Chapter

## Creating and Manipulating Strings

A string is basically a sequence of characters;

```JAVA
String name = "Fluffy";
```

this is an example of a reference type. reference types are created using the ***new*** keyword. In Java, these two
snippets both create a ``String``:

```JAVA
String name = "Fluffy";
String name = new String("Fluffy");
```

Both give you a reference variable named name pointing to the String object *Fluffy*. String class is special and doesn’t need to be instantiated with ``new``.  Further, text blocks are another way of creating a String. To review, this text block is the same as the previous variables:

```java
String name = """
Fluffy""";
```

Since a ``String`` is a sequence of characters, it implements the interface ``CharSequence``. This interface is a general way of representing several classes, including ``String`` and ``StringBuilder`` . 
### Concatenating

Java combines the two String objects. Placing one String before the other String and combining them is called string *concatenation.* The exam creators like string concatenation because the ``+`` operator can be used in two ways within the same line of code.

1. ==**If both operands are numeric, ``+`` means numeric addition.**==
2. ==**If either operand is a String, ``+`` means concatenation.**==
3. ==**The expression is evaluated left to right.**==

```java
System.out.println(1 + 2); // 3
System.out.println("a" + "b"); // ab
System.out.println("a" + "b" + 3); // ab3
System.out.println(1 + 2 + "c"); // 3c
System.out.println("c" + 1 + 2); // c12
System.out.println("c" + null); // cnull
```

- The first example uses the first rule. Both operands are numbers, so we use normal addition.
- The second example is simple string concatenation, described in the second rule.
- The third example combines the second and third rules. Since we start on the left, Java
	figures out what "a" + "b" evaluates to. Then Java looks at the remaining expression of "ab" + 3. The second rule tells us to concatenate since one of the operands is a ``String``.
- In the fourth example, start with the third rule, which tells us to consider 1 + 2. Both operands are numeric, so the first rule tells us the answer is 3. Then we have 3 + "c", which uses the second rule to give us "3c". 
- The fifth example shows the importance of the third rule. First we have "c" + 1, which uses the second rule to give us "c1". Then we have "c1" + 2, which uses the second rule again to give us "c12".
- Finally, the last example shows how **==``null`` is represented as a string when concatenated or printed==**, giving us ``"cnull"``.

```java
int three = 3;
String four = "4";
System.out.println(1 + 2 + three + four); // 64 type String
```

just take it slow, remember the three rules, and be sure to check the variable types. 
There is one more thing to know about concatenation, s += "2" means the same thing as s = s + "2".

```java
	4: var s = "1"; // s currently holds "1"
	5: s += "2"; // s currently holds "12"
	6: s += 3; // s currently holds "123"
	7: System.out.println(s); // 123
```

==**use numeric addition if two numbers are involved, use concatenation otherwise, and evaluate from left to right.**==
### Important String Methods

For all these methods, you need to remember that a string is a sequence of characters and ==**Java counts from 0 when indexed.**== also need to know that a ==**String is immutable, or unchangeable. This means calling a method on a String will return a different String object rather than changing the value of the reference.**==
#### Determining the Length

The method ``length()`` returns the number of characters in the String.
```java
public int length()
```

```java
var name = "animals";
System.out.println(name.length()); // 7
```

Java counts from 0? The difference is that **==zero counting happens only when you’re using indexes or positions**== 
==**within a list==**. When determining the total size or length, Java uses normal counting again.
#### Getting a Single Character

The method ``charAt()`` lets you query the string to find out what character is at a specific index.
```java
public char charAt(int index)
```

```java
var name = "animals";
System.out.println(name.charAt(0)); // a
System.out.println(name.charAt(6)); // s
System.out.println(name.charAt(7)); // exception
```
#### Finding an Index

The method ``indexOf()`` looks at the characters in the string and finds the first index that matches the desired value. The ``indexOf`` method can work with an individual character or a whole String as input. It can also start from a requested position. char can be passed to an int parameter type.

```java
public int indexOf(int ch)
public int indexOf(int ch, int fromIndex)
public int indexOf(String str)
public int indexOf(String str, int fromIndex)
```

```java
var name = "animals";
System.out.println(name.indexOf('a')); // 0
System.out.println(name.indexOf("al")); // 4
System.out.println(name.indexOf('a', 4)); // 4
System.out.println(name.indexOf("al", 5)); // -1
```

==**Unlike ``charAt()``, the ``indexOf()`` method doesn’t throw an exception if it can’t find a match, instead returning –1.**== Because indexes start with 0, the caller knows that –1 couldn’t be a valid index.
#### Getting a Substring

The method ``substring()`` also looks for characters in a string. It returns parts of the string. The first parameter is the index to start with for the returned string. As usual, this is a zero-based index. There is an optional second parameter, which is the end index you want to stop at.

==**Notice  “stop at” rather than “include.”**== This means the ``endIndex`` parameter is allowed to be one past the end of the sequence if you want to stop at the end of the sequence. That would be redundant, though, since you could omit the second parameter entirely in that case

```java
public String substring(int beginIndex)
public String substring(int beginIndex, int endIndex)
```

![[Pasted image 20240204161904.png]]

```java
var name = "animals";
System.out.println(name.substring(3)); // mals
System.out.println(name.substring(name.indexOf('m'))); // mals
System.out.println(name.substring(3, 4)); // m
System.out.println(name.substring(3, 7)); // mals
```

The ``substring()`` method is the trickiest String method on the exam. The second example calls ``indexOf()`` to get the index rather than hard-coding it. This is a common practice when coding because you may not know the index in advance.

```java
System.out.println(name.substring(3, 3)); // empty string
System.out.println(name.substring(3, 2)); // exception
System.out.println(name.substring(3, 8)); // exception
```

The first example in this set prints an empty string. The request is for the characters starting with index 3 until we get to index 3. ==**Since we start and end with the same index, there are no characters in between.**==

==**The method returns the string starting from the requested index. If an end index is requested, it stops right before that index. Otherwise, it goes to the end of the string.**==
#### Adjusting Case

```java
public String toLowerCase()
public String toUpperCase()
```

```java
var name = "animals";
System.out.println(name.toUpperCase()); // ANIMALS
System.out.println("Abc123".toLowerCase()); // abc123
```

==**These methods leave alone any characters other than letters. Also, remember that strings are immutable, so the original string stays the same.**==
#### Checking for Equality

- ==**The ``equals()`` method checks whether two String objects contain exactly the same characters in the same order.**== 
- ==**The ``equalsIgnoreCase()`` method checks whether two String objects contain the same characters, with the exception that it ignores the characters’ case.**==

```java
public boolean equals(Object obj)
public boolean equalsIgnoreCase(String str)
```

``equals()`` takes an Object rather than a String. This is because the method is the same for all objects. If you pass in something that isn’t a String, it will just return false. By contrast, the ``equalsIgnoreCase()`` method only applies to String objects, so it can take the more specific type as the parameter.

```java
System.out.println("abc".equals("ABC")); // false
System.out.println("ABC".equals("ABC")); // true
System.out.println("abc".equalsIgnoreCase("ABC")); // true
```

---
**Overriding`` toString()``, ``equals(Object)``, and ``hashCode()``**

- **``toString()``: The ``toString()`` method is called when you try to print an object or concatenate the object with a String. It is commonly overridden with a version that prints a unique description of the instance using its instance fields.**
- **``equals(Object)``: The ``equals(Object)`` method is used to compare objects, with the default implementation just using the == operator. You should override the ``equals(Object)`` method any time you want to conveniently compare elements for equality, especially if this requires checking numerous fields.**
- **``hashCode()``: Any time you override ``equals(Object)``, you must override ``hashCode()`` to be consistent. This means that for any two objects, ``if a.equals(b)`` is true, then ``a.hashCode() == b.hashCode()`` must also be true. If they are not consistent, this could lead to invalid data and side effects in hash-based collections such as ``HashMap`` and ``HashSet``.**

---
#### Searching for Substrings

The ``startsWith()`` and ``endsWith()`` methods look at whether the provided value matches part of the String. The ``contains()`` method isn’t as particular; it looks for matches anywhere in the String.

```java
public boolean startsWith(String prefix)
public boolean endsWith(String suffix)
public boolean contains(CharSequence charSeq)
```

```java
System.out.println("abc".startsWith("a")); // true
System.out.println("abc".startsWith("A")); // false

System.out.println("abc".endsWith("c")); // true
System.out.println("abc".endsWith("a")); // false

System.out.println("abc".contains("b")); // true
System.out.println("abc".contains("B")); // false
```
#### Replacing Values

The ``replace()`` method does a simple search and replace on the string. There’s a version that takes char parameters as well as a version that takes ``CharSequence`` parameters.

```java
public String replace(char oldChar, char newChar)
public String replace(CharSequence target, CharSequence replacement)
```

```java
System.out.println("abcabc".replace('a', 'A')); // AbcAbc
System.out.println("abcabc".replace("a", "A")); // AbcAbc
```
#### Removing Whitespace
 
 These methods remove blank space from the beginning and/or end of a String. ==**The`` strip()`` and ``trim()`` methods remove whitespace from the beginning and end of a String**==. In terms of the exam, whitespace consists of spaces along with the ``\t (tab)`` and ``\n (newline)`` characters. Other characters, such as ``\r (carriage return)``, are also included in what gets trimmed. **==The ``strip()`` method does everything that ``trim()`` does, but it supports Unicode.==**

Additionally, the ``stripLeading()`` method removes whitespace from the beginning of the String and leaves it at the end. The ``stripTrailing()`` method does the opposite. It removes whitespace from the end of the String and leaves it at the beginning.

```java
public String strip()
public String stripLeading()
public String stripTrailing()
public String trim()
```

```java
System.out.println("abc".strip()); // abc
System.out.println("\t a b c\n".strip()); // a b c

String text = " abc\t ";
System.out.println(text.length()); // 6
System.out.println(text.trim().length()); // 3
System.out.println(text.strip().length()); // 3
System.out.println(text.stripLeading().length()); // 5
System.out.println(text.stripTrailing().length());// 4
```

First, remember that ``\t`` is a single character. The backslash escapes the t to represent a tab.
The second example gets rid of the leading tab, subsequent spaces, and the trailing newline. It leaves the spaces that are in the middle of the string. The remaining examples just print the number of characters remaining

```java
public class RemovingWhitespace {  
  
    public static void main(String[] args) {  
  
        stripWhiteSpace();  
  
        trimWhiteSpace();  
  
        stripTabCharacter();  
  
        trimTabCharacter();  
  
        stripSpecialCharacters();  
  
        trimSpecialCharacters();  
  
        trimUnicodeContent();  
  
        stripUnicodeContent();  
    }  
    private static void stripWhiteSpace() {  
        System.out.println("##### stripWhiteSpace #####");  
        System.out.println("abc".strip());  //abc  
        System.out.println(" abc ".strip()); //abc  
        System.out.println(" abc ".strip().length()); //3  
    }  
  
    private static void trimWhiteSpace() {  
        System.out.println("##### trimWhiteSpace #####");  
        System.out.println("abc".trim());  //abc  
        System.out.println(" abc ".trim()); //abc  
        System.out.println(" abc ".trim().length()); //3  
    }  
  
    private static void stripTabCharacter() {  
        System.out.println("##### stripTabCharacter #####");  
        String text = " abc\t ";  
        System.out.println(text.strip()); //abc  
        System.out.println(text.strip().length()); //3  
        System.out.println(text.stripLeading().length()); //5  
        System.out.println(text.stripTrailing().length()); //4  
    }  
  
  
    private static void trimTabCharacter() {  
        System.out.println("##### trimTabCharacter #####");  
        String text = " abc\t ";  
        System.out.println(text.trim()); //abc  
        System.out.println(text.trim().length()); //3  
    }  
  
  
    private static void stripSpecialCharacters() {  
        System.out.println("##### stripSpecialCharacters #####");  
        String contentWithTab = "\t   a b c\n \r";  
        System.out.println(contentWithTab);  
        System.out.println(contentWithTab.length()); //12  
  
        System.out.println(contentWithTab.strip()); // a b c  
        System.out.println(contentWithTab.strip().length());   //5  
    }  
  
    private static void trimSpecialCharacters() {  
        System.out.println("##### trimSpecialCharacters #####");  
        String contentWithTab = "\t   a b c\n \r";  
        System.out.println(contentWithTab);  
        System.out.println(contentWithTab.length()); //12  
  
        System.out.println(contentWithTab.trim()); //a b c  
        System.out.println(contentWithTab.trim().length());   //5  
    }  
  
    private static void trimUnicodeContent() {  
        System.out.println("##### trimUnicodeContent #####");  
        String content = "\u2000abc\u2000";  
        System.out.println(content);  
        System.out.println(content.trim()); // DOES NOT SUPPORT Unicode  
    }  
  
    private static void stripUnicodeContent() {  
        System.out.println("##### stripUnicodeContent #####");  
        char ch = '\u2000';  
        String content = "\u2000abc\u2000";  
        System.out.println(content);  
        System.out.println(content.strip());  
    }}
```

#### Working with Indentation

```java
public String indent(int numberSpaces)
public String stripIndent()
```

The`` indent()`` method 
- ==**Positive: Adds the same number of blank spaces to the beginning of each line.**==
- ==**Negative: Tries to remove the specified number of whitespace characters from the beginning of the line.**==
- ==**Zero: The indentation remains unchanged.**==
---

**If you call ``indent()`` with a negative number and try to remove more whitespace characters than are present at the beginning of the line, Java will remove all that it can find.**

---
``indent()`` also normalizes whitespace characters. What does normalizing whitespace mean, you ask?
- ==**First, a line break is added to the end of the string if not already there.**==
- ==**Second, any line breaks are converted to the ``\n`` format. Regardless of whether your operating system uses**==

```java
String text = "  Line 1\n  Line 2  ";  
String indented = text.indent(2);  // Positive: Adds 2 spaces  
String normalized = text.indent(-3);  // Negative: No change in indentation  
  
System.out.println("indented:" +indented);  
System.out.println("normalized:" +normalized);
```
**Because of ``\n`` at the end of Line 1, ``indent()`` method also applies to Line 2 and gives the output below**

```text
indented:    Line 1
    Line 2  

normalized:Line 1
Line 2  
```

The ``stripIndent()`` method is useful when a String was built with concatenation rather than using a text block. ==**It gets rid of all incidental whitespace.**== This means that all non-blank lines are shifted left so the same number of whitespace characters are removed from each line and the first character that remains is not blank

```java
public static void main(String args[]) {
	String example = """
		This is an example
		demonstrating the usage
		of stripIndent().
		""";
	System.out.println(example.stripIndent());
}
```

```text
This is an example
demonstrating the usage
of stripIndent().
```

==**If the `stripIndent()` method is used and there are no leading spaces on the first line of a multiline string, no changes will occur. `stripIndent()` only removes the common indentation level from each line, and if there are no leading spaces on the first line, the text remains unchanged.**==

```java
String text = "No leading spaces.\n  Indented line.\n  Another indented line.";
System.out.println(text.stripIndent());
```

```text
No leading spaces.
  Indented line.
  Another indented line.
```

Like ``indent()``, ``\r\n`` is turned into \n. However, ==**the ``stripIndent()`` method does not add a trailing line break if it is missing.**==

| Method               | Indent change                                    | Normalizes existing line breaks | Adds line break at end if missing |
|----------------------|--------------------------------------------------|---------------------------------|------------------------------------|
| `indent(n)` where n > 0 | Adds n spaces to beginning of each line           | Yes                             | Yes                                |
| `indent(n)` where n == 0| No change                                        | Yes                             | Yes                                |
| `indent(n)` where n < 0 | Removes up to n spaces from each line             | Yes                             | Yes                                |
| `stripIndent()`       | Removes all leading incidental whitespace         | Yes                             | No                                 |

```java
10: var block = """
11: a
12: b
13: c""";
14: var concat = " a\n"
15: + "  b\n"
16: + " c";
17: System.out.println(block.length()); // 6
18: System.out.println(concat.length()); // 9
19: System.out.println(block.indent(1).length()); // 10
20: System.out.println(concat.indent(-1).length()); // 7
21: System.out.println(concat.indent(-4).length()); // 6
22: System.out.println(concat.stripIndent().length()); // 6
```

- Lines 10–16 create similar strings using a text block and a regular String, respectively. We say “similar” because concat has a whitespace character at the beginning of each line while block does not.
- Line 17 counts the six characters in block, which are the three letters, the blank space before b, and the \n after a and b.
- Line 18 counts the nine characters in concat, which are the three letters, one blank space before a, two blank spaces before b, one blank space before c, and the \n after a and b.
- line 19, we ask Java to add a single blank space to each of the three lines in block. However, the output says we added 4 characters rather than 3 since the length went from 6 to 10 This mysterious additional character is thanks to the line termination normalization. ==**Since the text block doesn’t have a line break at the end, indent() adds one!**==
- line 20, we remove one whitespace character from each of the three lines of concat. This gives a length of seven.
- line 21, we ask Java to remove four whitespace characters from the same three lines. Since there are not four whitespace characters, Java does its best. The single space is removed before a and c. Both spaces are removed before b. The length of six should make sense here; we removed one more character here than on line 20.
- line 22 uses the ``stripIndent()`` method. All of the lines have at least one whitespace character. Since they do not all have two whitespace characters, the method only gets rid of one character per line. Since no new line is added by ``stripIndent()``, the length is six, which is three less than the original nine.

```java
public class WorkingWithIndentation {  
  
    public static void main(String[] args) {  
  
        indentTextBlock();  
  
        indentTextBlock2();  
  
        indentTextBlock3();  
  
        indentTextBlock4();  
  
        indentConcat();  
  
        indentConcat2();  
  
        stripIndent();  
  
        stripIndent2();  
  
    }  
    private static void indentTextBlock() {  
  
        System.out.println("##### indentTextBlock #####");  
  
        var block = """   
                a  
                 b                c""";  
  
        for (char c : block.toCharArray()) {  
            System.out.print(String.format("\\u%04x", (int) c) + " | ");  
        }        System.out.println();  
  
        System.out.println(block);  
        System.out.println(block.length()); // 6  
  
        System.out.println(block.indent(1));  
        System.out.println(block.indent(1).length()); // 10  
  
        // We ask Java to add a single blank space to each of the three lines in block. 
        // However, the output says we added 4 characters rather than 3 since the length went from 6 to 10.
	   // This mysterious additional character is thanks to the line termination normalization.
	   // Since the text block doesn’t have a line break at the end, indent() adds one!    
	}  
  
    private static void indentTextBlock2() {  
  
        System.out.println("##### indentTextBlock2 #####");  
  
        var block = """   
                a  
                 b                c                """;  
  
        for (char c : block.toCharArray()) {  
            System.out.print(String.format("\\u%04x", (int) c) + " | ");  
        }        System.out.println();  
  
        System.out.println(block);  
        System.out.println(block.length()); // 7  
  
        System.out.println(block.indent(1));  
        System.out.println(block.indent(1).length()); // 10  
  
        // We have line break! The indent does not add it at the end.    }  
  
    private static void indentTextBlock3() {  
  
        System.out.println("##### indentTextBlock3 #####");  
  
        var block = """   
                a\n  
                 b\n  
                c\n  
                """;  
  
        for (char c : block.toCharArray()) {  
            System.out.print(String.format("\\u%04x", (int) c) + " | ");  
        }        System.out.println();  
  
        System.out.println(block);  
        System.out.println(block.length()); // 10  
  
        System.out.println(block.indent(1));  
        System.out.println(block.indent(1).length()); // 16  
  
        // We have line break! The indent does not add it at the end.    
	}  
  
    private static void indentTextBlock4() {  
  
        System.out.println("##### indentTextBlock4 #####");  
  
        var block = """   
                a  
                   b                c""";  
  
        System.out.println(block);  
        System.out.println(block.length()); // 8  
        System.out.println(block.indent(-1));  
        System.out.println(block.indent(-1).length()); // 8  
  
    }  
  
    private static void indentConcat() {  
  
        System.out.println("##### indentConcat #####");  
  
        var concat = " a\n"  
                   + "  b\n"  
                   + " c";  
  
        System.out.println(concat.length());    //9  
        System.out.println(concat.indent(-1).length()); // 7  
  
        // We remove one whitespace character from each of the three lines of concat.
        // This gives a length of seven. We started with nine, got rid of three characters,
        // and added a trailing normalized new line.  
  
        System.out.println(concat.indent(-4));  
        System.out.println(concat.indent(-4).length()); // 6  
  
        // we ask Java to remove four whitespace characters from the same three lines.
        // Since there are not four whitespace characters, Java does its best.
        // The single space is removed before a and c.
        // Both spaces are removed before b. The length of six should make sense here; we removed one more character here    
	}  
  
    private static void indentConcat2() {  
  
        System.out.println("##### indentConcat2 #####");  
  
        var concat = " a\n"  
                   + "  b\n"  
                   + " c\n";  
  
        System.out.println(concat.length());    //10  
        System.out.println(concat.indent(-1).length()); // 7  
  
        // We remove one whitespace character from each of the three lines of concat.       
		// This gives a length of seven. We started with nine, got rid of three characters,   
		// and NOT added a trailing normalized new line.  
  
        System.out.println(concat.indent(-4).length()); // 6  
  
        // we ask Java to remove four whitespace characters from the same three lines.        // Since there are not four whitespace characters, Java does its best.        // The concat ends with \n !    
	}  
  
  
    private static void stripIndent() {  
  
        System.out.println("##### stripIndent #####");  
  
        var concat = " a\n"  
                   + "  b\n"  
                   + " c";  
  
        System.out.println(concat.length()); // 9  
  
        System.out.println(concat.stripIndent());  
        System.out.println(concat.stripIndent().length()); // 6  
  
  
        // All of the lines have at least one whitespace character.        
        // Since they do not all have two whitespace characters,        
        // the method only gets rid of one character per line.       
		// Since no new line is added by stripIndent(), the length is six, which is three less than the original nine.    
	}  
  
    private static void stripIndent2() {  
  
        System.out.println("##### stripIndent2 #####");  
  
        var concat = "a\n"  
                   + "  b\n"  
                   + " c";  
  
        System.out.println(concat.length()); //8  
  
        System.out.println(concat);  
        System.out.println(concat.stripIndent());  
        System.out.println(concat.stripIndent().length()); // 8  
  
    }  
}
```
#### Translating Escapes

When we escape characters, we use a single backslash. For example, ``\t`` is a tab. If we don’t want this behavior, we add another backslash to escape the backslash, so ``\\t`` is the literal string ``\t``.
==**The ``translateEscapes()`` method takes these literals and turns them into the equivalent escaped character.**==

```java
public String translateEscapes()
```

```java
var str = "1\\t2";
System.out.println(str); // 1\t2
System.out.println(str.translateEscapes()); // 1 2
```

- ==**The first line prints the literal string \t because the backslash is escaped.**==
- ==**The second line prints an actual tab since we translated the escape.**==

This method can be used for escape sequences such as ``\t`` (tab), ``\n`` (new line), ``\s`` (space), ``\"`` (double quote), and ``\'`` (single quote.)

```java
public class TranslatingEscapes {  
  
    public static void main(String[] args) {  
  
        System.out.println("---------");  
  
        System.out.println("1\t2");  
        System.out.println("1\"2");  
        System.out.println("1\n2");  
        System.out.println("1\s2");  
  
        System.out.println("---------");  
  
        var str = "1\\t2";  
        System.out.println(str); // 1\t2  
        System.out.println(str.translateEscapes()); // 1 2  
  
        System.out.println("---------");  
  
        var str2 = "1\\n2";  
        System.out.println(str2); // 1\n2  
        System.out.println(str2.translateEscapes()); // 1 new line 2  
  
        System.out.println("---------");  
  
        var str3 = "1\\s2";  
        System.out.println(str3); // 1\s2  
        System.out.println(str3.translateEscapes()); // 1 2  
  
        System.out.println("---------");  
  
        var str4 = "1\\\"2";  
        System.out.println(str4); // 1\"2  
        System.out.println(str4.translateEscapes()); // 1"2  
  
        System.out.println("---------");  
  
        var str5 = "1\\\'2";  
        System.out.println(str5); // 1\'2  
        System.out.println(str5.translateEscapes()); // 1'2  
    }  
}
```

#### Checking for Empty or Blank Strings

```java
public boolean isEmpty()
public boolean isBlank()
```

```java
public static void main(String[] args) {  
  
    System.out.println(" ".isEmpty()); // false  
    System.out.println("".isEmpty()); // true  
    System.out.println(" ".isBlank()); // true  
    System.out.println("         ".isBlank()); // true  
    System.out.println("         ".isEmpty()); // false  
    System.out.println("".isBlank()); // true  
}
```

- The first line prints ``false`` because the ``String`` is not empty; it has a blank space in it.
- The second line prints ``true`` because this time, there are no characters in the ``String``.
- The final two lines print true because there are no characters other than whitespace present.
#### Formatting Values

Two of the methods take the format string as a parameter, and the other uses an instance for that value. One method takes a ``Locale``

The method parameters are used to construct a formatted String in a single method call, rather than via a lot of format and concatenation operations. They return a reference to the instance they are called on so that operations can be chained together.

```java
public static String format(String format, Object args...)
public static String format(Locale loc, String format, Object args...)
public String formatted(Object args...)
```

```java
var name = "Kate";
var orderId = 5;
// All print: Hello Kate, order 5 is ready
System.out.println("Hello "+name+", order "+orderId+" is ready");
System.out.println(String.format("Hello %s, order %d is ready",
name, orderId));
System.out.println("Hello %s, order %d is ready"
.formatted(name, orderId));
```

In the ``format()`` and ``formatted()`` operations, the parameters are inserted and formatted via symbols in the order that they are provided in the ``vararg``.

| Symbol | Description                                      |
|--------|--------------------------------------------------|
| `%s`   | Applies to any type, commonly String values      |
| `%d`   | Applies to integer values like int and long      |
| `%f`   | Applies to floating-point values like float and double |
| `%n`   | Inserts a line break using the system-dependent line separator |
```java
var name = "James";
var score = 90.25;
var total = 100;
System.out.println("%s:%n Score: %f out of %d"
.formatted(name, score, total));
```

```text
James:
Score: 90.250000 out of 100
```

==**Mixing data types may cause exceptions at runtime.**== 
### Method Chaining

It is common to call multiple methods as shown here:
```java
var start = "AniMaL ";
var trimmed = start.trim(); // "AniMaL"
var lowercase = trimmed.toLowerCase(); // "animal"
var result = lowercase.replace('a', 'A'); // "AnimAl"
System.out.println(result);
```

Each time one is called, the returned value is put in a new variable. There are four String values along the way, and ``AnimAl`` is output.
==**However, on the exam, there is a tendency to cram as much code as possible into a small space. You’ll see code using a technique called *method chaining.***==

```java
String result = "AniMaL ".trim().toLowerCase().replace('a', 'A');
System.out.println(result);
```

==**To read code that uses method chaining, start at the left and evaluate the first method. Then call the next method on the returned value of the first method. Keep going until you get to the semicolon.**==

```java
public static void main(String[] args) {  
    String a = "abc";  
    String b = a.toUpperCase();  
    b = b.replace("B", "2").replace('C', '3');  
    System.out.println("a=" + a); // a=abc  
    System.out.println("b=" + b); // b=A23  
}
```
## Using the ``StringBuilder`` Class

```java
10: String alpha = "";
11: for(char current = 'a'; current <= 'z'; current++)
12: alpha += current;
13: System.out.println(alpha);
```

==**because the ``String`` object is immutable, a new String object is assigned to alpha, and the ``""`` object becomes eligible for garbage collection.**==

The sequence of events continues, and after 26 iterations through the loop, a total of 27 objects are instantiated, most of which are immediately eligible for garbage collection. 

The ``StringBuilder`` class creates a ``String`` without storing all those interim ``String`` values. Unlike the ``String`` class, ``StringBuilder`` is not immutable.

```java
15: StringBuilder alpha = new StringBuilder();
16: for(char current = 'a'; current <= 'z'; current++)
17: alpha.append(current);
18: System.out.println(alpha);
```

This code reuses the same `StringBuilder` without creating an interim String each time.
### Mutability and Chaining

The exam will likely try to trick you with respect to String and StringBuilder being mutable.
Chaining makes this even more interesting. **==When we chained String method calls, the result was a new String with the answer.==** Chaining StringBuilder methods doesn’t work this way. Instead, the **==StringBuilder changes its own state and returns a reference to itself.==**

```java
4: StringBuilder sb = new StringBuilder("start");
5: sb.append("+middle"); // sb = "start+middle"
6: StringBuilder same = sb.append("+end"); // "start+middle+end"
```

Line 5 adds text to the end of sb. It also returns a reference to sb, which is ignored. Line 6 also adds text to the end of sb and returns a reference to sb. This time the reference is stored in same. This means sb and same point to the same object and would print out the same value.

```java
4: StringBuilder a = new StringBuilder("abc");
5: StringBuilder b = a.append("de");
6: b = b.append("f").append("g");
7: System.out.println("a=" + a);
8: System.out.println("b=" + b);
```

both print "abcdefg". ==**There’s only one ``StringBuilder`` object here. We know that because new StringBuilder() is called only once.**==
### Creating a ``StringBuilder``

```java
StringBuilder sb1 = new StringBuilder();
StringBuilder sb2 = new StringBuilder("animal");
StringBuilder sb3 = new StringBuilder(10);
```

The final example tells Java that we have some idea of how big the eventual value will be and would like the ``StringBuilder`` to reserve a certain capacity, or number of slots, for characters.
### Important ``StringBuilder`` Methods

#### Using Common Methods

==**These four methods work exactly the same as in the String class.**==

```java
var sb = new StringBuilder("animals");
String sub = sb.substring(sb.indexOf("a"), sb.indexOf("al"));
int len = sb.length();
char ch = sb.charAt(6);
System.out.println(sub + " " + len + " " + ch);
```

**Notice that substring() returns a String rather than a StringBuilder. That is why sb is not changed.**
#### Appending Values

The ``append()`` method is by far the most frequently used method in StringBuilder. it adds the parameter to the StringBuilder and returns a reference to the current StringBuilder.

```java
public StringBuilder append(String str)
```

```java
var sb = new StringBuilder().append(1).append('c');
sb.append("-").
append(true);
System.out.println(sb); // 1c-true
```

can just call ``append()`` without having to convert your parameter to a String first.`
#### Inserting Data

The ``insert()`` method adds characters to the StringBuilder at the requested index and returns a reference to the current ``StringBuilder``

```java
public StringBuilder insert(int offset, String str)
```

```java
3: var sb = new StringBuilder("animals");
4: sb.insert(7, "-"); // sb = animals-
5: sb.insert(0, "-"); // sb = -animals-
6: sb.insert(4, "-"); // sb = -ani-mals-
7: System.out.println(sb);
```
#### Deleting Contents

The ``delete()`` method is the opposite of the ``insert()`` method.  It removes characters from the sequence and returns a reference to the current StringBuilder. The ``deleteCharAt(``) method is convenient when you want to delete only one character.

```java
public StringBuilder delete(int startIndex, int endIndex)
public StringBuilder deleteCharAt(int index)
```

```java
var sb = new StringBuilder("abcdef");
sb.delete(1, 3); // sb = adef
sb.deleteCharAt(5); // exception
```

The ``delete()`` method is more flexible than some others when it comes to array indexes. If you specify a second parameter that is past the end of the StringBuilder, Java will just assume you meant the end.
#### Replacing Portions

**==The ``replace()`` method works differently for StringBuilder than it did for String==**

```java
public StringBuilder replace(int startIndex, int endIndex, String newString)
```

```java
var builder = new StringBuilder("pigeon dirty");
builder.replace(3, 6, "sty");
System.out.println(builder); // pigsty dirty
```

First, Java deletes the characters starting with index 3 and ending right before index 6. This gives us pig dirty. Then Java inserts the value "sty" in that position. In this example, the number of characters removed and inserted are the same. However, there is no reason they have to be.

```java
var builder = new StringBuilder("pigeon dirty");
builder.replace(3, 100, "");
System.out.println(builder);
```

the method is first doing a logical delete. The ``replace()`` method allows specifying a second parameter that is past the end of the StringBuilder. That means only the first three characters remain.
#### Reversing

The ``reverse()`` method does just what it sounds like: it reverses the characters in the sequences and returns a reference to the current ``StringBuilder``.

```java
public StringBuilder reverse()
```

```java
var sb = new StringBuilder("ABC");
sb.reverse();
System.out.println(sb);
```


----

**Working with `toString()`**

The ``Object`` class contains a ``toString()`` method that many classes provide custom implementations of. The ``StringBuilder`` class is one of these.

```java
var sb = new StringBuilder("ABC");
String s = sb.toString();
```

**Often ``StringBuilder`` is used internally for performance purposes, but the end result needs to be a String.**

---
## Understanding Equality

### Comparing ``equals()`` and ``==``

```java
var one = new StringBuilder();
var two = new StringBuilder();
var three = one.append("a");
System.out.println(one == two); // false
System.out.println(one == three); // true
```

The one and two variables are both completely separate ``StringBuilder`` objects, giving us two objects. Therefore, the first print statement gives us ``false``.  The three variable is more interesting. Remember how ``StringBuilder`` methods like to return the current reference for chaining? This means one and three both point to the same object, and the second print statement gives us ``true``.

``equals()`` uses logical equality rather than object equality for String objects:

```java
var x = "Hello World";
var z = " Hello World".trim();
System.out.println(x.equals(z)); // true
```

==**``equals()`` to check the values inside the String rather than the string reference itself.**==
==**If a class doesn’t have an ``equals()`` method, Java determines whether the references point to the same object, which is exactly what ``==`` does.**==

**==StringBuilder did not implement equals(). If you call equals() on two StringBuilder instances, it will check reference equality==**. You can call ``toString()`` on StringBuilder to get a String to check for equality instead.

the exam might try to trick you with a question like this.

```java
var name = "a";
var builder = new StringBuilder("a");
System.out.println(name == builder); // DOES NOT COMPILE
```

``==`` is checking for object reference equality. The compiler is smart enough to know that two references can’t possibly point to the same object when they are completely different types.
### The String Pool

Since strings are everywhere in Java, they use up a lot of memory. Java realizes that many strings repeat in the program and solves this issue by reusing common ones. ==**The string pool, also known as the intern pool, is a location in the Java Virtual Machine (JVM) that collects all these strings.**==

==**The string pool contains literal values and constants that appear in your program. For example, *"name"* is a literal and therefore goes into the string pool. The ``myObject.toString()`` method returns a string but not a literal, so it does not go into the string pool.**==


```java
var x = "Hello World";
var y = "Hello World";
System.out.println(x == y); // true
```

Remember that ==**a String is immutable and literals are pooled. The JVM created only one literal in memory. The x and y variables both point to the same location in memory**==; therefore, the statement outputs true

```java
var x = "Hello World";
var z = " Hello World".trim();
System.out.println(x == z); // false
System.out.println(x.equals(z)); // true
```

we don’t have two of the same String literal. ==**Although x and z happen to evaluate to the same string, one is computed at runtime. Since it isn’t the same at compile-time, a new String object is created**==

```java
var singleString = "hello world";
var concat = "hello ";
concat += "world";
System.out.println(singleString == concat); // false
```

==**Calling ``+=`` is just like calling a method and results in a new String**==

```java
var x = "Hello World"; // String Pool
var y = new String("Hello World"); // New Object @ Heap
System.out.println(x == y); // false
```

 ==**The ``intern()`` method will use an object in the string pool if one is present.**==

```java
public String intern()
```

```java
var name = "Hello World";
var name2 = new String("Hello World").intern();
System.out.println(name == name2); // true
```


```java
15: var first = "rat" + 1;
16: var second = "r" + "a" + "t" + "1";
17: var third = "r" + "a" + "t" + new String("1");
18: System.out.println(first == second); // true
19: System.out.println(first == second.intern()); // true
20: System.out.println(first == third); // false
21: System.out.println(first == third.intern()); // false 
```

- On line 15, we have a compile-time constant that automatically gets placed in the string pool as "rat1".
- On line 16, we have a more complicated expression that is also a compile-time constant. Therefore, first and second share the same string pool reference. This makes lines 18 and 19 print true.
- On line 17, we have a String constructor. This means we no longer have a compile-time constant, and third does not point to a reference in the string pool. Therefore, line 20 prints false.
- On line 21, the intern() call looks in the string pool. Java notices that first points to the same String and prints true.

```java
public class StringPoolFinal {  
  
    public static void main(String[] args) {  
  
  
        finalStrings();  // true
        finalStringsV2(); // false
        checkEquality();  // true
    }  
    private static void finalStrings() {  
        String fullMsg = "hello world";  
  
        final String msg1 = "hello";  
        final String msg2 = " world";  
  
        String msg3 = msg1 + msg2;  
  
        System.out.println(fullMsg == msg3);  
    }  
    private static void finalStringsV2() {  
        String fullMsg = "hello world";  
  
        final String msg1 = helloMessage();  
        final String msg2 = worldMessage();  
  
        String msg3 = msg1 + msg2;  
  
        System.out.println(fullMsg == msg3);  
    }  
    private static String helloMessage() {  
        return "hello";  
    }  
    private static String worldMessage() {  
        return " world";  
    }  
  
    private static void checkEquality() {  
  
        String fullMsg = "hello world";  
  
        String msg1 = "hello";  
        String msg2 = " world";  
  
        String msg3 = msg1 + msg2;  
  
        System.out.println(fullMsg.equals(msg3));  
    }}
```

## Understanding Arrays 

An array is an area of memory on the heap with space for a designated number of elements.
an array can be of any other Java type.

```java
char[] letters;
```

==**Keep in mind that letters is a reference variable and not a primitive. The char type is a primitive. But char is what goes into the array and not the type of the array itself. The array itself is of type char[].**==

An array is an ordered list. It can contain duplicates.
### Creating an Array of Primitives

The most common way to create an array

![[Pasted image 20240206131327.png]]


==**When you use this form to instantiate an array, all elements are set to the default value for that type.**==

Another way to create an array is to specify all the elements it should start out with:

```java
int[] moreNumbers = new int[] {42, 55, 99};
```

Java recognizes that this expression is redundant. Since you are specifying the type of the array on the left side of the equals sign, Java already knows the type. And since you are specifying the initial values, it already knows the size. As a shortcut, Java lets you write this:

```java
int[] moreNumbers = {42, 55, 99};
```

This approach is called an ***anonymous array***.

```java
int[] numAnimals;
int [] numAnimals2;
int []numAnimals3;
int numAnimals4[];
int numAnimals5 [];
```


---

**Multiple “*Arrays*” in Declarations**

```java
int[] ids, types;
```

**two variables of type int[]. This seems logical enough. After all, int a, b; created two int variables**

```java
int ids[], types;
```

**This time we get one variable of type int[] and one variable of type int. Java sees this line of code and thinks something like this: “They want two variables of type int. The first one is called ids[]. This one is an int[] called ids. The second one is just called types. No brackets, so it is a regular integer.”**

---
### Creating an Array with Reference Variables

You can choose any Java type to be the type of the array. This includes classes you create yourself.

```java
String[] bugs = { "cricket", "beetle", "ladybug" };
String[] alias = bugs;
System.out.println(bugs.equals(alias)); // true
System.out.println(bugs.toString()); // [Ljava.lang.String;@160bc7c0
```

We can call ``equals()`` because an array is an object. It returns true because of reference equality. The ``equals()`` method on arrays does not look at the elements of the array.

what do you think this array points to?

```java
public class Names {
	String names[];
}
```

==**The code never instantiated the array, so it is just a reference variable to null**==

```java
public class Names {
String names[] = new String[2];
}
```

Each of those two slots currently is null but has the potential to point to a String object.

```java
3: String[] strings = { "stringValue" };
4: Object[] objects = strings;
5: String[] againStrings = (String[]) objects;
6: againStrings[0] = new StringBuilder(); // DOES NOT COMPILE
7: objects[0] = new StringBuilder(); // Careful!
```
 
 Line 7 is where this gets interesting. From the point of view of the compiler, this is just fine. A ``StringBuilder`` object can clearly go in an ``Object[]``. The problem is that we don’t actually have an ``Object[]``. We have a ``String[]`` referred to from an ``Object[]`` variable. At runtime, the code throws an ``ArrayStoreException``.
### Using an Array

```java
4: String[] mammals = {"monkey", "chimp", "donkey"};
5: System.out.println(mammals.length); // 3
6: System.out.println(mammals[0]); // monkey
7: System.out.println(mammals[1]); // chimp
8: System.out.println(mammals[2]); // donkey
```

Note that there are no parentheses after length since it is not a method.

```java
4: String[] mammals = {"monkey", "chimp", "donkey"};
5: System.out.println(mammals.length()); // DOES NOT COMPILE
```


```java
var birds = new String[6];
System.out.println(birds.length);
```

Even though all six elements of the array are null, there are still six of them. ==**The length attribute does not consider what is in the array; it only considers how many slots have been allocated.**==

```java
5: var numbers = new int[10];
6: for (int i = 0; i < numbers.length; i++)
7: numbers[i] = i + 5;
```

The exam will test whether you are being observant by trying to access elements that are not in the array.
why each of these throws an `ArrayIndexOutOfBoundsException` for our array of size 10?

```java
numbers[10] = 3;
numbers[numbers.length] = 5;
for (int i = 0; i <= numbers.length; i++)
numbers[i] = i + 5;
```

- The first one is trying to see whether you know that indexes start with 0. Since we have 10 elements in our array, this means only numbers[0] through numbers[9] are valid.
- The second example assumes you are clever enough to know that 10 is invalid and disguises it by using the length field. However, the length is always one more than the maximum valid index.
- Finally, the for loop incorrectly uses <= instead of <, which is also a way of referring to that tenth element.
### Sorting

Java makes it easy to sort an array by providing a sort method—or rather, a bunch of sort methods.
```java
import java.util.*; // import whole package including Arrays
import java.util.Arrays; // import just Arrays

Arrays.sort()
```

Remember that if you are shown a code snippet, you can assume the necessary imports are there.

```java
int[] numbers = { 6, 9, 1 };
Arrays.sort(numbers);
for (int i = 0; i < numbers.length; i++)
System.out.print(numbers[i] + " "); // 1 6 9
```

```java
String[] strings = { "10", "9", "100" };
Arrays.sort(strings);
for (String s : strings)
System.out.print(s + " "); // 10 100 9
```

==**The problem is that String sorts in alphabetic order, and 1 sorts before 9. (Numbers sort before letters, and uppercase sorts before lowercase.)**==
### Searching
Java also provides a convenient way to search, ==**but only if the array is already sorted.**==

==**Returns:**==
==**index of the search key, if it is contained in the array; otherwise,`` (-(insertion point) - 1)``. The insertion point is defined as the point at which the key would be inserted into the array**==

| Scenario                          | Result                                                                       |
| --------------------------------- | ---------------------------------------------------------------------------- |
| Target element found in sorted array | Index of match                                                               |
| Target element not found in sorted array | Negative value showing one smaller than the negative of the index, where a match needs to be inserted to preserve sorted order  |
| Unsorted array                    | A surprise; this result is undefined                                       |

```java
3: int[] numbers = {2,4,6,8};
4: System.out.println(Arrays.binarySearch(numbers, 2)); // 0
5: System.out.println(Arrays.binarySearch(numbers, 4)); // 1
6: System.out.println(Arrays.binarySearch(numbers, 1)); // -1
7: System.out.println(Arrays.binarySearch(numbers, 3)); // -2
8: System.out.println(Arrays.binarySearch(numbers, 9)); // -5
   System.out.println(Arrays.binarySearch(numbers, 30)); // -5
	
	int[] numbersNotSorted = new int[]{3, 2, 1};  
	System.out.println(Arrays.binarySearch(numbersNotSorted, 2));  
	System.out.println(Arrays.binarySearch(numbersNotSorted, 3));  
  
	// The array isn’t sorted. This means the output will not be defined.
```

- line 3 is a sorted array
- Line 4 searches for the index of 2. The answer is index 0.
- Line 5 searches for the index of 4, which is 1.
- Line 6 searches for the index of 1. Although 1 isn’t in the list, the search can determine that it should be inserted at element 0 to preserve the sorted order. Since 0 already means something for array indexes, Java needs to subtract 1 to give us the answer of –1.
- Line 7 is similar. Although 3 isn’t in the list, it would need to be inserted at element 1 to preserve the sorted order. We negate and subtract 1 for consistency, getting –1 –1, also known as –2.
- line 8 wants to tell us that 9 should be inserted at index 4. We again negate and subtract 1, getting –4 –1, also known as –5.

```java
5: int[] numbers = new int[] {3,2,1};
6: System.out.println(Arrays.binarySearch(numbers, 2));
7: System.out.println(Arrays.binarySearch(numbers, 3));
```

Note that on line 5, the array isn’t sorted. This means the output will not be defined. ==**As soon as you see the array isn’t sorted, look for an answer choice about unpredictable output.**==
### Comparing

Java also provides methods to compare two arrays to determine which is ***“smaller.”***
#### Using ``compare()``
There are a bunch of rules you need to know before calling ``compare()``.

- ==**A negative number means the first array is smaller than the second.**==
- ==**A zero means the arrays are equal.**==
-  ==**A positive number means the first array is larger than the second.**==

```java
System.out.println(Arrays.compare(new int[] {1}, new int[] {2})); // -1 Negative
```

how to compare arrays of different lengths:

- ==**If both arrays are the same length and have the same values in each spot in the same order, return zero.**==
- ==**If all the elements are the same but the second array has extra elements at the end, return a negative number.**==
- ==**If all the elements are the same, but the first array has extra elements at the end, return a positive number.**==
- ==**If the first element that differs is smaller in the first array, return a negative number.**==
- ==**If the first element that differs is larger in the first array, return a positive number.**==

What does smaller means? 

-  ==**null is smaller than any other value.**==
- ==**For numbers, normal numeric order applies.**==
- ==**For strings, one is smaller if it is a prefix of another.**==
- ==**For strings/characters, numbers are smaller than letters.**==
- ==**For strings/characters, uppercase is smaller than lowercase.**==

==**For strings/characters: null -> numbers -> uppercase -> lowercase**==

```java
public static void main(String[] args) {  
  
    System.out.println(Arrays.compare(new int[]{1}, new int[]{1})); // 0  
    System.out.println(Arrays.compare(new int[]{1}, new int[]{2})); // negative  
    System.out.println(Arrays.compare(new int[]{1, 2}, new int[]{1})); // positive  
    System.out.println(Arrays.compare(new int[]{1, 2}, new int[]{2})); // negative  
    System.out.println(Arrays.compare(new int[]{1, 2, 5, 3, 20}, new int[]{3})); // negative  
  
    System.out.println();  
    System.out.println(Arrays.compare(new int[]{1, 2}, new int[]{1, 2})); // zero  
    System.out.println(Arrays.compare(new int[]{1, 2, -1}, new int[]{1, 2})); // positive  
    System.out.println(Arrays.compare(new int[]{1, 2}, new int[]{1, 2, -1})); // negative  
  
    System.out.println();  
    System.out.println(Arrays.compare(new String[]{"a"}, new String[]{"aa"})); // negative  
    System.out.println(Arrays.compare(new String[]{"a"}, new String[]{"A"})); // positive  
  
    //Uppercase is smaller than lowercase    System.out.println(Arrays.compare(new String[]{"a"}, new String[]{"Z"})); // positive  
  
    System.out.println(Arrays.compare(new String[]{"a"}, new String[]{null})); // positive  
  
    // null is smaller than a letter.  
    // System.out.println(Arrays.compare(new int[]{1}, new String[]{"a"})); // DOES NOT COMPILE}
```

| First array                | Second array               | Result           | Reason                                       |
|----------------------------|----------------------------|------------------|----------------------------------------------|
| `new int[] {1, 2}`          | `new int[] {1}`            | Positive number  | The first element is the same, but the first array is longer.   |
| `new int[] {1, 2}`          | `new int[] {1, 2}`         | Zero             | Exact match                                  |
| `new String[] {"a"}`        | `new String[] {"aa"}`      | Negative number  | The first element is a substring of the second.                |
| `new String[] {"a"}`        | `new String[] {"A"}`       | Positive number  | Uppercase is smaller than lowercase.                        |
| `new String[] {"a"}`        | `new String[] {null}`      | Positive number  | null is smaller than a letter.                              |
==**When comparing two arrays, they must be the same array type.**== 

```java
System.out.println(Arrays.compare(
new int[] {1}, new String[] {"a"})); // DOES NOT COMPILE
```

### Using ``mismatch()``

==**If the arrays are equal, ``mismatch()`` returns -1. Otherwise, it returns the first index where they differ.**==

```java
System.out.println(Arrays.mismatch(new int[] {1}, new int[] {1})); // -1
System.out.println(Arrays.mismatch(new String[] {"a"}, new String[] {"A"})); // 0
System.out.println(Arrays.mismatch(new int[] {1, 2}, new int[] {1})); // 1
```

- In the first example, the arrays are the same, so the result is -1. 
- In the second example, the entries at element 0 are not equal, so the result is 0.
- In the third example, the entries at element 0 are equal, so we keep looking. The element at index 1 is not equal. Or, more specifically, one array has an element at index 1, and the other does not. Therefore, the result is 1.

```java
public static void main(String[] args) {  
    System.out.println(Arrays.mismatch(new int[]{1}, new int[]{1}));  // -1  
    System.out.println(Arrays.mismatch(new String[]{"a"}, new String[]{"A"})); //0  
    System.out.println(Arrays.mismatch(new int[]{1, 2}, new int[]{1})); //1  
    System.out.println(Arrays.mismatch(new int[]{1, 2, -1}, new int[]{1, 2, -1, 5})); //3  
}
```

| Method     | When arrays contain the same data | When arrays are different        |
|------------|------------------------------------|-----------------------------------|
| equals()   | true                               | false                             |
| compare()  | 0                                  | Positive or negative number      |
| mismatch() | -1                                 | Zero or positive index           |
### Using Methods with ``Varargs``

```java
public static void main(String[] args)
public static void main(String args[])
public static void main(String... args) // varargs
```

you can use a variable defined using ``varargs`` as if it were a normal array.
### Working with Multidimensional Arrays

#### Creating a Multidimensional Array

Multiple array separators are all it takes to declare arrays with multiple dimensions.

```java
int[][] vars1; // 2D array
int vars2 [][]; // 2D array
int[] vars3[]; // 2D array
int[] vars4 [], space [][]; // a 2D AND a 3D array
```

- The third example also declares a 2D array.
- The final example declares two arrays on the same line. Adding up the brackets, we see that the vars4 is a 2D array and space is a 3D array.

You can specify the size of your multidimensional array in the declaration if you like:

```java
String [][] rectangle = new String[3][2];
```

You can think of the addressable range as [0][0] through ``[2][1]``, but don’t think of it as a structure of addresses like ``[0,0]`` or ``[2,1]``.

```java
rectangle[0][1] = "set";
```

This array is sparsely populated because it has a lot of null values.

```java
int[][] differentSizes = {{1, 4}, {3}, {9,8,7}};
```

Another way to create an asymmetric array is to initialize just an array’s first dimension and define the size of each array component in a separate statement:

```java
int [][] args = new int[4][];
args[0] = new int[5];
args[1] = new int[3];
```

This technique reveals what you really get with Java: arrays of arrays that, properly managed, offer a multidimensional effect.
#### Using a Multidimensional Array

The most common operation on a multidimensional array is to loop through it.

```java
var twoD = new int[3][2];
for(int i = 0; i < twoD.length; i++) {
for(int j = 0; j < twoD[i].length; j++)
System.out.print(twoD[i][j] + " "); // print element
System.out.println(); // time for a new row
}
```

two loops here. The first uses index i and goes through the first subarray for twoD. The second uses a different loop variable, j. It is important that these be different variable names so the loops don’t get mixed up. The inner loop looks at how many elements are in the second-level array. The inner loop prints the element and leaves a space for readability. When the inner loop completes, the outer loop goes to a new line and repeats the process for the next element.

```java
for(int[] inner : twoD) {
for(int num : inner)
System.out.print(num + " ");
System.out.println();
}
```

## Calculating with Math APIs

Pay special attention to return types in math questions. They are an excellent opportunity for trickery!
### Finding the Minimum and Maximum

The ``min()`` and ``max()`` methods compare two values and return one of them. 

```java
public static double min(double a, double b)
public static float min(float a, float b)
public static int min(int a, int b)
public static long min(long a, long b)
```

```java
int first = Math.max(3, 7); // 7
int second = Math.min(7, -9); // -9
```
### Rounding Numbers

The ``round()`` method gets rid of the decimal portion of the value, choosing the next higher
number if appropriate. ==**If the fractional part is .5 or higher, we round up.**==

```java
public static long round(double num)
public static int round(float num)
```

```java
long low = Math.round(123.45); // 123
long high = Math.round(123.50); // 124
int fromFloat = Math.round(123.45f); // 123
```

### Determining the Ceiling and Floor

The ``ceil()`` method takes a double value. If it is a whole number, it returns the same value. If it has any fractional value, it rounds up to the next whole number. By contrast, the ``floor()`` method discards any values after the decimal.

```java
public static double ceil(double num)
public static double floor(double num)
```

```java
double c = Math.ceil(3.14); // 4.0
double f = Math.floor(3.14); // 3.0
```

### Calculating Exponents

The ``pow()`` method handles exponents.
```java
public static double pow(double number, double exponent)
```

```java
double squared = Math.pow(5, 2); // 25.0
```

### Generating Random Numbers

The ``random()`` method ==**returns a value greater than or equal to 0 and less than 1**==

```java
public static double random()
```

```java
double num = Math.random();
```

## Working with Dates and Times

### Creating Dates and Times

When working with dates and times, the first thing to do is to decide how much information you need. The exam gives you four choices:

- ==**`LocalDate` Contains just a date—no time and no time zone.**== 
- ==**``LocalTime`` Contains just a time—no date and no time zone**==. 
- ==**``LocalDateTime`` Contains both a date and time but no time zone**.== 
- ==**``ZonedDateTime`` Contains a date, time, and time zone.**== 

```java
System.out.println(LocalDate.now());
System.out.println(LocalTime.now());
System.out.println(LocalDateTime.now());
System.out.println(ZonedDateTime.now());
```

```text
2021–10–25
09:13:07.768
2021–10–25T09:13:07.768
2021–10–25T09:13:07.769–05:00[America/New_York]
```

==**The key is the type of information in the output. The output uses ``T`` to separate the date and time when converting ``LocalDateTime`` to a ``String``. Finally, the fourth adds the time zone offset and time zone.**==

---

**The time zone offset can be listed in different ways: +02:00, GMT+2, and UTC+2 all mean the same thing. You might see any of them on the exam.**

---

Both of these examples create the same date:

```java
var date1 = LocalDate.of(2022, Month.JANUARY, 20);
var date2 = LocalDate.of(2022, 1, 20);
```

```java
public static LocalDate of(int year, int month, int dayOfMonth)
public static LocalDate of(int year, Month month, int dayOfMonth)
```

---

**Java counts starting with 0. Well, months are an exception. For months in the new date and time methods, Java counts starting from 1, just as we humans do.**

---

When creating a time, you can choose how detailed you want to be. You can specify just the hour and minute, or you can include the number of seconds. You can even include nanoseconds if you want to be very precise.

```java
var time1 = LocalTime.of(6, 15); // hour and minute
var time2 = LocalTime.of(6, 15, 30); // + seconds
var time3 = LocalTime.of(6, 15, 30, 200); // + nanoseconds
```

```java
public static LocalTime of(int hour, int minute)
public static LocalTime of(int hour, int minute, int second)
public static LocalTime of(int hour, int minute, int second, int nanos)
```

You can combine dates and times into one object:

```java
var dateTime1 = LocalDateTime.of(2022, Month.JANUARY, 20, 6, 15, 30);
var dateTime2 = LocalDateTime.of(date1, time1);
```

The following method signatures use integer values:

```java
public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanos)
```

Others take a Month reference:

```java
public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanos)
```

Finally, one takes an existing ``LocalDate`` and ``LocalTime``:

```java
public static LocalDateTime of(LocalDate date, LocalTime time)
```

In order to create a ``ZonedDateTime``, we first need to get the desired time zone.

```java
var zone = ZoneId.of("US/Eastern");
var zoned1 = ZonedDateTime.of(2022, 1, 20, 6, 15, 30, 200, zone);
var zoned2 = ZonedDateTime.of(date1, time1, zone);
var zoned3 = ZonedDateTime.of(dateTime1, zone);
```

A better approach is to pass a ``LocalDate`` object and a ``LocalTime`` object, or a ``LocalDateTime`` object. Instead of Integers

```java
public static ZonedDateTime of(int year, int month,
int dayOfMonth, int hour, int minute, int second, int nanos, ZoneId zone)
public static ZonedDateTime of(LocalDate date, LocalTime time, ZoneId zone)
public static ZonedDateTime of(LocalDateTime dateTime, ZoneId zone)
```

==**The date and time classes have private constructors along with static methods that return instances.**==

```java
var d = new LocalDate(); // DOES NOT COMPILE
```

==**You are not allowed to construct a date or time object directly**==. Another trick is what happens when you pass invalid numbers to ``of()``,

```java
var d = LocalDate.of(2022, Month.JANUARY, 32) // DateTimeException
java.time.DateTimeException: Invalid value for DayOfMonth (valid values 1-28/ 31): 32
```
### Manipulating Dates and Times

==**The date and time classes are immutable**==. Remember to assign the results of these methods to a reference variable so they are not lost.

```java
12: var date = LocalDate.of(2022, Month.JANUARY, 20);
13: System.out.println(date); // 2022–01–20
14: date = date.plusDays(2);
15: System.out.println(date); // 2022–01–22
16: date = date.plusWeeks(1);
17: System.out.println(date); // 2022–01–29
18: date = date.plusMonths(1);
19: System.out.println(date); // 2022–02–28
20: date = date.plusYears(5);
21: System.out.println(date); // 2027–02–28
```

There are also nice, easy methods to go backward in time.

```java
22: var date = LocalDate.of(2024, Month.JANUARY, 20);
23: var time = LocalTime.of(5, 15);
24: var dateTime = LocalDateTime.of(date, time);
25: System.out.println(dateTime); // 2024–01–20T05:15
26: dateTime = dateTime.minusDays(1);
27: System.out.println(dateTime); // 2024–01–19T05:15
28: dateTime = dateTime.minusHours(10);
29: System.out.println(dateTime); // 2024–01–18T19:15
30: dateTime = dateTime.minusSeconds(30);
31: System.out.println(dateTime); // 2024–01–18T19:14:30
```

Java is smart enough to hide the seconds and nanoseconds when we aren’t using them.
It is common for date and time methods to be chained.

```java
var date = LocalDate.of(2024, Month.JANUARY, 20);
var time = LocalTime.of(5, 15);
var dateTime = LocalDateTime.of(date, time).minusDays(1).minusHours(10).minusSeconds(30);
```

There are two ways that the exam creators can try to trick you.

```java
var date = LocalDate.of(2024, Month.JANUARY, 20);
date.plusDays(10);
System.out.println(date);
```

Adding 10 days was useless because the program ignored the result. ==**Whenever you see immutable types, pay attention to make sure that the return value of a method call isn’t ignored.**==

```java
var date = LocalDate.of(2024, Month.JANUARY, 20);
date = date.plusMinutes(1); // DOES NOT COMPILE
```

**==``LocalDate`` does not contain time. This means that you cannot add minutes to it==**. This can be tricky in a chained sequence of addition/subtraction operations

```java
public static void main(String[] args) {  
  
    var date = LocalDate.of(2022, Month.JANUARY, 20);  
    System.out.println(date); //2022-01-20  
  
    date = date.plusDays(2); // 2022-01-22  
    System.out.println(date);  
  
    date = date.plusWeeks(1); //2022-01-29  
    System.out.println(date);  
  
    date = date.plusMonths(1); //2022-02-28  
    System.out.println(date);  
  
    // Java is smart enough to realize that February 29, 2022 does not exist, and it gives us February 28, 2022, instead.  
  
    date = date.plusYears(5); // 2027-02-28  
    System.out.println(date);  
  
    // date = date.plusMinutes(1); // DOES NOT COMPILE  
}
```

| Method            | Can call on LocalDate? | Can call on LocalTime? | Can call on LocalDateTime or ZonedDateTime? |
|-------------------|------------------------|------------------------|----------------------------------------------|
| plusYears()       | Yes                    | No                     | Yes                                          |
| minusYears()      | Yes                    | No                     | Yes                                          |
| plusMonths()      | Yes                    | No                     | Yes                                          |
| minusMonths()     | Yes                    | No                     | Yes                                          |
| plusWeeks()       | Yes                    | No                     | Yes                                          |
| minusWeeks()      | Yes                    | No                     | Yes                                          |
| plusDays()        | Yes                    | No                     | Yes                                          |
| minusDays()       | Yes                    | No                     | Yes                                          |
| plusHours()       | No                     | Yes                    | Yes                                          |
| minusHours()      | No                     | Yes                    | Yes                                          |
| plusMinutes()     | No                     | Yes                    | Yes                                          |
| minusMinutes()    | No                     | Yes                    | Yes                                          |
| plusSeconds()     | No                     | Yes                    | Yes                                          |
| minusSeconds()    | No                     | Yes                    | Yes                                          |
| plusNanos()       | No                     | Yes                    | Yes                                          |
| minusNanos()      | No                     | Yes                    | Yes                                          |
### Working with Periods

```java
public static void main(String[] args) {
var start = LocalDate.of(2022, Month.JANUARY, 1);
var end = LocalDate.of(2022, Month.MARCH, 30);
performAnimalEnrichment(start, end);
}
private static void performAnimalEnrichment(LocalDate start, LocalDate end) {
var upTo = start;
while (upTo.isBefore(end)) { // check if still before end
System.out.println("give new toy: " + upTo);
upTo = upTo.plusMonths(1); // add a month
} }
```

This code works fine. It adds a month to the date until it hits the end date. The problem is that this method can’t be reused.
Java has a ``Period`` class that we can pass in. This code does the same thing as the previous example:

```java
public static void main(String[] args) {
    var start = LocalDate.of(2022, Month.JANUARY, 1);
    var end = LocalDate.of(2022, Month.MARCH, 30);
    var period = Period.ofMonths(1); // create a period
    performAnimalEnrichment(start, end, period);
}

private static void performAnimalEnrichment(LocalDate start, LocalDate end, Period period) {
    // uses the generic period
    var upTo = start;
    while (upTo.isBefore(end)) {
        System.out.println("give new toy: " + upTo);
        upTo = upTo.plus(period); // adds the period
    }
}

```

The method can add an arbitrary period of time that is passed in. This allows us to reuse the same method for different periods of time

```java
var annually = Period.ofYears(1); // every 1 year
var quarterly = Period.ofMonths(3); // every 3 months
var everyThreeWeeks = Period.ofWeeks(3); // every 3 weeks
var everyOtherDay = Period.ofDays(2); // every 2 days
var everyYearAndAWeek = Period.of(1, 0, 7); // every year and 7 days
```

There’s one catch. ==**You cannot chain methods when creating a ``Period``.**== The following code looks like it is equivalent to the ``everyYearAndAWeek`` example, but it’s not. **==Only the last method is used because the ``Period.of ``methods are static methods.==**

```java
var wrong = Period.ofYears(1).ofWeeks(1); // every week
```

```java
var wrong = Period.ofYears(1);
wrong = Period.ofWeeks(1);
```

==**The ``of()`` method takes only years, months, and days**==. The ability to use another factory method to pass weeks is merely a convenience. As you might imagine, the actual period is stored in terms of years, months, and days. When you print out the value, Java displays any non-zero parts using the format

![[Pasted image 20240207145939.png]]

```java
System.out.println(Period.ofMonths(3)); // P3M.
```

Java omits any measures that are zero. The last thing to know about Period is what objects it can be used with.

```java
3: var date = LocalDate.of(2022, 1, 20);
4: var time = LocalTime.of(6, 15);
5: var dateTime = LocalDateTime.of(date, time);
6: var period = Period.ofMonths(1);
7: System.out.println(date.plus(period)); // 2022–02–20
8: System.out.println(dateTime.plus(period)); // 2022–02–20T06:15
9: System.out.println(time.plus(period)); // Exception
```

Line 9 attempts to add a month to an object that has only a time. This won’t work. Java throws an ``UnsupportedTemporalTypeException`` and complains that we attempted to use an ``Unsupported unit: Months``

==**You have to pay attention to the type of date and time objects every place you see them.**==

```java
var annually = Period.ofYears(1); // every 1 year  
var quarterly = Period.ofMonths(3); // every 3 months  
var everyThreeWeeks = Period.ofWeeks(3); // every 3 weeks  
var everyOtherDay = Period.ofDays(2); // every 2 days  
var everyYearAndAWeek = Period.of(1, 0, 7); // every year and 7 days  
  
System.out.println(annually); // P1Y  
System.out.println(quarterly);  // P3M  
System.out.println(everyThreeWeeks); // P21D  
System.out.println(everyOtherDay);  // P2D  
System.out.println(everyYearAndAWeek); // P1Y7D  
  
// There’s one catch. You cannot chain methods when creating a Period.  
var wrong = Period.ofYears(1).ofWeeks(1); // every week  
System.out.println(wrong); // P7D  
  
// This tricky code is really like writing the following:  
// var wrong = Period.ofYears(1);  
// wrong = Period.ofWeeks(1);
```

### Working with Durations

``Period`` is a day or more of time. There is also ``Duration``, which is intended for smaller units of time. For ``Duration``, you can specify the number of days, hours, minutes, seconds, or nanoseconds. And yes, you could pass 365 days to make a year, but you really shouldn’t—that’s what Period is for.

**==``Duration`` works roughly the same way as ``Period``, except it is used with objects that have time.==** ``Duration`` is output beginning with ``PT``, which you can think of as a period of time. A ``Duration`` is stored in hours, minutes, and seconds.

```java
var daily = Duration.ofDays(1); // PT24H
var hourly = Duration.ofHours(1); // PT1H
var everyMinute = Duration.ofMinutes(1); // PT1M
var everyTenSeconds = Duration.ofSeconds(10); // PT10S
var everyMilli = Duration.ofMillis(1); // PT0.001S
var everyNano = Duration.ofNanos(1); // PT0.000000001S
```

**==``Duration`` doesn’t have a factory method that takes multiple units like ``Period`` does==**. If you want something to happen every hour and a half, you specify 90 minutes.

``Duration`` includes another more generic factory method. It takes a number and a ``TemporalUnit``. The idea is, say, something like “5 seconds.” However, ``TemporalUnit`` is an interface. At the moment, there is only one implementation named ``ChronoUnit``.

```java
var daily = Duration.of(1, ChronoUnit.DAYS);
var hourly = Duration.of(1, ChronoUnit.HOURS);
var everyMinute = Duration.of(1, ChronoUnit.MINUTES);
var everyTenSeconds = Duration.of(10, ChronoUnit.SECONDS);
var everyMilli = Duration.of(1, ChronoUnit.MILLIS);
var everyNano = Duration.of(1, ChronoUnit.NANOS);
```

---

**``ChronoUnit`` for Differences**

**``ChronoUnit`` is a great way to determine how far apart two Temporal values are. Temporal includes ``LocalDate``, ``LocalTime``, and so on. ``ChronoUnit`` is in the java. ``time.temporal`` package.**

```java
var one = LocalTime.of(5, 15);
var two = LocalTime.of(6, 30);
var date = LocalDate.of(2016, 1, 20);
System.out.println(ChronoUnit.HOURS.between(one, two)); // 1
System.out.println(ChronoUnit.MINUTES.between(one, two)); // 75
System.out.println(ChronoUnit.MINUTES.between(one, date)); // DateTimeExce
```

**The last reminds us that Java will throw an exception if we mix up what can be done on date vs. time objects.**
**Alternatively, you can truncate any object with a time element.**

```java
LocalTime time = LocalTime.of(3,12,45);
System.out.println(time); // 03:12:45
LocalTime truncated = time.truncatedTo(ChronoUnit.MINUTES);
System.out.println(truncated); // 03:12
```

**This example zeroes out any fields smaller than minutes. In our case, it gets rid of the seconds.**

---

Using a ``Duration`` works the same way as using a Period. 

```java
7: var date = LocalDate.of(2022, 1, 20);
8: var time = LocalTime.of(6, 15);
9: var dateTime = LocalDateTime.of(date, time);
10: var duration = Duration.ofHours(6);
11: System.out.println(dateTime.plus(duration)); // 2022–01–20T12:15
12: System.out.println(time.plus(duration)); // 12:15
13: System.out.println(
14: date.plus(duration)); // UnsupportedTemporalTypeException
```

==**Line 13 fails because we cannot add hours to an object that does not contain a time.**==

```java
7: var date = LocalDate.of(2022, 1, 20);
8: var time = LocalTime.of(6, 15);
9: var dateTime = LocalDateTime.of(date, time);
10: var duration = Duration.ofHours(23);
11: System.out.println(dateTime.plus(duration)); // 2022–01–21T05:15
12: System.out.println(time.plus(duration)); // 05:15
13: System.out.println(
14: date.plus(duration)); // UnsupportedTemporalTypeException
```
### Period vs. Duration

Remember that ``Period`` and ``Duration`` are not equivalent.

```java
var date = LocalDate.of(2022, 5, 25);
var period = Period.ofDays(1);
var days = Duration.ofDays(1);
System.out.println(date.plus(period)); // 2022–05–26
System.out.println(date.plus(days)); // Unsupported unit: Seconds
```

Since we are working with a ``LocalDate``, we are required to use ``Period``. ``Duration`` has time units in it, even if we don’t see them, and they are meant only for objects with time.

|               | Can use with Period? | Can use with Duration? |
|---------------|----------------------|------------------------|
| LocalDate     | Yes                  | No                     |
| LocalDateTime | Yes                  | Yes                    |
| LocalTime     | No                   | Yes                    |
| ZonedDateTime | Yes                  | Yes                    |
### Working with Instants

The ``Instant`` class represents a specific moment in time in the GMT time zone.

```java
var now = Instant.now();
// do something time consuming
var later = Instant.now();
var duration = Duration.between(now, later);
System.out.println(duration.toMillis()); // Returns number milliseconds
```

If you have a ``ZonedDateTime``, you can turn it into an ``Instant``:

```java
var date = LocalDate.of(2022, 5, 25);
var time = LocalTime.of(11, 55, 00);
var zone = ZoneId.of("US/Eastern");
var zonedDateTime = ZonedDateTime.of(date, time, zone);
var instant = zonedDateTime.toInstant(); // 2022–05–25T15:55:00Z
System.out.println(zonedDateTime); // 2022–05–25T11:55–04:00[US/Eastern]
System.out.println(instant); // 202–05–25T15:55:00Z
```

The last two lines represent the same moment in time. The ``ZonedDateTime`` includes a time zone. The ``Instant`` gets rid of the time zone and turns it into an Instant of time in GMT.

```java
public static void main(String[] args) throws InterruptedException {  
  
    var date = LocalDate.of(2022, 5, 25);  
    var time = LocalTime.of(11, 55, 00);  
    var zone = ZoneId.of("US/Eastern");  
    var zonedDateTime = ZonedDateTime.of(date, time, zone);  
    var instant = zonedDateTime.toInstant(); // 2022–05–25T15:55:00Z  
    System.out.println("zonedDateTime : " + zonedDateTime); // 2022–05–25T11:55–04:00[US/Eastern]  
    System.out.println("instant : " + instant); // 202–05–25T15:55:00Z  
  
  
    ZonedDateTime istanbulZonedDateTime = ZonedDateTime.of(LocalDate.now(), LocalTime.now(), ZoneId.of("Europe/Istanbul"));  
  
    System.out.println("istanbulZonedDateTime : " + istanbulZonedDateTime);  
    System.out.println("instant : " + istanbulZonedDateTime.toInstant());  
    System.out.println("truncatedTo : " + (instant.truncatedTo(ChronoUnit.HOURS)));  
  
    Instant parsed = Instant.parse("2000-06-01T10:15:20.00Z");  
    System.out.println("parsed: " + parsed);  
}
```

### Accounting for Daylight Saving Time

Some countries observe daylight saving time. This is where the clocks are adjusted by an hour twice a year to make better use of the sunlight. You only have to work with U.S. daylight saving time on the exam, and that’s what we describe here.

The question will let you know if a date/time mentioned falls on a weekend when the clocks are scheduled to be changed. If it is not mentioned in a question, you can assume that it is a normal weekend. The act of moving the clock forward or back occurs at 2:00 a.m., which falls very early Sunday morning.

For example, on March 13, 2022, we move our clocks forward an hour and jump from 2:00 a.m. to 3:00 a.m. This means that there is no 2:30 a.m. that day. If we wanted to know the time an hour later than 1:30, it would be 3:30.

```java
var date = LocalDate.of(2022, Month.MARCH, 13);
var time = LocalTime.of(1, 30);
var zone = ZoneId.of("US/Eastern");
var dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime); // 2022–03-13T01:30-05: 00[US/Eastern]
System.out.println(dateTime.getHour()); // 1
System.out.println(dateTime.getOffset()); // -05:00
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); // 2022–03-13T03:30-04:00[US/Eastern]
System.out.println(dateTime.getHour()); // 3
System.out.println(dateTime.getOffset()); // -04:00
```

Notice that two things change in this example. The time jumps from 1:30 to 3:30. The UTC offset also changes. Remember when we calculated GMT time by subtracting the time zone from the time? You can see that we went from 6:30 GMT (1:30 minus –5:00) to 7:30 GMT (3:30 minus –4:00). This shows that the time really did change by one hour from GMT’s point of view.

```java
var date = LocalDate.of(2022, Month.NOVEMBER, 6);
var time = LocalTime.of(1, 30);
var zone = ZoneId.of("US/Eastern");
var dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime); // 2022-11-06T01:30-04:00[US/Eastern]
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); // 2022-11-06T01:30-05:00[US/Eastern]
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); // 2022-11-06T02:30-05:00[US/Eastern]
```

went from 5:30 GMT to 6:30 GMT, to 7:30 GMT. Finally, trying to create a time that doesn’t exist just rolls forward:

```java
var date = LocalDate.of(2022, Month.MARCH, 13);
var time = LocalTime.of(2, 30);
var zone = ZoneId.of("US/Eastern");
var dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime); // 2022–03–13T03:30–04:00[US/Eastern]
```

Java is smart enough to know that there is no 2:30 a.m. that night and switches over to the appropriate GMT offset.

```java
public static void main(String[] args) {  
  
    /*  
    Similarly, in November, an hour after the initial 1:30 a.m. is also 1:30 a.m. because at 2:00 a.m.    we repeat the hour. This time, try to calculate the GMT time yourself for all three times to confirm that    we really do move only one hour at a time.     */  
    var date = LocalDate.of(2022, Month.NOVEMBER, 6);  
    var time = LocalTime.of(1, 30);  
    var zone = ZoneId.of("US/Eastern");  
    var dateTime = ZonedDateTime.of(date, time, zone);  
    System.out.println(dateTime); // 2022-11-06T01:30-04:00[US/Eastern]  
  
    dateTime = dateTime.plusHours(1);  
    System.out.println(dateTime); // 2022-11-06T01:30-05:00[US/Eastern]  
    dateTime = dateTime.plusHours(1);  
    System.out.println(dateTime); // 2022-11-06T02:30-05:00[US/Eastern]  
}
```

```java
public class DayLightSpringExample {  
  
    public static void main(String[] args) {  
  
        /*  
        For example, on March 13, 2022, we move our clocks forward an hour and jump from 2:00 a.m. to 3:00 a.m.        This means that there is no 2:30 a.m. that day.         If we wanted to know the time an hour later than 1:30, it would be 3:30.         */  
        System.out.println("---------- US/Eastern 2022 ----------");  
  
        var date1 = LocalDate.of(2022, Month.MARCH, 10);  
        var date2 = LocalDate.of(2022, Month.MARCH, 13);  
        var date3 = LocalDate.of(2022, Month.MARCH, 20);  
  
        printDaylightSavingTime(date1, ZoneId.of("US/Eastern"));  
        printDaylightSavingTime(date2, ZoneId.of("US/Eastern"));  
        printDaylightSavingTime(date3, ZoneId.of("US/Eastern"));  
  
        // Notice that two things change in this example. The time jumps from 1:30 to 3:30. The UTC offset also changes.  
  
        System.out.println("---------- US/Eastern 2023 ----------");  
  
        var date4 = LocalDate.of(2023, Month.MARCH, 10);  
        var date5 = LocalDate.of(2023, Month.MARCH, 12);  
        var date6 = LocalDate.of(2023, Month.MARCH, 20);  
  
        printDaylightSavingTime(date4, ZoneId.of("US/Eastern"));  
        printDaylightSavingTime(date5, ZoneId.of("US/Eastern"));  
        printDaylightSavingTime(date6, ZoneId.of("US/Eastern"));  
  
        System.out.println("---------- Europe/Berlin 2023 ----------");  
  
        var date7 = LocalDate.of(2023, Month.MARCH, 12);  
        var date8 = LocalDate.of(2023, Month.MARCH, 26);  
        var date9 = LocalDate.of(2023, Month.MARCH, 28);  
  
        printDaylightSavingTime(date7, ZoneId.of("Europe/Berlin"));  
        printDaylightSavingTime(date8, ZoneId.of("Europe/Berlin"));  
        printDaylightSavingTime(date9, ZoneId.of("Europe/Berlin"));  
  
        System.out.println("---------- Europe/London 2023 ----------");  
  
        var date10 = LocalDate.of(2023, Month.MARCH, 12);  
        var date11 = LocalDate.of(2023, Month.MARCH, 26);  
        var date12 = LocalDate.of(2023, Month.MARCH, 28);  
  
        // UK change time 1.00AM  
        // US and Europe/Berlin 2.00AM        printDaylightSavingTimeForUK(date10, ZoneId.of("Europe/London"));  
        printDaylightSavingTimeForUK(date11, ZoneId.of("Europe/London"));  
        printDaylightSavingTimeForUK(date12, ZoneId.of("Europe/London"));  
  
    }  
  
    private static void printDaylightSavingTime(LocalDate date, ZoneId zone) {  
  
        System.out.println("##############");  
  
        var time = LocalTime.of(1, 30);  
        var dateTime = ZonedDateTime.of(date, time, zone);  
        System.out.println("dateTime : " + dateTime);  
        System.out.println("hour : " + dateTime.getHour() + " , offset : " + dateTime.getOffset());  
  
        dateTime = dateTime.plusHours(1);  
        System.out.println("dateTime : " + dateTime);  
        System.out.println("hour : " + dateTime.getHour() + " , offset : " + dateTime.getOffset());  
    }  
  
    private static void printDaylightSavingTimeForUK(LocalDate date, ZoneId zone) {  
  
        System.out.println("##############");  
  
        var time = LocalTime.of(00, 30);  
        var dateTime = ZonedDateTime.of(date, time, zone);  
        System.out.println("dateTime : " + dateTime);  
        System.out.println("hour : " + dateTime.getHour() + " , offset : " + dateTime.getOffset());  
  
        dateTime = dateTime.plusHours(1);  
        System.out.println("dateTime : " + dateTime);  
        System.out.println("hour : " + dateTime.getHour() + " , offset : " + dateTime.getOffset());  
    }  
}
```
## Summary #OCP_Summary 

- ==**a ``String`` is an immutable sequence of characters. Calling the constructor explicitly is optional. The concatenation operator ``(+)`` creates a new ``String`` with the content of the first ``String`` followed by the content of the second ``String``. If either operand involved in the + expression is a ``String``, concatenation is used; otherwise, addition is used. String literals are stored in the string pool. The ``String`` class has many methods. By contrast, a ``StringBuilder`` is a mutable sequence of characters. Most of the methods return a reference to the current object to allow method chaining. The ``StringBuilder`` class has many methods.**==

- ==**Calling ``==`` on ``String`` objects will check whether they point to the same object in the pool. Calling ``==`` on ``StringBuilder`` references will check whether they are pointing to the same ``StringBuilder`` object. Calling ``equals()`` on ``String`` objects will check whether the sequence of characters is the same. Calling ``equals()`` on ``StringBuilder`` objects will check whether they are pointing to the same object rather than looking at the values inside.**==

- ==**An array is a fixed-size area of memory on the heap that has space for primitives or pointers to objects. You specify the size when creating it. For example, int[] a = new int[6];. Indexes begin with 0, and elements are referred to using a [0]. The ``Arrays.sort()`` method sorts an array. ``Arrays.binarySearch()`` searches a sorted array and returns the index of a match. If no match is found, it negates the position where the element would need to be inserted and subtracts 1. ``Arrays.compare()`` and ``Arrays.mismatch()`` check whether two arrays are equivalent. Methods that are passed ``varargs (...)`` can be used as if a normal array was passed in. In a multidimensional array, the second-level arrays and beyond can be different sizes.**==

- ==**The Math class provides a number of static methods for performing mathematical operations. For example, you can get minimums or maximums. You can round or even generate random numbers. Some methods work on any numeric primitive, and others only work on double.**==

- ==**A ``LocalDate`` contains just a date, a ``LocalTime`` contains just a time, and a ``LocalDateTime`` contains both a date and a time. All three have private constructors and are created using ``LocalDate.now()`` or ``LocalDate.of()`` (or the equivalents for that class). Dates and times can be manipulated using plusXXX or minusXXX methods. The ``Period`` class represents a number of days, months, or years to add to or subtract from a ``LocalDate`` or ``LocalDateTime``. The date and time classes are all immutable, which means the return value must be used.**==


## Exam Essentials #Essential

- **Be able to determine the output of code using String**. : Know the rules for concatenating with String and how to use common String methods. Know that a String is immutable. Pay special attention to the fact that indexes are zero-based and that the ``substring()`` method gets the string up until right before the index of the second parameter.

- **Be able to determine the output of code using StringBuilder.**: Know that a StringBuilder is mutable and how to use common StringBuilder methods. Know that ``substring()`` does not change the value of a StringBuilder, whereas ``append(), delete(), and insert()`` do change it. Also note that most StringBuilder methods return a reference to the current instance of StringBuilder.

- **Understand the difference between == and equals().**: ``==`` checks object equality. ``equals()`` depends on the implementation of the object it is being called on. For the String class, ``equals()`` checks the characters inside of it.

- **Be able to determine the output of code using arrays.**: Know how to declare and instantiate one-dimensional and multidimensional arrays. Be able to access each element and know when an index is out of bounds. Recognize correct and incorrect output when searching and sorting.

- **Identify the return types of Math methods**. Depending on the primitive passed in, the Math methods may return different primitive results.

- **Recognize invalid uses of dates and times.**: ``LocalDate`` does not contain time fields, and ``LocalTime`` does not contain date fields. Watch for operations being performed on the wrong time. Also watch for adding or subtracting time and ignoring the result. Be comfortable with date math, including time zones and daylight saving time.

## Review Questions

1. What is output by the following code? (Choose all that apply.)

```java
1: public class Fish {
2: public static void main(String[] args) {
3: int numFish = 4;
4: String fishType = "tuna";
5: String anotherFish = numFish + 1;
6: System.out.println(anotherFish + " " + fishType);
7: System.out.println(numFish + " " + 1);
8: } }
```

A. 4 1
B. 5
C. 5 tuna
D. 5tuna
E. 51tuna
F. The code does not compile.

**My Answer: F
Correct Answer: F**

**``numFish`` is an int, and 1 is an int. Therefore, we use numeric addition and get 5. The problem is that we can’t store an int in a String variable.**

---

2. Which of these array declarations are not legal? (Choose all that apply.)

A. ``int[][] scores = new int[5][];``
B. ``Object[][][] cubbies = new Object[3][0][5];``
C. ``String beans[] = new beans[6];``
D. ``java.util.Date[] dates[] = new java.util.Date[2][];``
E. ``int[][] types = new int[];``
F. ``int[][] java = new int[][];``

**My Answer: C,E,F**
**Correct Answer: C,E,F**

**Option C uses the variable name as if it were a type, which is clearly illegal. Options E and F don’t specify any size. Although it is legal to leave out the size for later dimensions of a multidimensional array, the first one is required**

---

3. Note that March 13, 2022 is the weekend when we spring forward, and November 6, 2022 is when we fall back for daylight saving time. Which of the following can fill in the blank without the code throwing an exception? (Choose all that apply.)

```java
var zone = ZoneId.of("US/Eastern");
var date = ;
var time = LocalTime.of(2, 15);
var z = ZonedDateTime.of(date, time, zone);
```

`A. LocalDate.of(2022, 3, 13)`
`B. LocalDate.of(2022, 3, 40)`
`C. LocalDate.of(2022, 11, 6)`
`D. LocalDate.of(2022, 11, 7)`
`E. LocalDate.of(2023, 2, 29)`
`F. LocalDate.of(2022, MonthEnum.MARCH, 13);`

**My Answer: A,C,F**
**Correct Answer: A,C,D**

**Option B throws an exception because there is no March 40.** 
**Option E also throws an exception because 2023 isn’t a leap year and therefore has no February 29.** 
**Option F doesn’t compile because the enum should be named Month, rather than MonthEnum.**

---

4. Which of the following are output by this code? (Choose all that apply.)

```java
3: var s = "Hello";
4: var t = new String(s);
5: if ("Hello".equals(s)) System.out.println("one");
6: if (t == s) System.out.println("two");
7: if (t.intern() == s) System.out.println("three");
8: if ("Hello" == s) System.out.println("four");
9: if ("Hello".intern() == t) System.out.println("five");
```

A. one
B. two
C. three
D. four
E. five
F. The code does not compile.
G. None of the above

**My Answer: A,C,D**
**Correct Answer: A,C,D**


---

5. What is the result of the following code?

```java
7: var sb = new StringBuilder();
8: sb.append("aaa").insert(1, "bb").insert(4, "ccc");
9: System.out.println(sb);
```

A. abbaaccc
B. abbaccca
C. bbaaaccc
D. bbaaccca
E. An empty line
F. The code does not compile.

**My Answer: B**
**Correct Answer: B**

**After the call to ``append()``, sb contains "aaa". That result is passed to the first ``insert()`` call, which inserts at index 1. At this point, sb contains abbaa. That result is passed to the final insert(), which inserts at index 4, resulting in abbaccca.**

---

6. How many of these lines contain a compiler error? (Choose all that apply.)

```java
23: double one = Math.pow(1, 2);
24: int two = Math.round(1.0);
25: float three = Math.random();
26: var doubles = new double[] {one, two, three};
```

A. 0
B. 1
C. 2
D. 3
E. 4

**My Answer: B**
**Correct Answer: C**

**Remember to watch return types on math operations. ==One of the tricks is line 24. The ``round()`` method returns an int when called with a float. However, we are calling it with a double, so it returns a long. The other trick is line 25. The ``random()`` method returns a double.**==

---

7.  Which of these statements is true of the two values? (Choose all that apply.)
	2022–08–28T05:00 GMT-04:00
	2022–08–28T09:00 GMT-06:00
A. The first date/time is earlier.
B. The second date/time is earlier.
C. Both date/times are the same.
D. The date/times are two hours apart.
E. The date/times are six hours apart.
F. The date/times are 10 hours apart.

**My Answer: A,E**
**Correct Answer: A,E**

**When dealing with time zones, it is best to convert to GMT first by subtracting the time zone. Remember that subtracting a negative is like adding. The first date/time is 9:00 GMT, and the second is 15:00 GMT. Therefore, the first one is earlier by six hours.**

---

8. Which of the following return 5 when run independently? (Choose all that apply.)
```java
var string = "12345";
var builder = new StringBuilder("12345");
```

`A. builder.charAt(4)`
`B. builder.replace(2, 4, "6").charAt(3)`
`C. builder.replace(2, 5, "6").charAt(2)`
`D. string.charAt(5)`
`E. string.length`
`F. string.replace("123", "1").charAt(2)`
G. None of the above

**My Answer: A,D,E**
**Correct Answer: A,B,F**

**Remember that indexes are zero-based, which means index 4 corresponds to 5, and option A is correct.**
**For option B, the replace() method starts the replacement at index 2 and ends before index 4. This means two characters are replaced, and ``charAt(3)`` is called on the intermediate value of 1265. The character at index 3 is 5, making option B correct. Option C is similar, making the intermediate value 126 and returning 6.**

---

9. Which of the following are true about arrays? (Choose all that apply.)
A. The first element is index 0.
B. The first element is index 1.
C. Arrays are fixed size.
D. Arrays are immutable.
E. Calling ``equals()`` on two different arrays containing the same primitive values always
returns true.
F. Calling ``equals()`` on two different arrays containing the same primitive values always
returns false.
G. Calling ``equals()`` on two different arrays containing the same primitive values can return
true or false.

**My Answer: A,C,G**
**Correct Answer: A,C,F**

**An array does not override equals(), so it uses object equality. Since two different objects are not equal, option F is correct, and options E and G are incorrect.**

---

10. How many of these lines contain a compiler error? (Choose all that apply.)
```JAVA
23: int one = Math.min(5, 3);
24: long two = Math.round(5.5);
25: double three = Math.floor(6.6);
26: var doubles = new double[] {one, two, three};
```

A. 0
B. 1
C. 2
D. 3
E. 4

**My Answer: B**
**Correct Answer: A**

**All of these lines compile. The ``min()`` and ``floor()`` methods return the same type passed in: int and double, respectively. The ``round()`` method returns a long when called with a double. Option A is correct since the code compiles.**

---

11. What is the output of the following code?

```java
var date = LocalDate.of(2022, 4, 3);
date.plusDays(2);
date.plusHours(3);
System.out.println(date.getYear() + " " + date.getMonth()
+ " " + date.getDayOfMonth());
```

A. 2022 MARCH 4
B. 2022 MARCH 6
C. 2022 APRIL 3
D. 2022 APRIL 5
E. The code does not compile.
F. A runtime exception is thrown.

**My Answer: E**
**Correct Answer: E**

**A ``LocalDate`` does not have a time element. Therefore, there is no method to add hours**

---

12. What is output by the following code? (Choose all that apply.)
```java
var numbers = "012345678".indent(1);
numbers = numbers.stripLeading();
System.out.println(numbers.substring(1, 3));
System.out.println(numbers.substring(7, 7));
System.out.print(numbers.substring(7));
```

A. 12
B. 123
C. 7
D. 78
E. A blank line
F. The code does not compile.
G. An exception is thrown.

**My Answer: A**
**Correct Answer: A,D,E**

**First, notice that the ``indent()`` call adds a blank space to the beginning of numbers, and ``stripLeading()`` immediately removes it. Therefore, these methods cancel each other out and have no effect. The ``substring()`` method has two forms. The first takes the index to start with and the index to stop immediately before. The second takes just the index to start with and goes to the end of the String.**


---

13. What is the result of the following code?

```java
public class Lion {
public void roar(String roar1, StringBuilder roar2) {
roar1.concat("!!!");
roar2.append("!!!");
}
public static void main(String[] args) {
var roar1 = "roar";
var roar2 = new StringBuilder("roar");
new Lion().roar(roar1, roar2);
System.out.println(roar1 + " " + roar2);
} }
```

A. roar roar
B. roar roar!!!
C. roar!!! roar
D. roar!!! roar!!!
E. An exception is thrown.
F. The code does not compile.

**My Answer: B**
**Correct Answer: B**

**A String is immutable. Calling ``concat()`` returns a new String but does not change the original. A StringBuilder is mutable. Calling ``append()`` adds characters to the existing character sequence along with returning a reference to the same object**

---

14. Given the following, which can correctly fill in the blank? (Choose all that apply.)
```java
var date = LocalDate.now();
var time = LocalTime.now();
var dateTime = LocalDateTime.now();
var zoneId = ZoneId.systemDefault();
var zonedDateTime = ZonedDateTime.of(dateTime, zoneId);
Instant instant = ;
```

`A. Instant.now()`
`B. new Instant()`
`C. date.toInstant()`
`D. dateTime.toInstant()`
`E. time.toInstant()`
`F. zonedDateTime.toInstant()`

**My Answer: A,C,F**
**Correct Answer: A,F**

**Options C, D, and E are incorrect because the source object does not represent a point in time. Without a time zone, Java doesn’t know what moment in time to use for the Instant.**

---

15. What is the output of the following? (Choose all that apply.)

```java
var arr = new String[] { "PIG", "pig", "123"};
Arrays.sort(arr);
System.out.println(Arrays.toString(arr));
System.out.println(Arrays.binarySearch(arr, "Pippa"));
```

A. [pig, PIG, 123]
B. [PIG, pig, 123]
C. [123, PIG, pig]
D. [123, pig, PIG]
E. -3
F. -2
G. The results of ``binarySearch()`` are undefined in this example.

**My Answer: C,F**
**Correct Answer: C,E**

**The ``binarySearch()`` method looks at where a value would be inserted, which is before the second element for Pippa.**

---

16. What is included in the output of the following code? (Choose all that apply.)

```JAVA
var base = "ewe\nsheep\\t";
int length = base.length();
int indent = base.indent(2).length();
int translate = base.translateEscapes().length();

var formatted = "%s %s %s".formatted(length, indent, translate);
System.out.format(formatted);
```

A. 10
B. 11
C. 12
D. 13
E. 14
F. 15
G. 16

**My Answer: B,D**
**Correct Answer: A,B,G**

**There are 11 characters in base because there are two escape characters. The \n counts as one character representing a new line, and the \\ counts as one character representing a backslash. This makes option B one of the answers. The ``indent()`` method adds two characters to the beginning of each of the two lines of base. This gives us four additional characters. However, the method also normalizes by adding a new line to the end if**
**it is missing. The extra character means we add five characters to the existing 11, which is option G. Finally, the ``translateEscapes()`` method turns any text escape characters into actual escape characters, making \\t into \t. This gets rid of one character, leaving us with 10 characters matching option A.**

---

17. Which of these statements are true? (Choose all that apply.)

```JAVA
var letters = new StringBuilder("abcdefg");
```

A. ``letters.substring(1, 2)`` returns a single-character String.
B. ``letters.substring(2, 2)`` returns a single-character String.
C. ``letters.substring(6, 5)`` returns a single-character String.
D. ``letters.substring(6, 6)`` returns a single-character String.
E. ``letters.substring(1, 2)`` throws an exception.
F. ``letters.substring(2, 2)`` throws an exception.
G. ``letters.substring(6, 5)`` throws an exception.
H. ``letters.substring(6, 6)`` throws an exception.

**My Answer: A,G**
**Correct Answer: A,G**

---

18. What is the result of the following code? (Choose all that apply.)

```JAVA
13: String s1 = """
14: purr""";
15: String s2 = "";
16:
17: s1.toUpperCase();
18: s1.trim();
19: s1.substring(1, 3);
20: s1 += "two";
21:
22: s2 += 2;
23: s2 += 'c';
24: s2 += false;
25:
26: if ( s2 == "2cfalse") System.out.println("==");
27: if ( s2.equals("2cfalse")) System.out.println("equals");
28: System.out.println(s1.length());
```

A. 2
B. 4
C. 7
D. 10
E. ==
F. equals
G. An exception is thrown.
H. The code does not compile.

**My Answer: C,F**
**Correct Answer: C,F**

the text block on lines 13 and 14 is equivalent to a regular String. Since there is no line break at
the end, this is four characters. Then, you have to know that String objects are immutable, which means the results of lines 17–19 are ignored. Finally, on line 20, something happens. We concatenate three new characters to s1 and now have a String of length 7, making option C correct. The if statement on line 26 returns false because the two String objects are not the same in memory. One comes directly from the string pool, and the other comes from building using String operations.

---

19. Which of the following fill in the blank to print a positive integer? (Choose all that apply.)

```java
String[] s1 = { "Camel", "Peacock", "Llama"};
String[] s2 = { "Camel", "Llama", "Peacock"};
String[] s3 = { "Camel"};
String[] s4 = { "Camel", null};
System.out.println(Arrays. );
```

`A. compare(s1, s2)`
`B. mismatch(s1, s2)`
`C. compare(s3, s4)`
`D. mismatch (s3, s4)`
`E. compare(s4, s4)`
`F. mismatch (s4, s4)`

**My Answer: A,B,D**
**Correct Answer: A,B,D**

---

20. Note that March 13, 2022 is the weekend that clocks spring ahead for daylight saving time.
What is the output of the following? (Choose all that apply.)

```java
var date = LocalDate.of(2022, Month.MARCH, 13);
var time = LocalTime.of(1, 30);
var zone = ZoneId.of("US/Eastern");
var dateTime1 = ZonedDateTime.of(date, time, zone);
var dateTime2 = dateTime1.plus(1, ChronoUnit.HOURS);
long diff = ChronoUnit.HOURS.between(dateTime1, dateTime2);
int hour = dateTime2.getHour();
boolean offset = dateTime1.getOffset() == dateTime2.getOffset();
System.out.println("diff = " + diff);
System.out.println("hour = " + hour);
System.out.println("offset = " + offset);
```

A. diff = 1
B. diff = 2
C. hour = 2
D. hour = 3
E. offset = true
F. The code does not compile.
G. A runtime exception is thrown.

**My Answer: E**
**Correct Answer: A,D**

The dateTime1 object has a time of 1:30 per initialization. The dateTime2 object is an hour later. However, there is no 2:30 when springing ahead, setting the time to 3:30. Option A is correct because it is an hour later. Option D is also correct because the hour of the new time is 3. Option E is not correct because we have changed the time zone offset due to daylight saving time.

---

21. Which of the following can fill in the blank to print avaJ? (Choose all that apply.)

```JAVA
3: var puzzle = new StringBuilder("Java");
4: puzzle. ;
5: System.out.println(puzzle);
```

`A. reverse()`
`B. append("vaJ$").substring(0, 4)`
`C. append("vaJ$").delete(0, 3).deleteCharAt(puzzle.length() -1)`
`D. append("vaJ$").delete(0, 3).deleteCharAt(puzzle.length())`
E. None of the above

**My Answer: A,C**
**Correct Answer: A,C**

---

22. What is the output of the following code?

```java
var date = LocalDate.of(2022, Month.APRIL, 30);
date.plusDays(2);
date.plusYears(3);
System.out.println(date.getYear() + " " + date.getMonth() + " " + date.getDayOfMonth());
```

A. 2022 APRIL 30
B. 2022 MAY 2
C. 2025 APRIL 2
D. 2025 APRIL 30
E. 2025 MAY 2
F. The code does not compile.
G. A runtime exception is thrown.

**My Answer: A**
**Correct Answer: A**

**A. The date starts out as April 30, 2022. Since dates are immutable and the plus methods’ return values are ignored, the result is unchanged**

---


# Chapter 5 - Methods #Chapter

## Designing Methods

![[Pasted image 20240315184800.png]]

This is called a ***method declaration***, which specifies all the information needed to call the method.
**==Two of the parts—the method name and parameter list—are called the method signature==**. The method signature provides instructions for how callers can reference this method. The method signature does not include

|Element|Value|Required?|
|---|---|---|
|Access modifier|public|No|
|Optional specifier|final|No|
|Return type|void|Yes|
|Method name|nap|Yes|
|Parameter list|(int minutes)|Yes, but can be empty|
|Parentheses|Yes|Yes|
|Method signature|nap(int minutes)|Yes|
|Exception list|throws InterruptedException|No|
|Method body|{<br>// take a nap<br>}|Yes, except for abstract methods|
```java
nap(10);
```

### Access Modifiers

An access modifier determines what classes a method can be accessed from. Think of it like a security guard. Java offers four choices of access modifier:

- ==**private** The ``private`` modifier means the method can be called only from within the same class.==

- ==**Package Access** With package access, the method can be called only from a class in the same package.==

- ==**protected** The ``protected`` modifier means the method can be called only from a class in the same package or a subclass.==

- ==**public** The ``public`` modifier means the method can be called from anywhere.==

The exam creators like to trick you by putting method elements in the wrong order or using incorrect values.

```java
public class ParkTrip {
	public void skip1() {}
	default void skip2() {} // DOES NOT COMPILE
	void public skip3() {} // DOES NOT COMPILE
	void skip4() {}
}
```

### Optional Specifiers

Unlike with access modifiers, you can have multiple specifiers in the same method. When this happens, you can specify them in any order. And since these specifiers are optional, you are allowed to not have any of them at all. This means you can have zero or more specifiers in a method declaration.

|Modifier|Description|Chapter covered|
|---|---|---|
|static|Indicates the method is a member of the shared class object|Chapter 5|
|abstract|Used in an abstract class or interface when the method body is excluded|Chapter 6|
|final|Specifies that the method may not be overridden in a subclass|Chapter 6|
|default|Used in an interface to provide a default implementation of a method for classes that implement the interface|Chapter 7|
|synchronized|Used with multithreaded code|Chapter 13|
|native|Used when interacting with code written in another language, such as C++|Out of scope|
|strictfp|Used for making floating-point calculations portable|Out of scope|

While access modifiers and optional specifiers can appear in any order, **==they must all appear before the return type.==**

---

**==Access modifiers and optional specifiers can be listed in any order, but once the return type is specified, the rest of the parts of the method are written in a specific order: name, parameter list, exception list, body.==** #TIP 

---

```JAVA
public class Exercise {
	public void bike1() {}
	public final void bike2() {}
	public static final void bike3() {}
	public final static void bike4() {}
	public modifier void bike5() {} // DOES NOT COMPILE
	public void final bike6() {} // DOES NOT COMPILE
	final public void bike7() {}
}
```

- The ``bike5()`` method doesn’t compile because modifier is not a valid optional specifier.
- The ``bike6()`` method doesn’t compile because the optional specifier is after the return type.
- The ``bike7()`` method does compile. Java allows the optional specifiers to appear before the access modifier.
### Return Type

The next item in a method declaration is the return type. It must appear after any access modifiers or optional specifiers and before the method name. The return type might be an actual Java type such as ``String`` or int. If there is no return type, the ``void`` keyword is used.

---

**a method must have a return type. If no value is returned, the ``void`` keyword must be used. You cannot omit the return type.**

---

When checking return types, you also have to look inside the method body. Methods with a return type other than ``void`` are required to have a return statement inside the method body. This return statement must include the primitive or object to be returned.

```java
public void swim(int distance) {
	if(distance <= 0) {
	// Exit early, nothing to do!
	return;
}
	System.out.print("Fish is swimming " + distance + " meters");
}
```

```java
public class Hike {
	public void hike1() {}
	public void hike2() { return; }
	public String hike3() { return ""; }
	public String hike4() {} // DOES NOT COMPILE
	public hike5() {} // DOES NOT COMPILE
	public String int hike6() { } // DOES NOT COMPILE
	String hike7(int a) { // DOES NOT COMPILE
		if (1 < 2) return "orange";
	}
}
```

- The ``hike4()`` method doesn’t compile because the return statement is missing
- The ``hike5()`` method doesn’t compile because the return type is missing.
- The ``hike6()`` method doesn’t compile because it attempts to use two return types.
- The ``hike7()`` method is a little tricky. There is a return statement, but it doesn’t always get run.

```java
String hike8(int a) {
	if (1 < 2) return "orange";
		return "apple"; // COMPILER WARNING
}
```

The code compiles, although the compiler will produce a warning about *unreachable code (or dead code)*. This means the compiler was smart enough to realize you wrote code that cannot possibly be reached. 

**==When returning a value, it needs to be assignable to the return type.==**

```java
public class Measurement {
	int getHeight1() {
		int temp = 9;
		return temp;
	}
	int getHeight2() {
		int temp = 9L; // DOES NOT COMPILE
		return temp;
	}
	int getHeight3() {
		long temp = 9L;
		return temp; // DOES NOT COMPILE
	}
}
```

- The ``getHeight2()`` method doesn’t compile because you can’t assign a long to an int.
- The method ``getHeight3()`` method doesn’t compile because you can’t return a long value as an int.
### Method Name

an identifier may only contain letters, numbers, currency symbols, or _ . Also, the first character is not allowed to be a number, and reserved words are not allowed. Finally, the single underscore character is not allowed.

```java
public class BeachTrip {
	public void jog1() {}
	public void 2jog() {} // DOES NOT COMPILE
	public jog3 void() {} // DOES NOT COMPILE
	public void Jog_$() {}
	public _() {} // DOES NOT COMPILE
	public void() {} // DOES NOT COMPILE
}
```

- The ``2jog()`` method doesn’t compile because identifiers are not allowed to begin with numbers.
- The ``jog3()`` method doesn’t compile because the method name is before the return type.
- The ``_`` method is not allowed since it consists of a single underscore
- The final line of code doesn’t compile because the method name is missing.
### Parameter List

Although the parameter list is required, it doesn’t have to contain any parameters. This means you can just have an empty pair of parentheses after the method name

```java
public class Sleep {
	void nap() {}
}
```

```java
public class PhysicalEducation {
	public void run1() {}
	public void run2 {} // DOES NOT COMPILE
	public void run3(int a) {}
	public void run4(int a; int b) {} // DOES NOT COMPILE
	public void run5(int a, int b) {}
}
```

- The ``run2()`` method doesn’t compile because it is missing the parentheses around the parameter list.
-  The ``run4()`` method doesn’t compile because the parameters are separated by a semicolon rather than a comma.
### Method Signature

**==A method signature, composed of the method name and parameter list==** . It’s important to note that the names of the parameters in the method signature are not used as part of a method signature. It’s important to note that the names of the parameters in the method signature are not used as part of a method signature. **==The parameter list is about the types of parameters and their order==.**

```java
public class Trip {
	public void visitZoo(String name, int waitTime) {}
	public void visitZoo(String attraction, int rainFall) {} // DOES NOT COMPILE
}
```

Despite having different parameter names, these two methods have the same signature and cannot be declared within the same class. Changing the order of parameter types does allow the method to compile

```java
public class Trip {
	public void visitZoo(String name, int waitTime) {}
	public void visitZoo(int rainFall, String attraction) {}
}
```

### Exception List

In Java, code can indicate that something went wrong by throwing an exception. it is optional and where in the method declaration it goes if present.

```java
public class ZooMonorail {
	public void zeroExceptions() {}
	public void oneException() throws IllegalArgumentException {}
	public void twoExceptions() throws IllegalArgumentException, InterruptedException {}
}
```

### Method Body

A method body is simply a code block. It has braces that contain zero or more Java statements.

```JAVA
public class Bird {
	public void fly1() {}
	public void fly2() // DOES NOT COMPILE
	public void fly3(int a) { int name = 5; }
}
```

- The ``fly2()`` method doesn’t compile because it is missing the braces around the empty method body.
**==Methods are required to have a body unless they are declared ``abstract``.==**
## Declaring Local and Instance Variables

local variables are those defined with a method or block, while instance variables are those that are defined as a member of a class.

```java
public class Lion {
	int hunger = 4;
	public int feedZooAnimals() {
		int snack = 10; // Local variable
		if(snack > 4) {
			long dinnerTime = snack++;
			hunger--;
		}
		return snack;
	}
}
```

In the ``Lion`` class, ``snack`` and ``dinnertime`` are local variables only accessible within their respective code blocks, while ``hunger`` is an instance variable and created in every object of the Lion class.
all local variable references are destroyed after the block is executed, but the objects they point to may still be accessible.

### Local Variable Modifiers

**==There’s only one modifier that can be applied to a local variable: ``final``==**.

```java
public void zooAnimalCheckup(boolean isWeekend) {
	final int rest;
	if(isWeekend) rest = 5; else rest = 20;
	System.out.print(rest);
	final var giraffe = new Animal();
	final int[] friends = new int[5];
	rest = 10; // DOES NOT COMPILE
	giraffe = new Animal(); // DOES NOT COMPILE
	friends = null; // DOES NOT COMPILE
}
```

when a ``final`` variable is declared. The rule is only that it must be assigned a value before it can be used.

```java
public void zooAnimalCheckup(boolean isWeekend) {
	final int rest;
	if(isWeekend) rest = 5;
		System.out.print(rest); // DOES NOT COMPILE
}
```

Since the compiler does not allow the use of local variables that may not have been assigned a value, the code does not compile. The ``final`` attribute only refers to the variable reference; the contents can be freely modified (assuming the object isn’t immutable).

```java
public void zooAnimalCheckup() {
	final int rest = 5;
	final Animal giraffe = new Animal();
	final int[] friends = new int[5];
	giraffe.setName("George");
	friends[2] = 2;
}
```

The ``rest`` variable is a primitive, so it’s just a value that can’t be modified. On the other hand, the contents of the ``giraffe`` and ``friends`` variables can be freely modified, provided the variables aren’t reassigned. 

---

**marking a local variable ``final`` is often a good practice. For example, you may have a complex method in which a variable is referenced dozens of times. It would be really bad if someone came in and reassigned the variable in the middle of the method. Using the ``final`` attribute is like sending a message to other developers to leave the variable alone!**

---

### Effectively Final Variables

An *effectively final* local variable is one that is not modified after it is assigned. This means that the value of a variable doesn’t change after it is set, regardless of whether it is explicitly marked as ``final``. If you aren’t sure whether a local variable is effectively final, just add the final keyword. If the code still compiles, the variable is effectively final.

---
The Effectively Final variable is a local variable that follows the following properties:
- ==**Not defined as ``final``**==
- ==**Assigned to ONLY once.**==
---

```java
11: public String zooFriends() {
12: String name = "Harry the Hippo";
13: var size = 10;
14: boolean wet;
15: if(size > 100) size++;
16: name.substring(0);
17: wet = true;
18: return name;
19: }
```

a quick test of effectively final is to just add final to the variable declaration and see if it still compiles.
In this example, name and wet are effectively final and can be updated with the final modifier, but not size. The name variable is assigned a value on line 12 and not reassigned. Line 16 creates a value that is never used. The size variable is not effectively final because it could be incremented on line 15.
### Instance Variable Modifiers

Like methods, instance variables can use access modifiers, such as ``private``, ``package``, ``protected``, and ``public``.
Instance variables can also use optional specifiers

|Modifier|Description|Chapter Covered|
|---|---|---|
|final|Specifies that the instance variable must be initialized with each instance of the class exactly once|Chapter 5|
|volatile|Instructs the JVM that the value in this variable may be modified by other threads|Chapter 13|
|transient|Used to indicate that an instance variable should not be serialized with the class|Out of scope|
If an instance variable is marked ``final``, then it must be assigned a value when it is declared or when the object is instantiated. Like a local final variable, it cannot be assigned a value more than once

```java
public class PolarBear {
	final int age = 10;
	final int fishEaten;
	final String name;
	{ fishEaten = 10; }
	public PolarBear() {
		name = "Robert";
	}
}
```

The ``age`` variable is given a value when it is declared, while the ``fishEaten`` variable is assigned a value in an instance initializer. The name variable is given a value in the no-argument constructor.

---

==**The compiler does not apply a default value to ``final`` variables, though. A ``final`` instance or ``final static`` variable must receive a value when it is declared or as part of initialization.**==

---

```java
public class PolarBear2 {  

    final int age;  
    final int fishEaten;  
    final String name;  
  
    public PolarBear2() {  
        this(1, 5);  
    }  
  
    public PolarBear2(int age, int fishEaten) {  
        this.age = age;  
        this.fishEaten = fishEaten;  
        name = "default";  
    }  
  
    public PolarBear2(int age, int fishEaten, String name) {  
        this.age = age;  
        this.fishEaten = fishEaten;  
        this.name = name;  
    }
```

## Working with Varargs

### Creating Methods with Varargs

**Rules for Creating a Method with a Varargs Parameter**

1. ==**A method can have at most one varargs parameter.**==
2. ==**If a method contains a varargs parameter, it must be the last parameter in the list.**==

```java
public class VisitAttractions {
	public void walk1(int... steps) {}
	public void walk2(int start, int... steps) {}
	public void walk3(int... steps, int start) {} // DOES NOT COMPILE
	public void walk4(int... start, int... steps) {} // DOES NOT COMPILE
	public void walk5(int start, ...int steps) {} // DOES NOT COMPILE
}
```

### Calling Methods with Varargs

When calling a method with a varargs parameter, you have a choice. You can pass in an array, or you can list the elements of the array and let Java create it for you.

```java
// Pass an array
int[] data = new int[] {1, 2, 3};
walk1(data);
// Pass a list of values
walk1(1,2,3);
```

Regardless of which one you use to call the method, the method will receive an array containing the elements.

```java
public void walk1(int... steps) {
	int[] step2 = steps; // Not necessary, but shows steps is of type int[]
	System.out.print(step2.length);
}
```

can even omit the varargs values in the method call, and Java will create an array of length zero for you.

```java
walk1();
```
###  Accessing Elements of a Vararg

Accessing a varargs parameter is just like accessing an array. It uses array indexing.

```java
16: public static void run(int... steps) {
17: System.out.print(steps[1]);
18: }
19: public static void main(String[] args) {
20: run(11, 77); // 77
21: }
```
### Using Varargs with Other Method Parameters

```java
1: public class DogWalker {
2: public static void walkDog(int start, int... steps) {
3: System.out.println(steps.length);
4: }
5: public static void main(String[] args) {
6: walkDog(1); // 0
7: walkDog(1, 2); // 1
8: walkDog(1, 2, 3); // 2
9: walkDog(1, new int[] {4, 5}); // 2
10: } }
```

Java will create an empty array if no parameters are passed for a vararg. However, it is still possible to pass ``null`` explicitly

```java
walkDog(1, null); // Triggers NullPointerException in walkDog()
```

Since ``null`` isn’t an int, Java treats it as an array reference that happens to be ``null``. It just passes on the ``null`` array object to ``walkDog()``. Then the ``walkDog()`` method throws an exception because it tries to determine the length of ``null``.
## Applying Access Modifiers

- ==**``private``: Only accessible within the same class.**==
- ==**Package access: ``private`` plus other members of the same package. Sometimes referred to as package-private or default access.**==
- ==**``protected``: Package access plus access within subclasses.**==
- ==**``public``: ``protected`` plus classes in the other packages.==**
### Private Access

Only code in the same class can call ``private`` methods or access ``private`` fields.

```java
1: package pond.duck;
2: public class FatherDuck {
3: private String noise = "quack";
4: private void quack() {
5: System.out.print(noise); // private access is ok
6: }
7: }
```

``FatherDuck`` declares a ``private`` method ``quack()`` and uses ``private`` instance variable ``noise`` on line 5.

```java
1: package pond.duck;
2: public class BadDuckling {
3: public void makeNoise() {
4: var duck = new FatherDuck();
5: duck.quack(); // DOES NOT COMPILE
6: System.out.print(duck.noise); // DOES NOT COMPILE
7: }
8: }
```

``BadDuckling`` is trying to access an instance variable and a method it has no business touching. accessing ``private`` members of other classes is not allowed, and you need to use a different type of access.

---

**In the previous example, ``FatherDuck`` and ``BadDuckling`` are in separate files, but what if they were declared in the same file? Even then, the code would still not compile as Java prevents access outside the class.**

---
### Package Access

When there is no access modifier, Java assumes package access.

```java
package pond.duck;
public class MotherDuck {
	String noise = "quack";
	void quack() {
		System.out.print(noise); // package access is ok
	}
}
```

The big difference is that ``MotherDuck`` lets other classes in the same package access members, whereas ``FatherDuck`` doesn’t (due to being private). 

```java
package pond.duck;
public class GoodDuckling {
	public void makeNoise() {
		var duck = new MotherDuck();
		duck.quack(); // package access is ok
		System.out.print(duck.noise); // package access is ok
	}
}
```

all the classes covered so far are in the same package, ``pond.duck``. This allows package access to work.

```java
package pond.swan;
import pond.duck.MotherDuck; // import another package
public class BadCygnet {
	public void makeNoise() {
		var duck = new MotherDuck();
		duck.quack(); // DOES NOT COMPILE
		System.out.print(duck.noise); // DOES NOT COMPILE
	}
}
```

``MotherDuck`` only allows lessons to other ducks by restricting access to the ``pond.duck`` package. ``BadCygnet`` is in the ``pond.swan`` package, and the code doesn’t compile.
### Protected Access

Protected access allows everything that package access does, and more. The ``protected`` access modifier adds the ability to access members of a parent class. 

```java
public class Fish {}
public class ClownFish extends Fish {}
```

the “child” ``ClownFish`` class is a subclass of the “parent” ``Fish`` class, using the ``extends`` keyword to connect them

**==By extending a class, the subclass gains access to all ``protected`` and ``public`` members of the parent class, as if they were declared in the subclass. If the two classes are in the same package, then the subclass also gains access to all package members.==**

```java
package pond.shore;
public class Bird {
	protected String text = "floating";
	protected void floatInWater() {
		System.out.print(text); // protected access is ok
	}
}
```

```java
package pond.goose; // Different package than Bird
import pond.shore.Bird;
public class Gosling extends Bird { // Gosling is a subclass of Bird
	public void swim() {
		floatInWater(); // protected access is ok
	System.out.print(text); // protected access is ok
	}
	public static void main(String[] args) {
		new Gosling().swim();
	}
}
```

This is a simple subclass. It extends the ``Bird`` class. Extending means creating a subclass that has access to any protected or public members of the parent class

Remember that protected also gives us access to everything that package access does. This means a class in the same package as ``Bird`` can access its protected members.

```java
package pond.shore; // Same package as Bird
public class BirdWatcher {
	public void watchBird() {
		Bird bird = new Bird();
		bird.floatInWater(); // protected access is ok
		System.out.print(bird.text); // protected access is ok
	}
}
```

Since ``Bird`` and ``BirdWatcher`` are in the same package, ``BirdWatcher`` can access package members of the bird variable. **==The definition of protected allows access to subclasses and classes in the same package.==**

```java
package pond.inland; // Different package than Bird
import pond.shore.Bird;
public class BirdWatcherFromAfar { // Not a subclass of Bird
	public void watchBird() {
		Bird bird = new Bird();
		bird.floatInWater(); // DOES NOT COMPILE
		System.out.print(bird.text); // DOES NOT COMPILE
	}
}
```

``BirdWatcherFromAfar`` is not in the same package as ``Bird``, and it doesn’t inherit from ``Bird``. This means it is not allowed to access protected members of ``Bird``. Subclasses and classes in the same package are the only ones allowed to access protected members.

```java
1: package pond.swan; // Different package than Bird
2: import pond.shore.Bird;
3: public class Swan extends Bird { // Swan is a subclass of Bird
	4: public void swim() {
		5: floatInWater(); // protected access is ok
		6: System.out.print(text); // protected access is ok
	7: }
	8: public void helpOtherSwanSwim() {
		9: Swan other = new Swan();
		10: other.floatInWater(); // subclass access to superclass
		11: System.out.print(other.text); // subclass access to superclass
	12: }
	13: public void helpOtherBirdSwim() {
		14: Bird other = new Bird();
		15: other.floatInWater(); // DOES NOT COMPILE
		16: System.out.print(other.text); // DOES NOT COMPILE
	17: }
18: }
```

``Swan`` is not in the same package as ``Bird`` but does extend it—which implies it has access to the protected members of Bird since it is a subclass. And it does. Lines 5 and 6 refer to protected members via inheriting them.

Lines 10 and 11 also successfully use protected members of ``Bird``. This is allowed because these lines refer to a ``Swan`` object. ``Swan`` inherits from ``Bird``, so this is okay. It is sort of a two-phase check. The ``Swan`` class is allowed to use protected members of ``Bird``, and we are referring to a ``Swan`` object. Granted, it is a ``Swan`` object created on line 9 rather than an inherited one, but it is still a ``Swan`` object.

Lines 15 and 16 do not compile a ``Bird`` reference is used rather than inheritance. It is created on line 14. ``Bird`` is in a different package, and this code isn’t inheriting from ``Bird``, so it doesn’t get to use protected members. the variable reference isn’t a ``Swan``. The code just happens to be in the ``Swan`` class.

Looking at it a different way, the protected rules apply under two scenarios:

- ==**A member is used without referring to a variable. This is the case on lines 5 and 6. In this case, we are taking advantage of inheritance, and protected access is allowed.**==

- ==**A member is used through a variable. This is the case on lines 10, 11, 15, and 16. In this case, the rules for the reference type of the variable are what matter. If it is a subclass, protected access is allowed. This works for references to the same class or a subclass.==**

---

**==In Java, when a class extends another class, it inherits access to its protected members, allowing it to use them directly. When accessing these members through an object of the subclass, it's considered accessing them via inheritance, which is permitted. However, if you try to access protected members through a reference to the superclass, it won't compile because it's not considered inheritance and thus doesn't have access to those members.==** #TIP 

---

```JAVA
package pond.goose;
import pond.shore.Bird;
public class Goose extends Bird {
	public void helpGooseSwim() {
		Goose other = new Goose();
		other.floatInWater();
		System.out.print(other.text);
	}
	public void helpOtherGooseSwim() {
		Bird other = new Goose();
		other.floatInWater(); // DOES NOT COMPILE
		System.out.print(other.text); // DOES NOT COMPILE
	}
}
```

The second method is a problem. Although the object happens to be a ``Goose``, it is stored in a ``Bird`` reference. We are not allowed to refer to members of the ``Bird`` class since we are not in the same package and the reference type of other is not a subclass of ``Goose``.

```java
package pond.duck;
import pond.goose.Goose;
public class GooseWatcher {
	public void watch() {
		Goose goose = new Goose();
		goose.floatInWater(); // DOES NOT COMPILE
		// This code doesn’t compile because we are not in the goose object.
	}
}
```

This code doesn’t compile because we are not in the goose object. The ``floatInWater()`` method is declared in ``Bird``. ``GooseWatcher`` is not in the same package as ``Bird``, nor does it extend ``Bird``. ``Goose`` extends ``Bird``. That only lets ``Goose`` refer to ``floatInWater()``, not callers of ``Goose``.

---

**==the `GooseWatcher` class attempts to call the `floatInWater()` method on a `Goose` object, but it doesn't compile because `GooseWatcher` doesn't inherit from `Bird` nor is it in the same package as `Bird`. While `Goose` extends `Bird`, this only allows instances of `Goose` to access `floatInWater()`, not instances of `GooseWatcher`. Essentially, access to `floatInWater()` is restricted to instances of `Goose` or its subclasses due to the protected access level, and `GooseWatcher` isn't in that inheritance hierarchy.==**

---
### Public Access

``public`` means anyone can access the member from anywhere.

```java
package pond.duck;
public class DuckTeacher {
	public String name = "helpful";
	public void swim() {
		System.out.print(name); // public access is ok
	}
}
```

```java
package pond.goose;
import pond.duck.DuckTeacher;
public class LostDuckling {
	public void swim() {
		var teacher = new DuckTeacher();
		teacher.swim(); // allowed
		System.out.print("Thanks" + teacher.name); // allowed
	}
}
```

### Reviewing Access Modifiers

A method in `` ______`` can access a ``______`` member.

|                                           | private | package | protected | public |
| ----------------------------------------- | ------- | ------- | --------- | ------ |
| the same class                            | Yes     | Yes     | Yes       | Yes    |
| another class in the same package         | No      | Yes     | Yes       | Yes    |
| a subclass in a different package         | No      | No      | Yes       | Yes    |
| an unrelated class in a different package | No      | No      | No        | Yes    |
## Accessing ``static`` Data

When the ``static`` keyword is applied to a variable, method, or class, it belongs to the class rather than a specific instance of the class.
### Designing ``static`` Methods and Variables

Methods and variables declared static don’t require an instance of the class. They are shared among all users of the class.

```java
public class Penguin {
	String name;
	static String nameOfTallestPenguin;
}
```

**==think of a ``static`` variable as being a member of the single class object that exists independently of any instances of that class.==**

```java
public static void main(String[] unused) {
	var p1 = new Penguin();
	p1.name = "Lilly";
	p1.nameOfTallestPenguin = "Lilly";
	var p2 = new Penguin();
	p2.name = "Willy";
	p2.nameOfTallestPenguin = "Willy";
	
	System.out.println(p1.name); // Lilly
	System.out.println(p1.nameOfTallestPenguin); // Willy
	System.out.println(p2.name); // Willy
	System.out.println(p2.nameOfTallestPenguin); // Willy
}
```


```java
public class Koala {
	public static int count = 0; // static variable
	public static void main(String[] args) { // static method
		System.out.print(count);
	}
}
```

``static`` methods have two main purposes:

- For utility or helper methods that don’t require any object state. Since there is no need to access instance variables, having static methods eliminates the need for the caller to instantiate an object just to call the method.

-  For state that is shared by all instances of a class, like a counter. All instances must share the same state. Methods that merely use that state should be static as well.
### Accessing a ``static`` Variable or Method

```java
public class Snake {
	public static long hiss = 2;
}
```

just put the class name before the method or variable, and you are done.

```java
System.out.println(Snake.hiss);
```

**==There is one rule that is trickier. You can use an instance of the object to call a ``static`` method. The compiler checks for the type of the reference and uses that instead of the object==**

```java
5: Snake s = new Snake();
6: System.out.println(s.hiss); // s is a Snake
7: s = null;
8: System.out.println(s.hiss); // s is still a Snake
```

Java doesn’t care that ``s`` happens to be ``null``. Since we are looking for a ``static`` variable, it doesn’t matter.

---

==**Remember to look at the reference type for a variable when you see a ``static`` method or variable. The exam creators will try to trick you into thinking a ``NullPointerException`` is thrown because the variable happens to be ``null``. Don’t be fooled!**== #TIP 

---

```java
Snake.hiss = 4;
Snake snake1 = new Snake();
Snake snake2 = new Snake();
snake1.hiss = 6;
snake2.hiss = 5;
System.out.println(Snake.hiss); // 5 
```
### Class vs. Instance Membership

**==A ``static`` member cannot call an instance member without referencing an instance of the class.==**

```java
public class MantaRay {
	private String name = "Sammy";
	public static void first() { }
	public static void second() { }
	public void third() { System.out.print(name); }
	public static void main(String args[]) {
		first();
		second();
		third(); // DOES NOT COMPILE
	}
}
```

The compiler will give you an error about making a ``static`` reference to an instance method. If we fix this by adding ``static`` to ``third()``, we create a new problem.

```java
public static void third() { System.out.print(name); } // DOES NOT COMPILE
```

All this does is move the problem. Now, ``third()`` is referring to an instance variable name. There are two ways we could fix this. 

1. Add static to the name variable as well

```java
public class MantaRay {
	private static String name = "Sammy";
	...
	public static void third() { System.out.print(name); }
	...
}
```

2. call ``third()`` as an instance method and not use ``static`` for the method or the variable. 

```java
public class MantaRay {
	private String name = "Sammy";
	...
	public void third() { System.out.print(name); }
	public static void main(String args[]) {
		...
		var ray = new MantaRay();
		ray.third();
	}
}
```

**==A ``static`` method or instance method can call a ``static`` method because ``static`` methods don’t require an object to use.==** **==Only an instance method can call another instance method on the same class without using a reference variable==**, because instance methods do require an object. Similar logic applies for instance and ``static`` variables.

```java
public class Giraffe {
	public void eat(Giraffe g) {}
	public void drink() {};
	public static void allGiraffeGoHome(Giraffe g) {}
	public static void allGiraffeComeOut() {}
}
```

| Method                 | Calling                 | Legal |
| ---------------------- | ----------------------- | ----- |
| ``allGiraffeGoHome()`` | ``allGiraffeComeOut()`` | Yes   |
| ``allGiraffeGoHome()`` | ``drink()``             | No    |
| ``allGiraffeGoHome()`` | ``g.eat()``             | Yes   |
| ``eat()``              | ``allGiraffeComeOut()`` | Yes   |
| ``eat()``              | ``drink()``             | Yes   |
| ``eat()``              | ``g.eat()``             | Yes   |

```java
1: public class Gorilla {
	2: public static int count;
	3: public static void addGorilla() { count++; }
	4: public void babyGorilla() { count++; }
	5: public void announceBabies() {
		6: addGorilla();
		7: babyGorilla();
	8: }
	9: public static void announceBabiesToEveryone() {
		10: addGorilla();
		11: babyGorilla(); // DOES NOT COMPILE
	12: }
	13: public int total;
	14: public static double average
	15: = total / count; // DOES NOT COMPILE
16: }
```

- Lines 3 and 4 are fine because both ``static`` and instance methods can refer to a ``static`` variable.
- Lines 5–8 are fine because an instance method can call a ``static`` method.
- **==Line 11 doesn’t compile because a ``static`` method cannot call an instance method==**.
- **==Line 15 doesn’t compile because a ``static`` variable is trying to use an instance variable==**.
### ``static`` Variable Modifiers

``static`` variables can be declared with the same modifiers as instance variables, such as ``final``, ``transient``, and ``volatile``. While some ``static`` variables are meant to change as the program runs, like our count example, others are meant to never change. This type of ``static`` variable is known as a constant. It uses the ``final`` modifier to ensure the variable never changes.

Constants use the modifier ``static final`` and a different naming convention than other variables. They use all uppercase letters with underscores between “words.”

```java
public class ZooPen {
	private static final int NUM_BUCKETS = 45;
	public static void main(String[] args) {
		NUM_BUCKETS = 5; // DOES NOT COMPILE
	}
}
```

The compiler will make sure that you do not accidentally try to update a ``final`` variable.

```java
import java.util.*;
public class ZooInventoryManager {
	private static final String[] treats = new String[10];
	public static void main(String[] args) {
		treats[0] = "popcorn";
	}
}
```

It actually does compile since ``treats`` is a reference variable. **==We are allowed to modify the referenced object or array’s contents==**. All the compiler can do is check that we don’t try to reassign ``treats`` to point to a different object.

**==The rules for ``static final`` variables are similar to instance ``final`` variables, except they do not use ``static`` constructors (there is no such thing!) and use ``static`` initializers instead of instance initializers.==**

```java
public class Panda {
	final static String name = "Ronda";
	static final int bamboo;
	static final double height; // DOES NOT COMPILE
	static { bamboo = 5;}
}
```

- The ``name`` variable is assigned a value when it is declared
- The ``bamboo`` variable is assigned a value in a static initializer.
- The ``height`` variable is not assigned a value anywhere in the class definition, so that line does not compile.

### ``static`` Initializers

Static initializers add the ``static`` keyword to specify that they should be run when the class is first loaded.

```java
static {
	NUM_SECONDS_PER_MINUTE = 60;
	NUM_MINUTES_PER_HOUR = 60;
}
static {
	NUM_SECONDS_PER_HOUR = NUM_SECONDS_PER_MINUTE * NUM_MINUTES_PER_HOUR;
}
```

**==All ``static`` initializers run when the class is first used, in the order they are defined==**. The statements in them run and assign any ``static`` variables as needed. The final variables aren’t allowed to be reassigned(Assumed). **==The key here is that the ``static`` initializer is the first assignment. And since it occurs up front, it is okay==**.

```java
14: private static int one;
15: private static final int two;
16: private static final int three = 3;
17: private static final int four; // DOES NOT COMPILE
	private int five;
	private static final int eight;

18: static {
		19: one = 1;
		20: two = 2;
		21: three = 3; // DOES NOT COMPILE
		22: two = 4; // DOES NOT COMPILE
		five = 5; // DOES NOT COMPILE - instance variable!
		static int seven = 7; // DOES NOT COMPILE - local variable
		eight = 8;
23: }

	static {  
	     eight = 8; // DOES NOT COMPILE  
	}
```

- Line 14 declares a ``static`` variable that is not ``final``. It can be assigned as many times as we like
- Line 15 declares a ``final`` variable without initializing it. This means we can initialize it exactly once in a static block.
- Line 22 doesn’t compile because this is the second attempt.
- Line 16 declares a ``final`` variable and initializes it at the same time. We are not allowed to assign it again, so line 21 doesn’t compile.
- Line 17 declares **==a ``static final`` variable that never gets initialized==**. The compiler gives a compiler error because it knows that **==the ``static`` blocks are the only place the variable could possibly be initialized==**.

### ``static`` Imports

```java
import java.util.ArrayList;
import java.util.*;
```

```java
import java.util.List;
import java.util.Arrays;
public class Imports {
	public static void main(String[] args) {
		List<String> list = Arrays.asList("one", "two");
	}
}
```

**==Regular imports are for importing classes, while ``static`` imports are for importing static members of classes like variables and methods.==** Just like regular imports, you can use a wildcard or import a specific member.

```java
import java.util.List;
import static java.util.Arrays.asList; // static import
public class ZooParking {
	public static void main(String[] args) {
		List<String> list = asList("one", "two"); // No Arrays. prefix
	}
}
```

**==An interesting case is what would happen if we created an ``asList`` method in our ``ZooParking`` class. Java would give it preference over the imported one, and the method we coded would be used.==**

```java
1: import static java.util.Arrays; // DOES NOT COMPILE
2: import static java.util.Arrays.asList;
3: static import java.util.Arrays.*; // DOES NOT COMPILE
4: public class BadZooParking {
	5: public static void main(String[] args) {
		6: Arrays.asList("one"); // DOES NOT COMPILE
	7: }
8: }
```

- Line 1 tries to use a ``static`` import to import a class.
- Line 3 tries to see whether you are paying attention to the order of keywords.
- Line 6 is sneaky. The ``asList`` method is imported on line 2. However, the ``Arrays`` class is not imported anywhere. This makes it okay to write ``asList("one")`` but not ``Arrays.asList("one")``.

**==The compiler will complain if you try to explicitly do a ``static`` import of two methods with the same name or two ``static`` variables with the same name.==**

```java
import static zoo.A.TYPE;
import static zoo.B.TYPE; // DOES NOT COMPILE
```

```java
import static java.lang.Integer.MAX_VALUE;  
import static java.lang.Long.MAX_VALUE;  // DOES NOT COMPILE
// Field 'MAX_VALUE' is already defined in a single static import  
// Reference to 'MAX_VALUE' is ambiguous, both 'Integer.MAX_VALUE' and 'Long.MAX_VALUE'  
public class StaticImportSameName {  
  
    public static void main(String[] args) {  
  
        System.out.println(MAX_VALUE);  
  
    }
```

## Passing Data among Methods

**==Java is a *pass-by-value* language. This means that a copy of the variable is made and the method receives that copy. Assignments made in the method do not affect the caller==**

```java
2: public static void main(String[] args) {
	3: int num = 4;
	4: newNumber(num);
	5: System.out.print(num); // 4
6: }
7: public static void newNumber(int num) {
	8: num = 8;
9: }
```

The name could be anything. The exam will often use the same name to try to confuse you. The variable on line 3 never changes because no assignments are made to it.
### Passing Objects

```java
public class Dog {
	public static void main(String[] args) {
		String name = "Webby";
		speak(name);
		System.out.print(name); // Webby
	}
	public static void speak(String name) {
		name = "Georgette";
	}
}
```

Just as in the primitive example, the variable assignment is only to the method parameter and doesn’t affect the caller.

```java
public class Dog {
	public static void main(String[] args) {
		var name = new StringBuilder("Webby");
		speak(name);
		System.out.print(name); // WebbyGeorgette
	}
	public static void speak(StringBuilder s) {
		s = null;  
		s = new StringBuilder("reassign");
		s.append("Georgette");
	}
}
```

In this case, ``speak()`` calls a method on the parameter. It doesn’t reassign s to a different object. The variable ``s`` is a copy of the variable name. Both point to the same ``StringBuilder``, which means that changes made to the ``StringBuilder`` are available to both references.

![[Pasted image 20240316191549.png]]

---

**Pass-by-Value vs. Pass-by-Reference**
**the ``swap()`` method does not change the original values. It only changes a and b within the method.**

```java
public static void main(String[] args) {
	int original1 = 1;
	int original2 = 2;
	swap(original1, original2);
	System.out.println(original1); // 1
	System.out.println(original2); // 2
}
public static void swap(int a, int b) {
	int temp = a;
	a = b;
	b = temp;
}
```

---
### Returning Objects

A copy is made of the primitive or reference and returned from the method. Most of the time, this returned value is used.

```java
1: public class ZooTickets {
	2: public static void main(String[] args) {
		3: int tickets = 2; // tickets = 2
		4: String guests = "abc"; // guests = abc
		5: addTickets(tickets); // tickets = 2
		6: guests = addGuests(guests); // guests = abcd
		7: System.out.println(tickets + guests); // 2abcd
	8: }
	9: public static int addTickets(int tickets) {
		10: tickets++;
		11: return tickets;
	12: }
	13: public static String addGuests(String guests) {
		14: guests += "d";
		15: return guests;
	16: }
17: }
```

When you see such questions on the exam, write down the values of each variable.

- Lines 3 and 4 are straightforward assignments. 
- Line 5 calls a method.
- Line 10 increments the method parameter to 3 but leaves the ``tickets`` variable in the ``main()`` method as 2
- line 11 returns the value, the caller ignores it.
- The method call on line 6 doesn’t ignore the result, so ``guests`` becomes "abcd"
### Autoboxing and Unboxing Variables

Java supports some helpful features around passing primitive and wrapper data types, such as ``int`` and ``Integer``.

```java
5: int quack = 5;
6: Integer quackquack = Integer.valueOf(quack); // Convert int to Integer
7: int quackquackquack = quackquack.intValue(); // Convert Integer to int
```

Useful, but a bit verbose. Luckily, Java has handlers built into the Java language that automatically convert between primitives and wrapper classes and back again. 
- ==**Autoboxing is the process of converting a primitive into its equivalent wrapper class,**==  
- ==**Unboxing is the process of converting a wrapper class into its equivalent primitive==**

```java
5: int quack = 5;
6: Integer quackquack = Integer.valueOf(quack); // Convert int to Integer
7: int quackquackquack = quackquack.intValue(); // Convert Integer to int
```

Autoboxing applies to all primitives and their associated wrapper types, such as the following:

```java
Short tail = 8; // Autoboxing
Character p = Character.valueOf('p');
char paw = p; // Unboxing
Boolean nose = true; // Autoboxing
Integer e = Integer.valueOf(9);
long ears = e; // Unboxing, then implicit casting
```

In the last line, ``e`` is unboxed to an ``int`` value. Since an ``int`` value can be stored in a ``long`` variable via implicit casting, the compiler allows the assignment.

---
**==Limits of Autoboxing and Numeric Promotion==**

**==While Java will implicitly cast a smaller primitive to a larger type, as well as autobox, it will not do both at the same time.==**

```java
Long badGorilla = 8; // DOES NOT COMPILE
```

**==Java will automatically cast or autobox the ``int`` value to ``long`` or ``Integer``, respectively. Neither of these types can be assigned to a ``Long`` reference variable, though, so the code does not compile==**

---

What do you think happens if you try to unbox a ``null``?

```java
10: Character elephant = null;
11: char badElephant = elephant; // NullPointerException
```

Since calling any method on ``null`` gives a ``NullPointerException``, that is just what we get. Be careful when you see ``null`` in relation to autoboxing and unboxing.

```java
public class Chimpanzee {
	public void climb(long t) {}
	public void swing(Integer u) {}
	public void jump(int v) {}
	public static void main(String[] args) {
		var c = new Chimpanzee();
		c.climb(123);
		c.swing(123);
		c.jump(123L); // DOES NOT COMPILE
	}
}
```

- ``climb()`` compiles because the ``int`` value can be implicitly cast to a ``long``.
- ``swing()`` also is permitted, because the int value is autoboxed to an ``Integer``.
- ``jump()`` results in a compiler error because a ``long`` must be explicitly cast to an ``int``. In other words, Java will not automatically convert to a narrower type.

```java
public class Gorilla {
	public void rest(Long x) {
		System.out.print("long");
	}
	public static void main(String[] args) {
		var g = new Gorilla();
		g.rest(8); // DOES NOT COMPILE
	}
}
```

Java will cast or autobox the value automatically, but not both at the same time.
## Overloading Methods

==***Method overloading* occurs when methods in the same class have the same name but different method signatures, which means they use different parameter lists.**== Overloading also allows different numbers of parameters. **==Everything other than the method name can vary for overloading methods==**. This means
there can be different access modifiers, optional specifiers (like static), return types, and exception lists.

```java
public class Falcon {
	public void fly(int numMiles) {}
	public void fly(short numFeet) {}
	public boolean fly() { return false; }
	void fly(int numMiles, short numFeet) {}
	public void fly(short numFeet, int numMiles) throws Exception {}
}
```

**==the return type, access modifier, and exception list are irrelevant to overloading. Only the method name and parameter list matter.==**

```java
public class Eagle {
	public void fly(int numMiles) {}
	public int fly(int numMiles) { return 1; } // DOES NOT COMPILE
}
```

This method doesn’t compile because it differs from the original only by return type. The method signatures are the same, so they are duplicate methods as far as Java is concerned.

```java
public class Hawk {
	public void fly(int numMiles) {}
	public static void fly(int numMiles) {} // DOES NOT COMPILE
	public void fly(int numKilometers) {} // DOES NOT COMPILE
}
```

Calling overloaded methods is easy. You just write code, and Java calls the right one.

```java
public class Dove {
	public void fly(int numMiles) {
		System.out.println("int");
	}
	public void fly(short numFeet) {
		System.out.println("short");
	}
}
```

The call ``fly((short) 1)`` prints ``short``. It looks for matching types and calls the appropriate method.
### Reference Types

**==the rule about Java picking the most specific version of a method that it can==**

```java
public class Pelican {
	public void fly(String s) {
		System.out.print("string");
	}
	public void fly(Object o) {
		System.out.print("object");
	}
	public static void main(String[] args) {
		var p = new Pelican();
		p.fly("test"); // String
		System.out.print("-");
		p.fly(56); // Object
	}
}
```

- The first call passes a String and finds a direct match.
- The second call looks for an int parameter list. When it doesn’t find one, it autoboxes to ``Integer``. Since it still doesn’t find a match, it goes to the ``Object`` one.

```java
import java.time.*;
import java.util.*;
public class Parrot {
	public static void print(List<Integer> i) {
		System.out.print("I");
	}
	public static void print(CharSequence c) {
		System.out.print("C");
	}
	public static void print(Object o) {
		System.out.print("O");
	}
	public static void main(String[] args){
		print("abc"); // C
		print(Arrays.asList(3)); // I
		print(LocalDate.of(2019, Month.JULY, 4)); // O
	}
}
```

The code is due for a promotion!

- The first call to ``print()`` passes a ``String``.
- ``Arrays.asList()`` can be used to create ``asList<Integer>`` object
- The final call to print() passes a ``LocalDate``. That means the ``Object`` method signature is used.

### Primitives

Primitives work in a way that’s similar to reference variables. Java tries to find the most specific matching overloaded method.

```java
public class Ostrich {
	public void fly(int i) {
		System.out.print("int");
	}
	public void fly(long l) {
		System.out.print("long");
	}
	public static void main(String[] args) {
		var p = new Ostrich();
		p.fly(123); // int
		System.out.print("-");
		p.fly(123L); // long
	}
}
```

- The first call passes an int and sees an exact match.
- The second call passes a long and also sees an exact match
Java has no problem calling a larger primitive. However, it will not do so unless a better match is not found.

```java
public class Ambiguous {  
  
    private static void fly(int a, long b) {  
        System.out.println("int , long");  
    }  
  
    private static void fly(long a, int b) {  
        System.out.println("long , int");  
    }  
  
    public static void main(String[] args) {  
  
        fly(1, 2); // DOES NOT COMPILE Ambiguous method call!  
        fly(1L, 2);  
        fly(1, 2L);  
    }  
}
```
### Autoboxing

```java
public class Kiwi {
	public void fly(int numMiles) {}
	public void fly(Integer numMiles) {}
}
```

These method overloads are valid. Java tries to use the most specific parameter list it can find. This is true for autoboxing as well as other matching types we talk about in this section. This means calling ``fly(3)`` will call the first method. **==When the primitive ``int`` version isn’t present, Java will autobox. However, when the primitive ``int`` version is provided, there is no reason for Java to do the extra work of autoboxing.==**

### Arrays

```java
public static void walk(int[] ints) {}
public static void walk(Integer[] integers) {}
```

this code does not autobox:

### Varargs

Which method do you think is called if we pass an ``int[]``?

```java
public class Toucan {
	public void fly(int[] lengths) {}
	public void fly(int... lengths) {} // DOES NOT COMPILE
}
```

Java treats ``varargs`` as if they were an array. This means the method signature is the same for both methods. Since we are not allowed to overload methods with the same parameter list, this code doesn’t compile. Even though the code doesn’t look the same, it compiles to the same parameter list

```java
fly(new int[] { 1, 2, 3 }); // Allowed to call either fly() method
```

you can only call the ``varargs`` version with stand-alone parameters:

```java
fly(1, 2, 3); // Allowed to call only the fly() method using varargs
```

### Putting It All Together

**==Java calls the most specific method it can. When some of the types interact, the Java rules focus on backward compatibility. A long time ago, autoboxing and varargs didn’t exist. Since old code still needs to work, this means autoboxing and varargs come last when Java looks at overloaded methods.==**

The order that Java uses to choose the right overloaded method

| Rule                  | Method Signature                     |
| --------------------- | ------------------------------------ |
| Exact match by type   | `String glide(int i, int j)`         |
| Larger primitive type | `String glide(long i, long j)`       |
| Autoboxed type        | `String glide(Integer i, Integer j)` |
| Varargs               | `String glide(int... nums)`          |
```java
public class Glider {
	public static String glide(String s) {
		return "1";
	}
	public static String glide(String... s) {
		return "2";
	}
	public static String glide(Object o) {
		return "3";
	}
	public static String glide(String s, String t) {
		return "4";
	}
	public static void main(String[] args) {
		System.out.print(glide("a")); // 1
		System.out.print(glide("a", "b")); // 4
		System.out.print(glide("a", "b", "c")); // 2
	}
}
```

- The first call matches the signature taking a single ``String`` because that is the most specific match.
- The second call matches the signature taking two ``String`` parameters since that is an exact match.

## Summary #OCP_Summary 

**==The access modifiers are ``private``, package (omitted), ``protected``, and ``public``. The optional specifier for methods  ``static``. For this chapter.**==

==**the method return type, which is ``void`` if there is no return value. The method name and parameter list are provided next, which compose the unique method signature. The method name uses standard Java identifier rules, while the parameter list is composed of zero or more types with names. An optional list of exceptions may also be added following the parameter list. Finally, a block defines the method body (which is omitted for ``abstract`` methods).**==

==**Using the ``private`` keyword means the code is only available from within the same class. Package access means the code is available only from within the same package. Using the ``protected`` keyword means the code is available from the same package or subclasses. Using the ``public`` keyword means the code is available from anywhere.**==

==**Both ``static`` methods and ``static`` variables are shared by all instances of the class. When referenced from outside the class, they are called using the class name—for example, ``Pigeon.fly()``. Instance members are allowed to call ``static`` members, but ``static`` members are not allowed to call instance members. In addition, ``static`` imports are used to import ``static`` members.**==

==**the ``final`` modifier and showed how it can be applied to local, instance, and ``static`` variables. Remember, a local variable is effectively final if it is not modified after it is assigned. One quick test for this is to add the ``final`` modifier and see if the code still compiles.**==

==**Java uses pass-by- value, which means that calls to methods create a copy of the parameters. Assigning new values to those parameters in the method doesn’t affect the caller’s variables. Calling methods on objects that are method parameters changes the state of those objects and is reflected in the caller. Java supports autoboxing and unboxing of primitives and wrappers automatically within a method and through method calls.**==

==**Overloaded methods are methods with the same name but a different parameter list. Java calls the most specific method it can find. Exact matches are preferred, followed by wider primitives. After that comes autoboxing and finally ``varargs``.==**

## Exam Essentials #Essential 

**Be able to identify correct and incorrect method declarations.** Be able to view a method signature and know if it is correct, contains invalid or conflicting elements, or contains elements in the wrong order.

**Identify when a method or field is accessible**. Recognize when a method or field is accessible when the access modifier is: ``private``, package (omitted), ``protected``, or ``public``.

**Understand how to declare and use final variables**. Local, instance, and ``static`` variables may be declared final. Be able to understand how to declare them and how they can (or cannot) be used.

**Recognize valid and invalid uses of static imports**  ``Static`` imports import ``static`` members. They are written as import static, not static import. Make sure they are importing ``static`` methods or variables rather than class names.

**Apply autoboxing and unboxing**. The process of automatically converting from a primitive value to a wrapper class is called autoboxing, while the reciprocal process is called unboxing. Watch for a ``NullPointerException`` when performing unboxing.

**State the output of code involving methods**. Identify when to call ``static`` rather than instance methods based on whether the class name or object comes before the method. **==Recognize that instance methods can call ``static`` methods and that static methods need an instance of the object in order to call an instance method==**.

**Recognize the correct overloaded method**. Exact matches are used first, followed by wider primitives, followed by autoboxing, followed by varargs. Assigning new values to method parameters does not change the caller, but calling methods on them does.

## Review Questions

1. Which statements about the final modifier are correct? (Choose all that apply.)

A. Instance and static variables can be marked final.
B. A variable is effectively final only if it is marked final.
C. An object that is marked final cannot be modified.
D. Local variables cannot be declared with type var and the final modifier.
E. A primitive that is marked final cannot be modified.

**My Answer:  A,E**
**Correct Answer: A,E**

**A, E. Instance and static variables can be marked final, making option A correct. Effectively final means a local variable is not marked final but whose value does not change after it is set, making option B incorrect. Option C is incorrect, as final refers only to the reference to an object, not its contents. Option D is incorrect, as var and final can be used together. Finally, option E is correct: once a primitive is marked final, it cannot be modified.**

---

2. Which of the following can fill in the blank in this code to make it compile? (Choose all that apply.)

```JAVA
public class Ant {
	??? void method() {}
}
```

A. default
B. final
C. private
D. Public
E. String
F. zzz:

**My Answer:  B,C**
**Correct Answer: B,C**

**The keyword void is a return type. Only the access modifier or optional specifiers are allowed before the return type. Option C is correct, creating a method with private access. Option B is also correct, creating a method with package access and the optional specifier final. Since package access does not use a modifier, we get to jump right to final.**

---

3. Which of the following methods compile? (Choose all that apply.)

`A. final static void rain() {}`
`B. public final int void snow() {}`
`C. private void int hail() {}`
`D. static final void sleet() {}`
`E. void final ice() {}`
`F. void public slush() {}`

**My Answer:  A,D**
**Correct Answer: A,D**

**Options A and D are correct because the optional specifiers are allowed in any order. Options B and C are incorrect because they each have two return types. Options E and F are incorrect because the return type is before the optional specifier and access modifier, respectively.**

---

4. Which of the following can fill in the blank and allow the code to compile? (Choose all that apply.)
```java
final ??? song = 6;
```

A. int
B. Integer
C. long
D. Long
E. double
F. Double

**My Answer:  A,B,C,E**
**Correct Answer: A,B,C,E**

**The value 6 can be implicitly promoted to any of the primitive types, making options A, C, and E correct. It can also be autoboxed to Integer, making option B correct. ==It cannot be both promoted and autoboxed, making options D and F incorrect==.**

---

5. Which of the following methods compile? (Choose all that apply.)

`A. public void january() { return; }`
`B. public int february() { return null;}`
`C. public void march() {}`
`D. public int april() { return 9;}`
`E. public int may() { return 9.0;}`
`F. public int june() { return;}`

**My Answer:  A,C,D**
**Correct Answer: A,C,D**

**Options A and C are correct because a void method is optionally allowed to have a return statement as long as it doesn’t try to return a value. Option B does not compile because null requires a reference object as the return type. Since int is primitive, it is not a reference object. Option D is correct because it returns an int value. Option E does not compile because it tries to return a double when the return type is int. Since a double cannot be assigned to an int, it cannot be returned as one either. Option F does not compile because no value is actually returned.**

---

6. Which of the following methods compile? (Choose all that apply.)

`A. public void violin(int... nums) {}`
`B. public void viola(String values, int... nums) {}`
`C. public void cello(int... nums, String values) {}`
`D. public void bass(String... values, int... nums) {}`
`E. public void flute(String[] values, ...int nums) {}`
`F. public void oboe(String[] values, int[] nums) {}`

**My Answer:  A,B,F**
**Correct Answer: A,B,F**

**Options A and B are correct because the single varargs parameter is the last parameter declared. Option F is correct because it doesn’t use any varargs parameters. Option C is incorrect because the varargs parameter is not last. Option D is incorrect because two varargs parameters are not allowed in the same method. Option E is incorrect because the ``...`` for a varargs must be after the type, not before it.**

---

7. Given the following method, which of the method calls return 2? (Choose all that apply.)

```JAVA
public int juggle(boolean b, boolean... b2) {
	return b2.length;
}
```

`A. juggle();`
`B. juggle(true);`
`C. juggle(true, true);`
`D. juggle(true, true, true);`
`E. juggle(true, {true, true});`
`F. juggle(true, new boolean[2]);`

**My Answer:  D,F**
**Correct Answer: D,F**

Option D passes the initial parameter plus two more to turn into a varargs array of size 2. Option F passes the initial parameter plus an array of size 2. Option A does not compile because it does not pass the initial parameter. Option E does not compile because it does not declare an array properly. It should be ``new boolean[] {true, true}``. Option B creates a varargs array of size 0, and option C creates a varargs array of size 1.

---

8. Which of the following statements is correct?

A. Package access is more lenient than protected access.
B. A public class that has private fields and package methods is not visible to classes outside the package.
C. You can use access modifiers so only some of the classes in a package see a particular package class.
D. You can use access modifiers to allow access to all methods and not any instance variables.
E. You can use access modifiers to restrict access to all classes that begin with the word Test.

**My Answer:  D**
**Correct Answer: D**

**Option D is correct. A common practice is to set all fields to be private and all methods to be public. Option A is incorrect because protected access allows everything that package access allows and additionally allows subclasses access. Option B is incorrect because the class is public. This means that other classes can see the class. However, they cannot call any of the methods or read any of the fields. It is essentially a useless class. Option C is incorrect because package access applies to the whole package. Option E is incorrect because Java has no such wildcard access capability.**

---

9. Given the following class definitions, which lines in the main() method generate a compiler error? (Choose all that apply.)

```JAVA
// Classroom.java
package my.school;
public class Classroom {
private int roomNumber;
protected static String teacherName;
static int globalKey = 54321;
public static int floor = 3;
Classroom(int r, String t) {
roomNumber = r;
teacherName = t; } }

// School.java
1: package my.city;
2: import my.school.*;
3: public class School {
4: public static void main(String[] args) {
5: System.out.println(Classroom.globalKey);
6: Classroom room = new Classroom(101, "Mrs. Anderson");
7: System.out.println(room.roomNumber);
8: System.out.println(Classroom.floor);
9: System.out.println(Classroom.teacherName); } }
```

**My Answer:  C,D**
**Correct Answer: B,C,D,F**

**The two classes are in different packages, which means private access and package access will not compile. This causes compiler errors on lines 5, 6, and 7, making options B, C, and D correct answers. Additionally, protected access will not compile since School does not inherit from Classroom. This causes the compiler error on line 9, making option F a correct answer as well.**

---

10. What is the output of executing the Chimp program?

```JAVA
// Rope.java
1: package rope;
2: public class Rope {
3: public static int LENGTH = 5;
4: static {
5: LENGTH = 10;
6: }
7: public static void swing() {
8: System.out.print("swing ");
9: } }
// Chimp.java
1: import rope.*;
2: import static rope.Rope.*;
3: public class Chimp {
4: public static void main(String[] args) {
5: Rope.swing();
6: new Rope().swing();
7: System.out.println(LENGTH);
8: } }
```

A. swing swing 5
B. swing swing 10
C. Compiler error on line 2 of Chimp
D. Compiler error on line 5 of Chimp
E. Compiler error on line 6 of Chimp
F. Compiler error on line 7 of Chimp

**My Answer:  B**
**Correct Answer: B**

**Rope runs line 3, setting LENGTH to 5, and then immediately after that runs the static initializer, which sets it to 10. Line 5 in the Chimp class calls the static method normally and prints swing and a space. Line 6 also calls the static method. Java allows calling a static method through an instance variable, although it is not recommended. Line 7 uses the static import on line 2 to reference LENGTH.**

---

11. Which statements are true of the following code? (Choose all that apply.)

```JAVA
1: public class Rope {
2: public static void swing() {
3: System.out.print("swing");
4: }
5: public void climb() {
6: System.out.println("climb");
7: }
8: public static void play() {
9: swing();
10: climb();
11: }
12: public static void main(String[] args) {
13: Rope rope = new Rope();
14: rope.play();
15: Rope rope2 = null;
16: System.out.print("-");
17: rope2.play();
18: } }
```

A. The code compiles as is.
B. There is exactly one compiler error in the code.
C. There are exactly two compiler errors in the code.
D. If the line(s) with compiler errors are removed, the output is swing-climb.
E. If the line(s) with compiler errors are removed, the output is swing-swing.
F. If the line(s) with compile errors are removed, the code throws a NullPointerException.

**My Answer:  C,F**
**Correct Answer: B,E**

**Line 10 does not compile because static methods are not allowed to call instance methods. Even though we are calling play() as if it were an instance method and an instance exists, Java knows play() is really a static method and treats it as such. Since this is the only line that does not compile, option B is correct. If line 10 is removed, the code prints swing-swing, making ==option E correct. It does not throw a NullPointerException on line 17 because play() is a static method. Java looks at the type of the reference for rope2 and translates the call to Rope.play().==**

---

12. How many variables in the following method are effectively final?

```JAVA
10: public void feed() {
11: int monkey = 0;
12: if(monkey > 0) {
13: var giraffe = monkey++;
14: String name;
15: name = "geoffrey";
16: }
17: String name = "milly";
18: var food = 10;
19: while(monkey <= 10) {
20: food = 0;
21: }
22: name = null;
23: }
```

A. 1
B. 2
C. 3
D. 4
E. 5
F. None of the above. The code does not compile.

**My Answer:  B**
**Correct Answer: B**

**The test for effectively final is if the final modifier can be added to the local variable and the code still compiles.**

---

13. What is the output of the following code?

```JAVA
// RopeSwing.java
import rope.*;
import static rope.Rope.*;
public class RopeSwing {
private static Rope rope1 = new Rope();
private static Rope rope2 = new Rope();
{
System.out.println(rope1.length);
}
public static void main(String[] args) {
rope1.length = 2;
rope2.length = 8;
System.out.println(rope1.length);
}
}
// Rope.java
package rope;
public class Rope {
public static int length = 0;
}
```

A. 02
B. 08
C. 2
D. 8
E. The code does not compile.
F. An exception is thrown.

**My Answer:  E**
**Correct Answer: D**
 
 **There are two details to notice in this code. First, ==note that RopeSwing has an instance initializer and not a static initializer. Since RopeSwing is never constructed, the instance initializer does not run==. The other detail is that length is static. Changes from any object update this common static variable. The code prints 8, making option D correct.**

---

14. How many lines in the following code have compiler errors?

```JAVA
1: public class RopeSwing {
2: private static final String leftRope;
3: private static final String rightRope;
4: private static final String bench;
5: private static final String name = "name";
6: static {
7: leftRope = "left";
8: rightRope = "right";
9: }
10: static {
11: name = "name";
12: rightRope = "right";
13: }
14: public static void main(String[] args) {
15: bench = "bench";
16: }
17: }
```

A. 0
B. 1
C. 2
D. 3
E. 4
F. 5

**My Answer:  D**
**Correct Answer: E**

**If a variable is static final, it must be set exactly once, and it must be in the declaration line or in a static initialization block. Line 4 doesn’t compile because bench is not set in either of these locations. Line 15 doesn’t compile because final variables are not allowed to be set after that point. Line 11 doesn’t compile because name is set twice: once in the declaration and again in the static block. Line 12 doesn’t compile because rightRope is set twice as well. Both are in static initialization**

---

15. Which of the following can replace line 2 to make this code compile? (Choose all that apply.)

```JAVA
1: import java.util.*;
2: // INSERT CODE HERE
3: public class Imports {
4: public void method(ArrayList<String> list) {
5: sort(list);
6: }
7: }
```

`A. import static java.util.Collections;`
`B. import static java.util.Collections.*;`
`C. import static java.util.Collections.sort(ArrayList<String>);`
`D. static import java.util.Collections;`
`E. static import java.util.Collections.*;`
`F. static import java.util.Collections.sort(ArrayList<String>);``

**My Answer:  B**
**Correct Answer: B**

**The two valid ways to do this are import static ``java.util.Collections.``*; and import static ``java.util.Collections.sort``;. Option A is incorrect because you can do a static import only on static members. Classes such as Collections require a regular import. Option C is nonsense as method parameters have no business in an import. Options D, E, and F try to trick you into reversing the syntax of import static.**

---

16. What is the result of the following statements?
```java
1: public class Test {
2: public void print(byte x) {
3: System.out.print("byte-");
4: }
5: public void print(int x) {
6: System.out.print("int-");
7: }
8: public void print(float x) {
9: System.out.print("float-");
10: }
11: public void print(Object x) {
12: System.out.print("Object-");
13: }
14: public static void main(String[] args) {
15: Test t = new Test();
16: short s = 123;
17: t.print(s);
18: t.print(true);
19: t.print(6.789);
20: }
21: }
```

A. byte-float-Object-
B. int-float-Object-
C. byte-Object-float-
D. int-Object-float-
E. int-Object-Object-
F. byte-Object-Object-

**My Answer: E**
**Correct Answer: E**

**The argument on line 17 is a short. It can be promoted to an int, so print() on line 5 is invoked. The argument on line 18 is a boolean. It can be autoboxed to a Boolean, so print() on line 11 is invoked. The argument on line 19 is a double. It can be autoboxed to a Double, so print() on line 11 is invoked. Therefore, the output is int-Object-Object-** 

---

17. What is the result of the following program?

```JAVA
1: public class Squares {
2: public static long square(int x) {
3: var y = x * (long) x;
4: x = -1;
5: return y;
6: }
7: public static void main(String[] args) {
8: var value = 9;
9: var result = square(value);
10: System.out.println(value);
11: } }
```

A. -1
B. 9
C. 81
D. Compiler error on line 9
E. Compiler error on a different line

**My Answer: B**
**Correct Answer: B**

**Since Java is pass-by- value and the variable on line 8 never gets reassigned, it stays as 9.**

---

18. Which of the following are output by the following code? (Choose all that apply.)

```JAVA
public class StringBuilders {
public static StringBuilder work(StringBuilder a,
StringBuilder b) {
a = new StringBuilder("a");
b.append("b");
return a;
}
public static void main(String[] args) {
var s1 = new StringBuilder("s1");
var s2 = new StringBuilder("s2");
var s3 = work(s1, s2);
System.out.println("s1 = " + s1);
System.out.println("s2 = " + s2);
System.out.println("s3 = " + s3);
}
}
```

A. s1 = a
B. s1 = s1
C. s2 = s2
D. s2 = s2b
E. s3 = a
F. The code does not compile.

**My Answer: A,D,E**
**Correct Answer: B,D,E**

**Since Java is pass-by-value, assigning a new object to a does not change the caller. Calling append() does affect the caller because both the method parameter and the caller have a reference to the same object. Finally, returning a value does pass the reference to the caller for assignment to s3.**

---

19. Which of the following will compile when independently inserted in the following code? (Choose all that apply.)

```java
1: public class Order3 {
2: final String value1 = "red";
3: static String value2 = "blue";
4: String value3 = "yellow";
5: {
6: // CODE SNIPPET 1
7: }
8: static {
9: // CODE SNIPPET 2
10: } }
```

A. Insert at line 6: value1 = "green";
B. Insert at line 6: value2 = "purple";
C. Insert at line 6: value3 = "orange";
D. Insert at line 9: value1 = "magenta";
E. Insert at line 9: value2 = "cyan";
F. Insert at line 9: value3 = "turquoise";

**My Answer: B,C,E**
**Correct Answer: B,C,E**

**The variable value1 is a final instance variable. It can be set only once: in the variable declaration, an instance initializer, or a constructor. Option A does not compile because the final variable was already set in the declaration. The variable value2 is a static variable. Both instance and static initializers are able to access static variables, making options B and E correct. The variable value3 is an instance variable. Options D and F do not compile because a static initializer does not have access to instance variables.**

---

 20. Which of the following are true about the following code? (Choose all that apply.)

```JAVA
public class Run {
static void execute() {
System.out.print("1-");
}
static void execute(int num) {
System.out.print("2-");
}
static void execute(Integer num) {
System.out.print("3-");
}
static void execute(Object num) {
System.out.print("4-");
}
static void execute(int... nums) {
System.out.print("5-");
}
public static void main(String[] args) {
Run.execute(100);
Run.execute(100L);
}
}
```

A. The code prints out 2-4-.
B. The code prints out 3-4-.
C. The code prints out 4-2-.
D. The code prints out 4-4-.
E. The code prints 3-4- if you remove the method static void execute(int num).
F. The code prints 4-4- if you remove the method static void execute(int num).

**My Answer: A,E**
**Correct Answer: A,E**

**The 100 parameter is an int and so calls the matching int method, making option A correct. When this method is removed, Java looks for the next most specific constructor. Java prefers autoboxing to varargs, so it chooses the Integer constructor. The 100L parameter is a long. Since it can’t be converted into a smaller type, it is autoboxed into a Long, and then the method for Object is called,**

---

21. Which method signatures are valid overloads of the following method signature? (Choose all that apply.)

```JAVA
public void moo(int m, int... n)
```

A. public void moo(int a, int... b)
B. public int moo(char ch)
C. public void moooo(int... z)
D. private void moo(int... x)
E. public void moooo(int y)
F. public void moo(int... c, int d)
G. public void moo(int... i, int j...)

**My Answer: B,D**
**Correct Answer: B,D**

**Option A is incorrect because it has the same parameter list of types and therefore the same signature as the original method. Options B and D are valid method overloads because the types of parameters in the list change. When overloading methods, the return type and access modifiers do not need to be the same. Options C and E are incorrect because the method name is different. Options F and G do not compile. There can be at most one varargs parameter, and it must be the last element in the parameter list.**

---

# Chapter 6 - Class Design #Chapter

At its core, proper Java class design is about code reusability, increased functionality, and standardization
## Understanding Inheritance

When creating a new class in Java, you can define the class as inheriting from an existing class. Inheritance is the process by which a subclass automatically includes certain members of the class, including primitives, objects, or methods, defined in the parent class.

### Declaring a Subclass

![[Pasted image 20240322192526.png]]

indicate a class is a subclass by declaring it with the ``extends`` keyword. We don’t need to declare anything in the superclass other than making sure it is not marked ``final``.

One key aspect of inheritance is that it is transitive. Given three classes ``[X, Y, Z]``, if ``X`` extends ``Y``, and ``Y`` extends ``Z``, then ``X`` is considered a subclass or descendant of ``Z``. Likewise, ``Z`` is a superclass or ancestor of ``X``. We sometimes use the term direct subclass or descendant to indicate the class directly extends the parent class. For example, ``X`` is a direct descendant only of class ``Y``, not ``Z``.

**==When one class inherits from a parent class, all ``public`` and ``protected`` members are automatically available as part of the child class. If the two classes are in the same package, then package members are available to the child class. Last but not least, ``private`` members are restricted to the class they are defined in and are never available via inheritance.==**

```java
public class BigCat {
	protected double size;
}
public class Jaguar extends BigCat {
	public Jaguar() {
		size = 10.2;
	}
	public void printDetails() {
		System.out.print(size);
	}
}

public class Spider {
	public void printDetails() {
		System.out.println(size); // DOES NOT COMPILE
	}
}
```

``Jaguar`` is a subclass or child of ``BigCat``, making ``BigCat`` a superclass or parent of ``Jaguar``. In the ``Jaguar`` class, size is accessible because it is marked ``protected``. Via inheritance, the ``Jaguar`` subclass can read or write size as if it were its own member. Contrast this with the ``Spider`` class, which has no access to size since it is not inherited
### Class Modifiers

| Modifier   | Description                                                          |
| ---------- | -------------------------------------------------------------------- |
| final      | The class may not be extended.                                       |
| abstract   | The class is abstract, may contain abstract methods, and requires a  |
|            | concrete subclass to instantiate.                                    |
| sealed     | The class may only be extended by a specific list of classes.        |
| non-sealed | A subclass of a sealed class permits potentially unnamed subclasses. |
| static     | Used for static nested classes defined within a class.               |
**==The ``final`` modifier prevents a class from being extended any further.==**

```java
public final class Rhinoceros extends Mammal { }
public class Clara extends Rhinoceros { } // DOES NOT COMPILE
```

### Single vs. Multiple Inheritance

Java supports single inheritance, by which a class may inherit from only one direct parent class. Java also supports **==multiple levels of inheritance==**, by which one class may extend another class, which in turn extends another class. You can have any number of levels of inheritance, allowing each descendant to gain access to its ancestor’s members.

By design, Java doesn’t support multiple inheritance in the language because multiple inheritance can lead to complex, often difficult-to-maintain data models. Java does allow one exception to the single inheritance rule, which a class may implement multiple interfaces.

![[Pasted image 20240322193445.png]]

Part of what makes multiple inheritance complicated is determining which parent to inherit values from in case of a conflict. For example, if you have an object or method defined in all of the parents, which one does the child inherit? There is no natural ordering for parents in this example, which is why Java avoids these issues by disallowing multiple inheritance altogether.
### Inheriting Object

In Java, all classes inherit from a single class: ``java.lang.Object``, or ``Object`` for short. Furthermore, Object is the only class that doesn’t have a parent class. The following two are equivalent:

```java
public class Zoo { }
public class Zoo extends java.lang.Object { }
```

**==The key is that when Java sees you define a class that doesn’t extend another class, the compiler automatically adds the syntax extends ``java.lang.Object`` to the class definition.==** The result is that every class gains access to any accessible methods in the Object class. For example, the ``toString()`` and ``equals()`` methods are available in Object; therefore, they are accessible in all classes. Without being overridden in a subclass, though, they may not be particularly useful.

On the other hand, when you define a new class that extends an existing class, Java does not automatically extend the Object class. Since all classes inherit from Object, extending an existing class means the child already inherits from Object by definition.

						![[Pasted image 20240322194238.png]]


Primitive types such as ``int`` and ``boolean`` do not inherit from Object, since they are not classes. Through autoboxing they can be assigned or passed as an instance of an associated wrapper class, which does inherit ``Object``.

## Creating Classes

### Extending a Class

```java
// Animal.java
public class Animal {
	private int age;
	protected String name;
	public int getAge() {
		return age;
	}
	public void setAge(int newAge) {
		age = newAge;
	}
}
// Lion.java
public class Lion extends Animal {
	protected void setProperties(int age, String n) {
		setAge(age);
		name = n;
	}
	public void roar() {
		System.out.print(name + ", age " + getAge() + ", says: Roar!");
	}
	public static void main(String[] args) {
		var lion = new Lion();
		lion.setProperties(3, "kion");
		lion.roar(); // kion, age 3, says: Roar!
	}
}
```

- The ``age`` variable exists in the parent ``Animal`` class and is not directly accessible in the ``Lion`` child class. It is indirectly accessible via the ``setAge()`` method.
- The ``name`` variable is ``protected``, so it is inherited in the ``Lion`` class and directly accessible.
- create the ``Lion`` instance in the ``main()`` method and use ``setProperties()`` to set instance variables.
- Finally, call the ``roar()`` method,

The instance variable ``age`` is marked ``private`` and is not directly accessible from the subclass ``Lion``. Therefore, the following would not compile:

```java
public class Lion extends Animal {
	public void roar() {
		System.out.print("Lions age: " + age); // DOES NOT COMPILE
	}
}
```

**==Remember when working with subclasses that ``private`` members are never inherited, and package members are only inherited if the two classes are in the same package.==**
### Applying Class Access Modifiers

Like variables and methods, you can apply access modifiers to classes. **==A top-level class is one not defined inside**== ==**another class. Also a .java file can have at most one top-level class.==** While you can only have one top-level
class, you can have as many classes (in any order) with package access as you want

```java
// Bear.java
class Bird {}
class Bear {}
class Fish {}
```

Trying to declare a top-level class with ``protected`` or ``private`` class will lead to a compiler error,

```java
// ClownFish.java
protected class ClownFish{} // DOES NOT COMPILE
// BlueTang.java
private class BlueTang {} // DOES NOT COMPILE
```

### Accessing the ``this`` Reference

What happens when a method parameter has the same name as an existing instance variable ?

```java
public class Flamingo {
	private String color = null;
	public void setColor(String color) {
		color = color;
	}
	public static void main(String... unused) {
		var f = new Flamingo();
		f.setColor("PINK");
		System.out.print(f.color); // null
	}
}
```

Java uses the most granular scope, so when it sees ``color = color``, it thinks you are assigning the method parameter value to itself (not the instance variable). The assignment completes successfully within the method, but the value of the instance variable ``color`` is never modified and is ``null`` when printed in the ``main()`` method.

The fix **==when you have a local variable with the same name as an instance variable is to use the ``this`` reference or keyword. The this reference refers to the current instance of the class==** and can be used to access any member of the class, including inherited members. It can be used in any instance method, constructor, or instance initializer block. **==It cannot be used when there is no implicit instance of the class, such as in a static method or static initializer block.==**

```java
public void setColor(String color) {
	this.color = color; // Sets the instance variable with method parameter
}
```

In many cases, the ``this`` reference is optional. If Java encounters a variable or method it cannot find, it will check the class hierarchy to see if it is available.

```java
1: public class Duck {
	2: private String color;
	3: private int height;
	4: private int length;
5:
	6: public void setData(int length, int theHeight) {
		7: length = this.length; // Backwards --no good!
		8: height = theHeight; // Fine, because a different name
		9: this.color = "white"; // Fine, but this. reference not necessary
	10: }
11:
	12: public static void main(String[] args) {
		13: Duck b = new Duck();
		14: b.setData(1,2);
		15: System.out.print(b.length + " " + b.height + " " + b.color); // 0 2 white
	16: } }
```

- Line 7 is incorrect, and you should watch for it on the exam. The instance variable ``length`` starts out with a 0 value. That 0 is assigned to the method parameter ``length``. The instance variable stays at 0.
-  Line 8 is more straightforward. The parameter ``theHeight`` and instance variable ``height`` have different names. **==Since there is no naming collision, this is not required.==**
- line 9 shows that a variable assignment is allowed to use the this reference even when there is no duplication of variable names.
### Calling the ``super`` Reference

In Java, a variable or method can be defined in both a parent class and a child class. This means the object instance actually holds two copies of the same variable with the same underlying name. When this happens, how do we reference the version in the parent class instead of the current class?

```java
// Reptile.java
1: public class Reptile {
	2: protected int speed = 10;
3: }

// Crocodile.java
1: public class Crocodile extends Reptile {
	2: protected int speed = 20;
	3: public int getSpeed() {
		4: return speed;
	5: }
	
	6: public static void main(String[] data) {
		7: var croc = new Crocodile();
		8: System.out.println(croc.getSpeed()); // 20
	9: } 
}
```

**==One of the most important things to remember about this code is that an instance of ``Crocodile`` stores two separate values for ``speed``: one at the ``Reptile`` level and one at the ``Crocodile`` level==**. On line 4, Java first checks to see if there is a local variable or method parameter named ``speed``. Since there is not, it then checks ``this.speed;`` and since it exists, the program prints 20.

Within the ``Crocodile`` class, we can access the parent value of ``speed``, instead, by using the ``super`` reference or keyword. **==The ``super`` reference is similar to the this reference, except that it excludes any members found in the current class. In other words, the member must be accessible via inheritance.==**

```java
3: public int getSpeed() {
	4: return super.speed; // Causes the program to now print 10
5: }
```

```java
1: class Insect {
	2: protected int numberOfLegs = 4;
	3: String label = "buggy";
4: }
5:
6: public class Beetle extends Insect {
	7: protected int numberOfLegs = 6;
	8: short age = 3;
	9: public void printData() {
		10: System.out.println(this.label);
		11: System.out.println(super.label);
		12: System.out.println(this.age);
		13: System.out.println(super.age);
		14: System.out.println(numberOfLegs);
	15: }
	16: public static void main(String []n) {
		17: new Beetle().printData();
	18: }
19: }
```

this program code would not compile!

- Since ``label`` is defined in the parent class, it is accessible via both ``this`` and ``super`` references. For this reason, lines 10 and 11 compile and would both print buggy if the class compiled.
- the variable ``age`` is defined only in the current class, making it accessible via ``this`` but not ``super``. For this reason, line 12 compiles (and would print 3), but line 13 does not. **==while ``this`` includes current and inherited members, ``super`` only includes inherited members.==**
- Even though both ``numberOfLegs`` variables are accessible in ``Beetle``, **==Java checks outward, starting with the narrowest scope.==** For this reason, the value of ``numberOfLegs`` in the ``Beetle`` class is used, and 6 is printed.


**==Since ``this`` includes inherited members, you often only use ``super`` when you have a naming conflict via inheritance.==** For example, you have a method or variable defined in the current class that matches a method or variable in a parent class. This commonly comes up in method overriding and variable hiding
## Declaring Constructors

a constructor is a special method that matches the name of the class and has no return type. It is called when a new instance of the class is created.
### Creating a Constructor

```java
public class Bunny {
	public Bunny() {
		System.out.print("hop");
	}
}
```

The name of the constructor, ``Bunny``, matches the name of the class, ``Bunny``, and there is no return type, not even ``void``. That makes this a constructor.

```java
public class Bunny {
	public bunny() {} // DOES NOT COMPILE
	public void Bunny() {}
}
```

The first one doesn’t match the class name because Java is case-sensitive. Since it doesn’t match, Java knows it can’t be a constructor and is supposed to be a regular method. However, it is missing the return type and doesn’t compile. The second method is a perfectly good method but is not a constructor because it has a return type. **==Like method parameters, constructor parameters can be any valid class, array, or primitive type, including generics, but may not include ``var``==**. For example, the following does not compile:

```java
public class Bonobo {
	public Bonobo(var food) { // DOES NOT COMPILE
	}
}
```

**==A class can have multiple constructors, as long as each constructor has a unique constructor signature==**. In this case, that means ==**the constructor parameters must be distinct**==. Like methods with the same name but different signatures, declaring multiple constructors with different signatures is referred to as constructor overloading.

```java
public class Turtle {
	private String name;
	public Turtle() {
		name = "John Doe";
	}
	public Turtle(int age) {}
	public Turtle(long age) {}
	public Turtle(String newName, String... favoriteFoods) {
		name = newName;
	}
}
```

Constructors are used when creating a new object. This process is called instantiation because it creates a new instance of the class. A constructor is called when we write new followed by the name of the class we want to instantiate.

```java
new Turtle(15)
```

When Java sees the new keyword, it allocates memory for the new object. It then looks for a constructor with a matching signature and calls it.

### The Default Constructor

Every class in Java has a constructor, whether you code one or not. If you don’t include any constructors in the class, Java will create one for you without any parameters. This Java-created constructor is called the default constructor and is added any time a class is declared without any constructors.

```java
public class Rabbit {
	public static void main(String[] args) {
		new Rabbit(); // Calls the default constructor
	}
}
```

The previous class is equivalent to the following, in which the default constructor is provided and therefore not inserted by the compiler:

```java
public class Rabbit {
	public Rabbit() {}
	public static void main(String[] args) {
		new Rabbit(); // Calls the user-defined constructor
	}
}
```

This happens during the compile step. **==For the exam, one of the most important rules you need to know is that the compiler only inserts the default constructor when no constructors are defined.==**

```java
public class Rabbit1 {} // Valid No Args Ctor

public class Rabbit2 {
	public Rabbit2() {}
}
public class Rabbit3 {
	public Rabbit3(boolean b) {}
}
public class Rabbit4 {
	private Rabbit4() {}
}
```

```java
1: public class RabbitsMultiply {
	2: public static void main(String[] args) {
		3: var r1 = new Rabbit1();
		4: var r2 = new Rabbit2();
		5: var r3 = new Rabbit3(true);
		6: var r4 = new Rabbit4(); // DOES NOT COMPILE
	7: } }
```

Line 6 does not compile. ``Rabbit4`` made the constructor ``private`` so that other classes could not call it.

---

**Having only private constructors in a class tells the compiler not to provide a default no-argument constructor. It also prevents other classes from instantiating the class**

---
###  Calling Overloaded Constructors with ``this()``

Since a class can contain multiple overloaded constructors, these constructors can actually call one another.

```java
public class Hamster {
	private String color;
	private int weight;
	public Hamster(int weight, String color) { // First constructor
		this.weight = weight;
		this.color = color;
	}
	public Hamster(int weight) { // Second constructor
		this.weight = weight;
		color = "brown";
	}
}
```

One of the constructors takes a single ``int`` parameter. The other takes an ``int`` and a ``String``. These parameter lists are different, so the constructors are successfully overloaded. There is a bit of duplication, as ``this.weight`` is assigned the same way in both constructors. What we really want is for the first constructor to call the second constructor with two parameters.

```java
public Hamster(int weight) { // Second constructor
	Hamster(weight, "brown"); // DOES NOT COMPILE
}
```

This will not work. Constructors can be called only by writing new before the name of the constructor. They are not like normal methods that you can just call

```java
public Hamster(int weight) { // Second constructor
	new Hamster(weight, "brown"); // Compiles, but creates an extra object
}
```

This attempt does compile. When this constructor is called, it creates a new object with the default ``weight`` and ``color``. It then constructs a different object with the desired ``weight`` and ``color``.

Java provides a solution: ``this()`` When ``this()`` is used with parentheses, Java calls another constructor on the same instance of the class.

```java
public Hamster(int weight) { // Second constructor
	this(weight, "brown");
}
```

Now Java calls the constructor that takes two parameters, with ``weight`` and ``color`` set as expected.

---
**``this`` vs. ``this()``** #TIP 

**Despite using the same keyword, ``this`` and ``this()`` are very different. ==The first, this, refers to an instance of the class, while the second, this(), refers to a constructor call within the class==.**

---

**==Calling ``this()`` has one special rule you need to know. If you choose to call it, the`` this()`` call must be the first statement in the constructor. The side effect of this is that there can be only one call to ``this()`` in any constructor.==**

```java
3: public Hamster(int weight) {
4: System.out.println("chew");
5: // Set weight and default color
6: this(weight, "brown"); // DOES NOT COMPILE
7: }
```

There’s one last rule for overloaded constructors

```java
public class Gopher {
	public Gopher(int dugHoles) {
		this(5); // DOES NOT COMPILE
	}
}
```

**==The compiler is capable of detecting that this constructor is calling itself infinitely. This is often referred to as a cycle and is similar to the infinite loops Since the code can never terminate, the compiler stops and reports this as an error.==**

```java
public class Gopher {
	public Gopher() {
		this(5); // DOES NOT COMPILE
	}
	public Gopher(int dugHoles) {
		this(); // DOES NOT COMPILE
	}
}
```

the constructors call each other, and the process continues infinitely. Since the compiler can detect this, it reports an error.

- ==**A class can contain many overloaded constructors, provided the signature for each is distinct.**==
- ==**The compiler inserts a default no-argument constructor if no constructors are declared.**==
- ==**If a constructor calls ``this()``, then it must be the first line of the constructor.**==
- ==**Java does not allow cyclic constructor calls.==**

### Calling Parent Constructors with ``super()``

**==The first statement of every constructor is a call to a parent constructor using ``super()`` or another constructor in the class using ``this()``.==**

```java
public class Animal {
	private int age;
	public Animal(int age) {
		super(); // Refers to constructor in java.lang.Object
		this.age = age;
	}
}
	public class Zebra extends Animal {
		public Zebra(int age) {
		super(age); // Refers to constructor in Animal
	}
	public Zebra() {
		this(4); // Refers to constructor in Zebra with int argument
	}
}
```

---
**``super`` vs. ``super()``** #TIP

**Like ``this`` and ``this()``, ``super`` and ``super()`` are unrelated in Java. ==The first, ``super``, is used to reference members of the parent class, while the second, ``super()``, calls a parent constructor.**==

---
**==Like calling ``this()``, calling ``super()`` can only be used as the first statement of the constructor.==**

```java
public class Zoo {
	public Zoo() {
		System.out.println("Zoo created");
		super(); // DOES NOT COMPILE
	}
}
public class Zoo {
	public Zoo() {
		super();
		System.out.println("Zoo created");
		super(); // DOES NOT COMPILE
	}
}
```

If the parent class has more than one constructor, the child class may use any valid parent constructor in its definition

```java
public class Animal {
	private int age;
	private String name;
	public Animal(int age, String name) {
		super();
		this.age = age;
		this.name = name;
	}
	public Animal(int age) {
		super();
		this.age = age;
		this.name = null;
	}
}
public class Gorilla extends Animal {
	public Gorilla(int age) {
		super(age,"Gorilla"); // Calls the first Animal constructor
	}
	public Gorilla() {
		super(5); // Calls the second Animal constructor
	}
}
```

notice that the child constructors are not required to call matching parent constructors. Any valid parent constructor is acceptable as long as the appropriate input parameters to the parent constructor are provided.

### Understanding Compiler Enhancements

the Java compiler automatically inserts a call to the no-argument constructor ``super()`` if you do not explicitly call ``this()`` or ``super()`` as the first line of a constructor.

```java
public class Donkey {}

public class Donkey {
	public Donkey() {}
}

public class Donkey {
	public Donkey() {
		super();
	}
}
```

### Default Constructor Tips and Tricks

What happens if we define a subclass with no constructors, or a subclass with a constructor that doesn’t include a ``super()`` reference?

```java
public class Mammal {
	public Mammal(int age) {}
}
public class Seal extends Mammal {} // DOES NOT COMPILE
public class Elephant extends Mammal {
	public Elephant() {} // DOES NOT COMPILE
}
```

The answer is that neither subclass compiles. Since ``Mammal`` defines a constructor, the compiler does not insert a no-argument constructor. The compiler will insert a default no-argument constructor into ``Seal``, though, but it will be a simple implementation that just calls a nonexistent parent default constructor.

```java
public class Seal extends Mammal {
	public Seal() {
		super(); // DOES NOT COMPILE
	}
}
```

Likewise, ``Elephant`` will not compile for similar reasons. The compiler doesn’t see a call to ``super()`` or ``this()`` as the first line of the constructor so it inserts a call to a nonexistent no-argument ``super()`` automatically.

```java
public class Elephant extends Mammal {
	public Elephant() {
		super(); // DOES NOT COMPILE
	}
}
```

the compiler will not help, and you must create at least one constructor in your child class that explicitly calls a parent constructor via the ``super()`` command.

```java
public class Seal extends Mammal {
	public Seal() {
		super(6); // Explicit call to parent constructor
	}
}
public class Elephant extends Mammal {
	public Elephant() {
		super(4); // Explicit call to parent constructor
	}
}
```

Subclasses may include no-argument constructors even if their parent classes do not

---
**``super()`` Always Refers to the Most Direct Parent**
**A class may have multiple ancestors via inheritance. For constructors, though, ``super()`` always refers to the most direct parent.**

---

- ==**The first line of every constructor is a call to a parent constructor using ``super()`` or an overloaded constructor using ``this()``.**==
- ==**If the constructor does not contain a ``this()`` or ``super()`` reference, then the compiler automatically inserts super() with no arguments as the first line of the constructor.**==
- ==**If a constructor calls ``super()``, then it must be the first line of the constructor.==**

## Initializing Objects

Order of initialization refers to how members of a class are assigned values. They can be given default values, like 0 for an ``int``, or require explicit values, such as for ``final`` variables.
### Initializing Classes

First, we initialize the class, which involves invoking all ``static`` members in the class hierarchy, starting with the highest superclass and working downward. This is sometimes referred to as loading the class. The Java Virtual Machine (JVM) controls when the class is initialized, although you can assume the class is loaded before it is used. The class may be initialized when the program first starts, when a ``static`` member of the class is referenced, or shortly before an instance of the class is created.

**==One of the most important rules with class initialization is that it happens at most once for each class.==**

**Initialize Class X**

1. ==**If there is a superclass ``Y`` of ``X``, then initialize class ``Y`` first.**==
2. ==**Process all ``static`` variable declarations in the order in which they appear in the class.**==
3. ==**Process all ``static`` initializers in the order in which they appear in the class.==**

```java
public class Animal {
	static { System.out.print("A"); }
}
public class Hippo extends Animal {
	public static void main(String[] grass) {
		System.out.print("C");
		new Hippo();
		new Hippo();
		new Hippo();
	}
	static { System.out.print("B"); }
}
```

It prints ``ABC`` exactly once. Since the ``main()`` method is inside the ``Hippo`` class, the class will be initialized first, starting with the superclass and printing AB. Afterward, the ``main()`` method is executed, printing C. Even though the ``main()`` method creates three instances, the class is loaded only once.

### Initializing ``final`` Fields

**==A default value is only applied to a non-final field==**

``final static`` variables must be explicitly assigned a value exactly once. Fields marked ``final`` follow similar rules. They can be assigned values in the line in which they are declared or in an instance initializer.

```java
public class MouseHouse {
	private final int volume;
	private final String name = "The Mouse House"; // Declaration assignment
	{
		volume = 10; // Instance initializer assignment
	}
}
```
 
 Unlike ``static`` class members, though, ``final`` instance fields can also be set in a constructor. The constructor is part of the initialization process, so it is allowed to assign ``final`` instance variables. **==one important rule: by the time the constructor completes, all ``final`` instance variables must be assigned a value exactly once.==**

```java
public class MouseHouse {
	private final int volume;
	private final String name;
	public MouseHouse() {
		this.name = "Empty House"; // Constructor assignment
	}
	{
		volume = 10; // Instance initializer assignment
	}
}
```

Unlike local ``final`` variables, which are not required to have a value unless they are actually used, ``final`` instance variables must be assigned a value. If they are not assigned a value when they are declared or in an instance initializer, then they must be assigned a value in the constructor declaration. Failure to do so will result in a compiler error

```java
public class MouseHouse {
	private final int volume;
	private final String type;
	{
		this.volume = 10;
	}
	public MouseHouse(String type) {
		this.type = type;
	}
	public MouseHouse() { // DOES NOT COMPILE
		this.volume = 2; // DOES NOT COMPILE
	}
}
```

**==In terms of assigning values, each constructor is reviewed individually==**, which is why the second constructor does not compile. First, the constructor fails to set a value for the type variable. The compiler detects that a value is never set for type and reports an error on the line where the constructor is declared. Second, the constructor sets a value for the volume variable, even though it was already assigned a value by the instance initializer.

---

**On the exam, be wary of any instance variables marked ``final``. Make sure they are assigned a value in the line where they are declared, in an instance initializer, or in a constructor. They should be assigned a value only once, and failure to assign a value is considered a compiler error in the constructor.**

---

What about ``final`` instance variables when a constructor calls another constructor in the same class? In that case, you have to follow the flow carefully, making sure every ``final`` instance variable is assigned a value exactly once.

```java
public MouseHouse() {
	this(null);
}
```

can assign a ``null`` value to ``final`` instance variables as long as they are explicitly set.

### Initializing Instances

First, start at the lowest-level constructor where the ``new`` keyword is used. Remember, the first line of every constructor is a call to ``this()`` or ``super()``, and if omitted, the compiler will automatically insert a call to the parent no-argument constructor ``super()``. Then, progress upward and note the order of constructors. Finally, initialize each class starting with the superclass, processing each instance initializer and constructor in the reverse order in which it was called.

**Initialize Instance of X**

1. ==**Initialize class ``X`` if it has not been previously initialized.**==
2. ==**If there is a superclass ``Y`` of ``X``, then initialize the instance of ``Y`` first.**==
3. ==**Process all instance variable declarations in the order in which they appear in the class.**==
4. ==**Process all instance initializers in the order in which they appear in the class.**==
5. ==**Initialize the constructor, including any overloaded constructors referenced with ``this()``==**

```java
1: public class ZooTickets {
2: private String name = "BestZoo";
3: { System.out.print(name + "-");}
4: private static int COUNT = 0;
5: static { System.out.print(COUNT + "-");}
6: static { COUNT += 10; System.out.print(COUNT + "-");}
7:
8: public ZooTickets() {
	9: System.out.print("z-");
10: }
11:
12: public static void main(String... patrons) {
	13: new ZooTickets();
	// 0-10-BestZoo-z-
14: } }
```

- First, have to initialize the class. Since there is no superclass declared, which means the superclass is ``Object`` we can start with the ``static`` components of ``ZooTickets`` In this case, lines 4, 5, and 6 are executed, printing 0-and 10-
- Next, we initialize the instance created on line 13. Again, since no superclass is declared, we start with the instance components. Lines 2 and 3 are executed, which prints BestZoo- 
- Finally, we run the constructor on lines 8–10, which outputs z-.

```java
class Primate {
    public Primate() {
        System.out.print("Primate-");
    }
}

class Ape extends Primate {
    public Ape(int fur) {
        System.out.print("Ape1-");
    }

    public Ape() {
        System.out.print("Ape2-");
    }
}

public class Chimpanzee extends Ape {
    public Chimpanzee() {
        super(2);
        System.out.print("Chimpanzee-");
    }

    public static void main(String[] args) {
        new Chimpanzee(); // Primate-Ape1-Chimpanzee-
    }
}
```

The compiler inserts the ``super()`` command as the first statement of both the ``Primate`` and ``Ape`` constructors. The code will execute with the parent constructors called first

Notice that only one of the two ``Ape()`` constructors is called. You need to start with the call to ``new Chimpanzee()`` to determine which constructors will be executed. Remember, constructors are executed from the bottom up, but since the first line of every constructor is a call to another constructor, **==the flow ends up with the parent constructor executed before the child constructor.==**

```java
1: public class Cuttlefish {
	2: private String name = "swimmy";
	3: { System.out.println(name); }
	4: private static int COUNT = 0;
	5: static { System.out.println(COUNT); }
	6: { COUNT++; System.out.println(COUNT); }
	7:
	8: public Cuttlefish() {
		9: System.out.println("Constructor");
	10: }
	11:
	12: public static void main(String[] args) {
			13: System.out.println("Ready");
			14: new Cuttlefish();
15: } }
```

```text
0
Ready
swimmy
1
Constructor
```

- No superclass is declared, so we can skip any steps that relate to inheritance.
- first process the ``static`` variables and ``static`` initializers—lines 4 and 5, with line 5 printing 0.
- the ``main()`` method can run, which prints Ready.
- create an instance declared on line 14
- Lines 2, 3, and 6 are processed, with line 3 printing swimmy and line 6 printing 1.
- Finally, the constructor is run on lines 8–10, which prints Constructor.

```java
1: class GiraffeFamily {
	2: static { System.out.print("A"); }
	3: { System.out.print("B"); }
	4:
	5: public GiraffeFamily(String name) {
		6: this(1);
		7: System.out.print("C");
	8: }
	9:
	10: public GiraffeFamily() {
		11: System.out.print("D");
	12: }
	13:
	14: public GiraffeFamily(int stripes) {
		15: System.out.print("E");
	16: }
17: }
18: public class Okapi extends GiraffeFamily {
	19: static { System.out.print("F"); }
	20:
	21: public Okapi(int stripes) {
		22: super("sugar");
		23: System.out.print("G");
	24: }
	25: { System.out.print("H"); }
	26:
	27: public static void main(String[] grass) {
		28: new Okapi(1);
		29: System.out.println();
		30: new Okapi(2);
	31: }
32: }
```

```text
AFBECHG
BECHG
```

- Start with initializing the ``Okapi`` class. Since it has a superclass ``GiraffeFamily``, initialize it first, printing A on line 2.
- Next, initialize the ``Okapi`` class, printing F on line 19.
- After the classes are initialized, execute the ``main()`` method on line 27. The first line of the ``main()`` method creates a new ``Okapi`` object, triggering the instance initialization process. Per the first rule, the superclass instance of ``GiraffeFamily`` is initialized first. Per our third rule, the instance initializer in the superclass ``GiraffeFamily`` is called, and B is printed on line 3.
- Per the fourth rule, we initialize the constructors. In this case, this involves calling the constructor on line 5, which in turn calls the overloaded constructor on line 14. The result is that EC is printed, as the constructor bodies are unwound in the reverse order that they were called.
- The process then continues with the initialization of the ``Okapi`` instance itself. Per the third and fourth rules, H is printed on line 25, and G is printed on line 23, respectively
- Line 29 then inserts a line break in the output.
- Finally, line 30 initializes a new ``Okapi`` object. The order and initialization are the same as line 28, sans the class initialization, so BECHG is printed again. Notice that D is never printed, as only two of the three constructors in the superclass ``GiraffeFamily`` are called.

This example is tricky for a few reasons. There are multiple overloaded constructors, lots of initializers, and a complex constructor pathway to keep track of. Luckily, questions like this are uncommon on the exam. If you see one, just write down what is going on as you read the code.

- ==**A class is initialized at most once by the JVM before it is referenced or used.**==
- ==**All ``static final`` variables must be assigned a value exactly once, either when they are declared or in a ``static`` initializer.**==
- ==**All ``final`` fields must be assigned a value exactly once, either when they are declared, in an instance initializer, or in a constructor.**==
- ==**Non-final static and instance variables defined without a value are assigned a default value based on their type.**==
- ==**Order of initialization is as follows: variable declarations, then initializers, and finally constructors.==**
## Inheriting Members

Inheriting a class not only grants access to inherited methods in the parent class but also sets the stage for collisions between methods defined in both the parent class and the subclass
### Overriding a Method

In Java, overriding a method occurs when a subclass declares a new implementation for an inherited method with the same signature and compatible return type.

When you override a method, you may still reference the parent version of the method using the ``super`` keyword. In this manner, the keywords ``this`` and ``super`` allow you to select between the current and parent versions of a method, respectively

```java
public class Marsupial {
	public double getAverageWeight() {
		return 50;
	}
}
public class Kangaroo extends Marsupial {
	public double getAverageWeight() {
	return super.getAverageWeight()+20;
}
public static void main(String[] args) {
	System.out.println(new Marsupial().getAverageWeight()); // 50.0
	System.out.println(new Kangaroo().getAverageWeight()); // 70.0
	}
}
```

the ``Kangaroo`` class overrides the ``getAverageWeight()`` method but in the process calls the parent version using the ``super`` reference.

---

**Method Overriding Infinite Calls**

```java
public double getAverageWeight() {
	return getAverageWeight()+20; // StackOverflowError
}
```

In this example, the compiler would not call the parent ``Marsupial`` method; it would call the current ``Kangaroo`` method. The application will attempt to call itself infinitely and produce a ``StackOverflowError`` at runtime.

---

To override a method, you must follow a number of rules. The compiler performs the following checks when you override a method:

1. ==**The method in the child class must have the same signature as the method in the parent class.**==
2. ==**The method in the child class must be at least as accessible as the method in the parent class.**==
3. ==**The method in the child class may not declare a checked exception that is new or broader than the class of any exception declared in the parent class method.**==
4. ==**If the method returns a value, it must be the same or a subtype of the method in the parent class, known as covariant return types.==**
#### Rule #1: Method Signatures

If two methods have the same name but different signatures, the methods are overloaded, not overridden. Overloaded methods are considered independent and do not share the same polymorphic properties as overridden methods.
#### Rule #2: Access Modifiers

```java
public class Camel {
	public int getNumberOfHumps() {
	return 1;
	} }
	public class BactrianCamel extends Camel {
	private int getNumberOfHumps() { // DOES NOT COMPILE
	return 2;
} }
```

**==Java avoids these types of ambiguity problems by limiting overriding a method to access modifiers that are as accessible or more accessible than the version in the inherited method.==**
#### Rule #3: Checked Exceptions

Overriding a method cannot declare new checked exceptions or checked exceptions broader than the inherited method. In other words, you could end up with an object that is more restrictive than the reference type it is assigned to, resulting in a checked exception that is not handled or declared.

```java
public class Reptile {
	protected void sleep() throws IOException {}
	protected void hide() {}
	protected void exitShell() throws FileNotFoundException {}
}
public class GalapagosTortoise extends Reptile {
	public void sleep() throws FileNotFoundException {}
	public void hide() throws FileNotFoundException {} // DOES NOT COMPILE
	public void exitShell() throws IOException {} // DOES NOT COMPILE
}
```

These overridden methods use the more accessible ``public`` modifier, which is allowed per our second rule for overridden methods. 

The overridden`` hide()`` method does not compile because it declares a new checked exception not present in the parent declaration. The overridden ``exitShell()`` also does not compile, since ``IOException`` is a broader checked exception than ``FileNotFoundException``
#### Rule #4: Covariant Return Types

```java
public class Rhino {
	protected CharSequence getName() {
		return "rhino";
	}
	protected String getColor() {
		return "grey, black, or white";
	} 
}
public class JavanRhino extends Rhino {
	public String getName() {
		return "javan rhino";
	}
	public CharSequence getColor() { // DOES NOT COMPILE
		return "grey";
	} 
}
```

- ``String`` implements the ``CharSequence`` interface, making ``String`` a subtype of ``CharSequence``. Therefore, the return type of ``getName()`` in ``JavanRhino`` is covariant with the return type of ``getName()`` in ``Rhino``.
- the overridden ``getColor()`` method does not compile because ``CharSequence`` is not a subtype of ``String``. To put it another way, all ``String`` values are ``CharSequence`` values, but not all ``CharSequence`` values are ``String`` values. For instance, a ``StringBuilder`` is a ``CharSequence`` but not a ``String``.

---

**==A simple test for covariance is the following: given an inherited return type A and an overriding return type B, can you assign an instance of B to a reference variable for A without a cast? If so, then they are covariant. This rule applies to primitive types and object types alike. If one of the return types is ``void``, then they both must be ``void``, as nothing is covariant with void except itself==**

---
### Redeclaring ``private`` Methods

**==In Java, you can’t override ``private`` methods since they are not inherited.==** Just because a child class doesn’t have access to the parent method doesn’t mean the child class can’t define its own version of the method. It just means, strictly speaking, that the new method is not an overridden version of the parent class’s method.

Java permits you to redeclare a new method in the child class with the same or modified signature as the method in the parent class. This method in the child class is a separate and independent method, unrelated to the parent version’s method, so none of the rules for overriding methods is invoked.

```java
public class Beetle {
private String getSize() {
return "Undefined";
} }

public class RhinocerosBeetle extends Beetle {
private int getSize() {
return 5;
} }
```

What if ``getSize()`` method was declared ``public`` in ``Beetle``? In this case, the method in ``RhinocerosBeetle`` would be an invalid override. The access modifier in ``RhinocerosBeetle`` is more restrictive, and the return types are not covariant.

### Hiding Static Methods

**==A ``static`` method cannot be overridden because class objects do not inherit from each other in the same way as instance objects. On the other hand, they can be hidden. A hidden method occurs when a child class defines a static method with the same name and signature as an inherited ``static`` method defined in a parent class==**. Method hiding is similar to but not exactly the same as method overriding. The previous four rules for overriding a method must be followed when a method is hidden. In addition, a new fifth rule is added for hiding a method:

5. **==The method defined in the child class must be marked as ``static`` if it is marked as ``static`` in a parent class.==**

Put simply, it is method hiding if the two methods are marked ``static`` and method overriding if they are not marked ``static``. If one is marked ``static`` and the other is not, the class will not compile.

```java
public class Bear {
public static void eat() {
System.out.println("Bear is eating");
} }
public class Panda extends Bear {
public static void eat() {
System.out.println("Panda is chewing");
}
public static void main(String[] args) {
eat();
} }
```

- The ``eat()`` method in the ``Panda`` class hides the ``eat()`` method in the ``Bear`` class, printing "Panda is chewing" at runtime. Because they are both marked as ``static``, this is not considered an overridden method. If you remove the ``eat()`` declaration in the ``Panda`` class, then the program prints "Bear is eating" instead.

```java
public class Bear {
    public static void sneeze() {
        System.out.println("Bear is sneezing");
    }

    public void hibernate() {
        System.out.println("Bear is hibernating");
    }

    public static void laugh() {
        System.out.println("Bear is laughing");
    }
}

public class SunBear extends Bear {
    public void sneeze() { // DOES NOT COMPILE
        System.out.println("Sun Bear sneezes quietly");
    }

    public static void hibernate() { // DOES NOT COMPILE
        System.out.println("Sun Bear is going to sleep");
    }

    protected static void laugh() { // DOES NOT COMPILE
        System.out.println("Sun Bear is laughing");
    }
}
```

- ``sneeze()`` is marked ``static`` in the parent class but not in the child class. The compiler detects that you’re trying to override using an instance method. However, ``sneeze()`` is a ``static`` method that should be hidden, causing the compiler to generate an error
- The second method, ``hibernate()``, does not compile for the opposite reason. The method is marked ``static`` in the child class but not in the parent class.
- Finally, the ``laugh()`` method does not compile. Even though both versions of the method are marked ``static``, the version in ``SunBear`` has a more restrictive access modifier than the one it inherits, and it breaks the second rule for overriding methods

### Hiding Variables

Java doesn’t allow variables to be overridden. Variables can be hidden, though. **==A hidden variable occurs when a child class defines a variable with the same name as an inherited variable defined in the parent class==**
As when hiding a ``static`` method, you can’t override a variable; you can only hide it.

```java
class Carnivore {
	protected boolean hasFur = false;
}
public class Meerkat extends Carnivore {
	protected boolean hasFur = true;
	public static void main(String[] args) {
		Meerkat m = new Meerkat();
		Carnivore c = m;
		System.out.println(m.hasFur); // true
		System.out.println(c.hasFur); // false
	}
}
```

Both of these classes define a ``hasFur`` variable, but with different values. Even though only one object is created by the ``main()`` method, both variables exist independently of each other. The output changes depending on the reference variable used.

### Writing ``final`` Methods

**==final methods cannot be overridden. By marking a method ``final``, you forbid a child class from replacing this method==**. This rule is in place both when you override a method and when you hide a method.

```java
public class Bird {
	public final boolean hasFeathers() {
		return true;
	}
	public final static void flyAway() {}
}
public class Penguin extends Bird {
	public final boolean hasFeathers() { // DOES NOT COMPILE
		return false;
	}
	public final static void flyAway() {} // DOES NOT COMPILE
}
```

This rule applies only to inherited methods. For example, if the two methods were marked ``private`` in the parent ``Bird`` class, then the ``Penguin`` class, as defined, would compile.
## Creating Abstract Classes

### Introducing Abstract Classes

**==An abstract class is a class declared with the ``abstract`` modifier that cannot be instantiated directly and may contain abstract methods.==**

```java
public abstract class Canine {}
public class Wolf extends Canine {}
public class Fox extends Canine {}
public class Coyote extends Canine {}
```

An abstract class can contain abstract methods. An abstract method is a method declared with the ``abstract`` modifier that does not define a body. Put another way, an abstract method forces subclasses to override the method. By declaring a method abstract, we can guarantee that some version will be available on an instance without having to specify what that version is in the abstract parent class.

```java
public abstract class Canine {
public abstract String getSound();
public void bark() { System.out.println(getSound()); }
}
public class Wolf extends Canine {
public String getSound() {
return "Wooooooof!";
} }
public class Fox extends Canine {
public String getSound() {
return "Squeak!";
} }
public class Coyote extends Canine {
public String getSound() {
return "Roar!";
} }
```

```java
public static void main(String[] p) {
	Canine w = new Fox();
	w.bark(); // Squeak!
}
```

there are some rules you need to be aware of:

-  ==**Only instance methods can be marked ``abstract`` within a class, not variables, constructors, or ``static`` methods.**==
-  ==**An abstract method can only be declared in an abstract class.**==
-  ==**A non-abstract class that extends an abstract class must implement all inherited abstract methods.**==
-  ==**Overriding an abstract method follows the existing rules for overriding methods==**

```java
public class FennecFox extends Canine {
	public int getSound() {
	return 10;
} }
public class ArcticFox extends Canine {}
public class Direwolf extends Canine {
	public abstract rest();
	public String getSound() {
	return "Roof!";
} }

public class Jackal extends Canine {
	public abstract String name;
	public String getSound() {
	return "Laugh";
} }
```

- the ``FennecFox`` class does not compile because it is an invalid method override. The return types are not covariant
- The ``ArcticFox`` class does not compile because it does not override the abstract ``getSound()`` method.
- The ``Direwolf`` class does not compile because it is not abstract but declares an abstract method ``rest()``.
- the ``Jackal`` class does not compile because variables cannot be marked abstract.

```java
abstract class Alligator {
	public static void main(String... food) {
		var a = new Alligator(); // DOES NOT COMPILE
	}
}
```

An abstract class can be initialized, but only as part of the instantiation of a non-abstract subclass.

### Declaring Abstract Methods

**==An abstract method is always declared without a body. It also includes a semicolon (;) after the method declaration.==** An abstract class can include all of the same members as a non-abstract class, including variables, ``static`` and instance methods, constructors, etc. n abstract class is not required to include any abstract methods.

```java
public abstract class Llama {
	public void chew() {}
}
```

**==For the exam, keep an eye out for abstract methods declared outside abstract classes==**

```java
public class Egret { // DOES NOT COMPILE
	public abstract void peck();
}
```

Like the ``final`` modifier, the ``abstract`` modifier can be placed before or after the access modifier in class and method declarations

```java
abstract public class Tiger {
	abstract public int claw();
}
```

The ``abstract`` modifier cannot be placed after the class keyword in a class declaration or after the return type in a method declaration

```java
public class abstract Bear { // DOES NOT COMPILE
	public int abstract howl(); // DOES NOT COMPILE
}
```

### Creating a Concrete Class

A concrete class is a non-abstract class. **==The first concrete subclass that extends an abstract class is required to implement all inherited abstract methods==**. When you see a concrete class extending an abstract class on the exam, check to make sure that it implements all of the required abstract methods.

```java
public abstract class Animal {
	public abstract String getName();
}
public class Walrus extends Animal {} // DOES NOT COMPILE
```

An abstract class can extend a non-abstract class and vice versa. Anytime a concrete class is extending an abstract class, it must implement all of the methods that are inherited as abstract.

```java
public abstract class Mammal {
	abstract void showHorn();
	abstract void eatLeaf();
}
public abstract class Rhino extends Mammal {
	void showHorn() {} // Inherited from Mammal Because no abstract keyword start of the method
}
public class BlackRhino extends Rhino {
	void eatLeaf() {} // Inherited from Mammal
}
```

- the ``BlackRhino`` class is the first concrete subclass, while the ``Mammal`` and ``Rhino`` classes are abstract.
- The ``BlackRhino`` class inherits the`` eatLeaf()`` method as abstract and is therefore required to provide an implementation, which it does.
- ``showHorn()`` method. Since the parent class, ``Rhino``, provides an implementation of ``showHorn()``, the method is inherited in the ``BlackRhino`` as a non-abstract method. For this reason, the ``BlackRhino`` class is permitted but not required to override the ``showHorn()`` method.

```java
public class Rhino extends Mammal { // DOES NOT COMPILE
	void showHorn() {}
}
```

By changing ``Rhino`` to a concrete class, it becomes the first non-abstract class to extend the abstract ``Mammal`` class. Therefore, it must provide an implementation of both the ``showHorn()`` and ``eatLeaf()`` methods. Since it only provides one of these methods, the modified Rhino declaration does not compile.

```java
public abstract class Animal {
	abstract String getName();
}
public abstract class BigCat extends Animal {
	protected abstract void roar();
}

public class Lion extends BigCat {
	public String getName() {
		return "Lion";
	}
	public void roar() {
		System.out.println("The Lion lets out a loud ROAR!");
	}
}
```

- ``BigCat`` extends ``Animal`` but is marked as abstract; therefore, it is not required to provide an implementation for the ``getName()`` method
- The class ``Lion`` is not marked as ``abstract``, and as the first concrete subclass, it must implement all of the inherited abstract methods not defined in a parent class
###  Creating Constructors in Abstract Classes

Even though abstract classes cannot be instantiated, they are still initialized through constructors by their subclasses.

```java
abstract class Mammal {
	abstract CharSequence chew();
	public Mammal() {
		System.out.println(chew()); // Does this line compile?
	}
}
```

```java
public class Platypus extends Mammal {
	String chew() { return "yummy!"; }
	public static void main(String[] args) {
		new Platypus();
	}
}
```

For the exam, remember that abstract classes are initialized with constructors in the same way as non-abstract classes. For example, if an abstract class does not provide a constructor, the compiler will automatically insert a default no-argument constructor.

**==The primary difference between a constructor in an abstract class and a non-abstract class is that a constructor in an abstract class can be called only when it is being initialized by a non-abstract subclass==**

### Spotting Invalid Declarations

```java
public abstract class Turtle {
	public abstract long eat() // DOES NOT COMPILE
	public abstract void swim() {}; // DOES NOT COMPILE
	public abstract int getAge() { // DOES NOT COMPILE
	return 10;
	}
	public abstract void sleep; // DOES NOT COMPILE
	public void goInShell(); // DOES NOT COMPILE
}
```

- The first method, ``eat()``, does not compile because it is marked abstract but does not end with a semicolon (;).
- The next two methods, ``swim()`` and ``getAge()``, do not compile because they are marked abstract, but they provide an implementation block enclosed in braces ``({})``.
- The next method, ``sleep``, does not compile because it is missing parentheses, (), for method arguments.
- The last method, ``goInShell()``, does not compile because it is not marked ``abstract`` and therefore must provide a body enclosed in braces.

#### ``abstract`` and ``final`` Modifiers

If you mark something ``abstract``, you intend for someone else to extend or implement it. But if you mark something ``final``, you are preventing anyone from extending or implementing it. These concepts are in direct conflict with each other. Due to this incompatibility, **==Java does not permit a class or method to be marked both**==
==**``abstract`` and ``final``==**

```java
public abstract final class Tortoise { // DOES NOT COMPILE
	public abstract final void walk(); // DOES NOT COMPILE
}
```

#### ``abstract`` and ``private`` Modifiers

**==A method cannot be marked as both ``abstract`` and ``private``.==** the compiler will complain

```java
public abstract class Whale {
	private abstract void sing(); // DOES NOT COMPILE
}
public class HumpbackWhale extends Whale {
	private void sing() {
		System.out.println("Humpback whale is singing");
	} 
}
```

---

**While it is not possible to declare a method ``abstract`` and ``private``, ==it is possible (albeit redundant) to declare a method ``final`` and ``private``.**==

---

```java
public abstract class Whale {
	protected abstract void sing();
}
public class HumpbackWhale extends Whale {
	private void sing() { // DOES NOT COMPILE
		System.out.println("Humpback whale is singing");
	}
}
```

the code will still not compile, but for a completely different reason. the subclass cannot reduce the visibility of the parent method, ``sing()``.
#### ``abstract`` and ``static`` Modifiers

a ``static`` method can only be hidden, not overridden. It is defined as belonging to the class, not an instance of the class. **==If a ``static`` method cannot be overridden, then it follows that it also cannot be marked ``abstract`` since it can never be implemented.==**

```java
abstract class Hippopotamus {
	abstract static void swim(); // DOES NOT COMPILE
}
```

## Creating Immutable Objects

The immutable objects pattern is an object-oriented design pattern in which an object cannot be modified after it is created. Immutable objects are helpful when writing secure code because you don’t have to worry about the values changing. They also simplify code when dealing with concurrency since immutable objects can be easily shared between multiple threads.
### Declaring an Immutable Class

1. ==**Mark the class as ``final`` or make all of the constructors ``private``.**==
2. ==**Mark all the instance variables ``private`` and ``final``.**==
3. ==**Don’t define any setter methods.**==
4. ==**Don’t allow referenced mutable objects to be modified.==**

```java
import java.util.*;
public final class Animal { // Not an immutable object declaration
private final ArrayList<String> favoriteFoods;
public Animal() {
this.favoriteFoods = new ArrayList<String>();
this.favoriteFoods.add("Apples");
}
public List<String> getFavoriteFoods() {
return favoriteFoods;
} }
```

```java
var zebra = new Animal();
System.out.println(zebra.getFavoriteFoods()); // [Apples]
zebra.getFavoriteFoods().clear();
zebra.getFavoriteFoods().add("Chocolate Chip Cookies");
System.out.println(zebra.getFavoriteFoods()); // [Chocolate Chip Cookies]
```

```java
import java.util.*;
public final class Animal { // An immutable object declaration
private final List<String> favoriteFoods;
public Animal() {
this.favoriteFoods = new ArrayList<String>();
this.favoriteFoods.add("Apples");
}
public int getFavoriteFoodsCount() {
return favoriteFoods.size();
}
public String getFavoriteFoodsItem(int index) {
return favoriteFoods.get(index);
} }
```

---
**Copy on Read Accessor Methods**

**Besides delegating access to any ``private`` mutable objects, another approach is to make a copy of the mutable object any time it is requested.**

```java
public ArrayList<String> getFavoriteFoods() {
	return new ArrayList<String>(this.favoriteFoods);
}
```

**Of course, changes in the copy won’t be reflected in the original, but at least the original is**
**protected from external changes.**

---
### Performing a Defensive Copy

```java
import java.util.*;
public final class Animal { // Not an immutable object declaration
private final ArrayList<String> favoriteFoods;
public Animal(ArrayList<String> favoriteFoods) {
if (favoriteFoods == null || favoriteFoods.size() == 0)
throw new RuntimeException("favoriteFoods is required");
this.favoriteFoods = favoriteFoods;
}
public int getFavoriteFoodsCount() {
return favoriteFoods.size();
}
public String getFavoriteFoodsItem(int index) {
return favoriteFoods.get(index);
} }
```

```java
var favorites = new ArrayList<String>();
favorites.add("Apples");
var zebra = new Animal(favorites); // Caller still has access to favorites
System.out.println(zebra.getFavoriteFoodsItem(0)); // [Apples]
favorites.clear();
favorites.add("Chocolate Chip Cookies");
System.out.println(zebra.getFavoriteFoodsItem(0)); // [Chocolate Chip Cookies]
```

The solution is to make a copy of the list object containing the same elements.

```java
public Animal(List<String> favoriteFoods) {
	if (favoriteFoods == null || favoriteFoods.size() == 0)
	throw new RuntimeException("favoriteFoods is required");
	this.favoriteFoods = new ArrayList<String>(favoriteFoods);
}
```

The copy operation is called a defensive copy because the copy is being made in case other code does something unexpected. It’s the same idea as defensive driving: prevent a problem before it exists.

## Summary #OCP_Summary 

**==Java classes follow a single-inheritance pattern in which every class has exactly one direct parent class, with all classes eventually inheriting from ``java.lang.Object``. Inheriting a class gives you access to all of the ``public`` and ``protected`` members of the class. It also gives you access to package members of the class if the classes are in the same package. All instance methods, constructors, and instance initializers have access to two special reference variables: ``this`` and ``super``. Both ``this`` and ``super`` provide access to all inherited members, with only this providing access to all members in the current class declaration**==

==**Constructors are special methods that use the class name and do not have a return type. They are used to instantiate new objects. Declaring constructors requires following a number of important rules. If no constructor is provided, the compiler will automatically insert a default no-argument constructor in the class. The first line of every constructor is a call to an overloaded constructor, ``this()``, or a parent constructor, ``super()``; otherwise, the compiler will insert a call to super() as the first line of the constructor. In some cases, such as if the parent class does not define a no-argument constructor, this can lead to compilation errors. Pay close attention on the exam to any class that defines a constructor with arguments and doesn’t define a no-argument constructor.**==

==**Classes are initialized in a predetermined order: superclass initialization; ``static`` variables and ``static`` initializers in the order that they appear; instance variables and instance initializers in the order they appear; and finally, the constructor. All final instance variables must be assigned a value exactly once.**==

==**A method is overloaded if it has the same name but a different signature as another accessible method. A method is overridden if it has the same signature as an inherited method, with access modifiers, exceptions, and a return type that are compatible. A static method is hidden if it has the same signature as an inherited ``static`` method. Finally, a method is redeclared if it has the same name and possibly the same signature as an uninherited method.**==

==**abstract classes, which are just like regular classes except that they cannot be instantiated and may contain abstract methods. An abstract class can extend a non-abstract class and vice versa. Abstract classes can be used to define a framework that other developers write subclasses against. An abstract method is one that does not include a body when it is declared. An abstract method can only be placed inside an abstract class or interface. Next, an abstract method can be overridden with another abstract declaration or a concrete implementation, provided the rules for overriding methods are followed. The first concrete class must implement all of the inherited abstract methods, whether they are inherited from an abstract class or an interface.**==

==**immutable objects in Java. Although there are a number of different techniques to do so, we included the most common one you should know for the exam. Immutable objects are extremely useful in practice, especially in multi-threaded applications, since they do not change.==**

## Exam Essentials #Essential 

 **Be able to write code that extends other classes**. A Java class that extends another class inherits all of its ``public`` and ``protected`` methods and variables. If the class is in the same package, it also inherits all package members of the class. **==Classes that are marked final ``cannot`` be extended==**. Finally, all classes in Java extend ``java.lang.Object`` either directly or from a superclass.

**Be able to distinguish and use ``this``, ``this()``, ``super``, and ``super()``**. To access a current or inherited member of a class, the ``this`` reference can be used. To access an inherited member, the ``super`` reference can be used. The ``super`` reference is often used to reduce ambiguity, such as when a class reuses the name of an inherited method or variable. The calls to ``this()`` and ``super()`` are used to access constructors in the same class and parent class, respectively.


**Evaluate code involving constructors**. The first line of every constructor is a call to another constructor within the class using ``this()`` or a call to a constructor of the parent class using the ``super()`` call. The compiler will insert a call to ``super()`` if no constructor call is declared. If the parent class doesn’t contain a no-argument constructor, an explicit call to the parent constructor must be provided. Be able to recognize when the default constructor is provided. Remember that the order of initialization is to initialize all classes in the class hierarchy, starting with the superclass. Then the instances are initialized, again starting with the superclass. All final variables must be assigned a value exactly once by the time the constructor is finished.

**Understand the rules for method overriding**. Java allows methods to be overridden, or replaced, by a subclass if certain rules are followed: **==a method must have the same signature, be at least as accessible as the parent method, must not declare any new or broader exceptions, and must use covariant return types==**. **==Methods marked ``final`` may not be overridden or hidden.==**

**Recognize the difference between method overriding and method overloading.** Both method overloading and overriding involve creating a new method with the same name as an existing method. When the method signature is the same, it is referred to as method overriding and must follow a specific set of override rules to compile. When the method signature is different, with the method taking different inputs, it is referred to as method overloading, and none of the override rules are required. Method overriding is important to polymorphism because it replaces all calls to the method, even those made in a superclass.

**Understand the rules for hiding methods and variables**. When a ``static`` method is overridden in a subclass, it is referred to as method hiding. Likewise, variable hiding is when an inherited variable name is reused in a subclass. In both situations, the original method or variable still exists and is accessible depending on where it is accessed and the reference type used. For method hiding, the use of ``static`` in the method declaration must be the same between the parent and child class. Finally, variable and method hiding should generally be avoided since it leads to confusing and difficult-to- follow code.

**Be able to write code that creates and extends abstract classes**. In Java, classes and methods can be declared as ``abstract``. An ``abstract`` class cannot be instantiated. An instance of an ``abstract`` class can be obtained only through a concrete subclass. Abstract classes can include any number of ``abstract`` and non-abstract methods, including zero. Abstract methods follow all the method override rules and may be defined only within ``abstract`` classes. **==The first concrete subclass of an abstract class must implement all the inherited methods. Abstract classes and methods may not be marked as ``final``==**.

**Create immutable objects.** An immutable object is one that cannot be modified after it is declared. An immutable class is commonly implemented with a private constructor, no setter methods, and no ability to modify mutable objects contained within the class.

## Review Questions

1. Which code can be inserted to have the code print 2?

```java
public class BirdSeed {
private int numberBags;
boolean call;
public BirdSeed() {
// LINE 1
call = false;
// LINE 2
}
public BirdSeed(int numberBags) {
this.numberBags = numberBags;
}
public static void main(String[] args) {
var seed = new BirdSeed();
System.out.print(seed.numberBags);
} }
```

A. Replace line 1 with BirdSeed(2);.
B. Replace line 2 with BirdSeed(2);.
C. Replace line 1 with new BirdSeed(2);.
D. Replace line 2 with new BirdSeed(2);.
E. Replace line 1 with this(2);.
F. Replace line 2 with this(2);.
G. The code prints 2 without any changes.

**My Answer: E**
**Correct Answer: E**

**A and B will not compile because constructors cannot be called without new. Options C and D will compile but will create a new object rather than setting the fields in this one. The result is the program will print 0, not 2, at runtime. Calling an overloaded constructor, using this(), or a parent constructor, using super(), is only allowed on the first line of the constructor, making option E correct and option F incorrect.**

---

2. Which modifier pairs can be used together in a method declaration? (Choose all that apply.)
A. static and final
B. private and static
C. static and abstract
D. private and abstract
E. abstract and final
F. private and final

**My Answer: A,F**
**Correct Answer: A,B,F**

**The final modifier can be used with private and static, making options A and F correct. Marking a private method final is redundant but allowed. A private method may also be marked static, making option B correct.**

---

3. Which of the following statements about methods are true? (Choose all that apply.)

A. Overloaded methods must have the same signature.
B. Overridden methods must have the same signature.
C. Hidden methods must have the same signature.
D. Overloaded methods must have the same return type.
E. Overridden methods must have the same return type.
F. Hidden methods must have the same return type.

**My Answer: B,C**
**Correct Answer: B,C**

**Overloaded methods have the same method name but a different signature (the method parameters differ), making option A incorrect. Overridden instance methods and hidden static methods must have the same signature (the name and method parameters must match), making options B and C correct. ==Overloaded methods can have different return types, while overridden and hidden methods can have covariant return types==.**

---

4. What is the output of the following program?

```java
1: class Mammal {
2: private void sneeze() {}
3: public Mammal(int age) {
4: System.out.print("Mammal");
5: } }
6: public class Platypus extends Mammal {
7: int sneeze() { return 1; }
8: public Platypus() {
9: System.out.print("Platypus");
10: }
11: public static void main(String[] args) {
12: new Mammal(5);
13: } }
```

A. Platypus
B. Mammal
C. PlatypusMammal
D. MammalPlatypus
E. The code will compile if line 7 is changed.
F. The code will compile if line 9 is changed.

**My Answer: B**
**Correct Answer: F**

**The code will not compile as is, because the parent class Mammal does not define a no-argument constructor. For this reason, the first line of a Platypus constructor should be an explicit call to super(int), making option F the correct answer**

---

5. Which of the following complete the constructor so that this code prints out 50? (Choose all that apply.)

```java
class Speedster {
	int numSpots;
}
public class Cheetah extends Speedster {
	int numSpots;
	public Cheetah(int numSpots) {
	// INSERT CODE HERE
}

	public static void main(String[] args) {
		Speedster s = new Cheetah(50);
		System.out.print(s.numSpots);
	}
}
```

A. numSpots = numSpots;
B. numSpots = this.numSpots;
C. this.numSpots = numSpots;
D. numSpots = super.numSpots;
E. super.numSpots = numSpots;
F. The code does not compile regardless of the code inserted into the constructor.
G. None of the above

**My Answer: C,E**
**Correct Answer: E**

**An instance variable with the same name as an inherited instance variable is hidden, not overridden. This means that both variables exist, and the one that is used depends on the location and reference type. Because the main() method uses a reference type of Speedster to access the numSpots variable, the variable in the Speedster class, not the Cheetah class, must be set to 50. Option E is the only correct answer, as it assigns the instance variable numSpots in the Speedster class a value of 50. The numSpots variable in the Speedster class is then correctly referenced in the main() method, printing 50 at runtime.**

---

6. Which of the following declare immutable classes? (Choose all that apply.)

```java
public final class Moose {
	private final int antlers;
}
public class Caribou {
	private int antlers = 10;
}
public class Reindeer {
	private final int antlers = 5;
}
public final class Elk {}
	public final class Deer {
	private final Object o = new Object();
}
```

A. Moose
B. Caribou
C. Reindeer
D. Elk
E. Deer
F. None of the above

**My Answer: A,D**
**Correct Answer: D,E**

**The Moose class doesn’t compile, as the final variable antlers is not initialized  when it is declared, in an instance initializer, or in a constructor. Caribou and Reindeer are not immutable because they are not marked final, which means a subclass could extend them and add mutable fields. Elk and Deer are both immutable classes since they are marked final and only include private final members, making options D and E correct.**

---

7. What is the output of the following code?

```java
1: class Arthropod {
2: protected void printName(long input) {
3: System.out.print("Arthropod");
4: }
5: void printName(int input) {
6: System.out.print("Spooky");
7: } }
8: public class Spider extends Arthropod {
9: protected void printName(int input) {
10: System.out.print("Spider");
11: }
12: public static void main(String[] args) {
13: Arthropod a = new Spider();
14: a.printName((short)4);
15: a.printName(4);
16: a.printName(5L);
17: } }
```

A. SpiderSpiderArthropod
B. SpiderSpiderSpider
C. SpiderSpookyArthropod
D. SpookySpiderArthropod
E. The code will not compile because of line 5.
F. The code will not compile because of line 9.
G. None of the above

**My Answer: A**
**Correct Answer: A**

**The code compiles and runs without issue, so options E and F are incorrect. The Arthropod class defines two overloaded versions of the printName() method. The printName() method that takes an int value on line 5 is correctly overridden in theSpider class on line 9. Remember, an overridden method can have a broader access modifier, and protected access is broader than package access. Because of polymorphism, the overridden method replaces the method on all calls, even if an Arthropod reference variable is used, as is done in the main() method. For these reasons, the overridden method is called on lines 14 and 15, printing Spider twice. Note that the short value is automatically cast to the larger type of int, which then uses the overridden method. Line 16 calls the overloaded method in the Arthropod class, as the long value 5L does not match the overridden method, resulting in Arthropod being printed. Therefore, option A is the correct answer.**

---

8. What is the result of the following code?

```java
1: abstract class Bird {
2: private final void fly() { System.out.println("Bird"); }
3: protected Bird() { System.out.print("Wow-");}
4: }
5: public class Pelican extends Bird {
6: public Pelican() { System.out.print("Oh-");}
7: protected void fly() { System.out.println("Pelican"); }
8: public static void main(String[] args) {
9: var chirp = new Pelican();
10: chirp.fly();
11: } }
```

A. Oh-Bird
B. Oh-Pelican
C. Wow-Oh-Bird
D. Wow-Oh-Pelican
E. The code contains a compilation error.
F. None of the above

**My Answer: D**
**Correct Answer: D**

**The question is making sure you know that superclass constructors are called in the same manner in abstract classes as they are in non-abstract classes. Line 9 calls the constructor on line 6. The compiler automatically inserts super() as the first line of the constructor defined on line 6. The program then calls the constructor on line 3 and prints Wow-.Control then returns to line 6, and Oh-is printed. Finally, the method call on line 10 uses the version of fly() in the Pelican class, since it is marked private and the reference type of var is resolved as Pelican. The final output is Wow-Oh- Pelican, making option D the correct answer**

---
9. Which of the following statements about overridden methods are true? (Choose all that apply.)

A. An overridden method must contain method parameters that are the same or covariant with the method parameters in the inherited method.
B. An overridden method may declare a new exception, provided it is not checked.
C. An overridden method must be more accessible than the method in the parent class.
D. An overridden method may declare a broader checked exception than the method in the parent class.
E. If an inherited method returns void, then the overridden version of the method must return void.
F. None of the above

**My Answer: B,E**
**Correct Answer: C,E**

**An overridden method must not declare any new checked exceptions or a checked exception that is broader than the inherited method. For this reason, option B is correct Option C is incorrect because an overridden method may have the same access modifier as the version in the parent class. Finally, overridden methods must have covariant return types, and only void is covariant with void, making option E correct.**

---
10. Which of the following pairs, when inserted into the blanks, allow the code to compile? (Choose all that apply.)

```java
1: public class Howler {
2: public Howler(long shadow) {
3: ???;
4: }
5: private Howler(int moon) {
6: super();
7: }
8: }
9: class Wolf extends Howler {
10: protected Wolf(String stars) {
11: super(2L);
12: }
13: public Wolf() {
14: ???;
15: }
16: }
```

A. this(3) at line 3, this("") at line 14
B. this() at line 3, super(1) at line 14
C. this((short)1) at line 3, this(null) at line 14
D. super() at line 3, super() at line 14
E. this(2L) at line 3, super((short)2) at line 14
F. this(5) at line 3, super(null) at line 14
G. Remove lines 3 and 14.

**My Answer: A,C**
**Correct Answer: A,C**

**Option A is correct, as this(3) calls the constructor declared on line 5, while this("") calls the constructor declared on line 10. Option B does not compile, as inserting this() at line 3 results in a compiler error, since there is no matching constructor. Option C is correct, as short can be implicitly cast to int, resulting in this((short)1) calling the constructor declared on line 5. In addition, this(null) calls the String constructor declared on line 10.** 

---

11. What is the result of the following?

```java
1: public class PolarBear {
2: StringBuilder value = new StringBuilder("t");
3: { value.append("a"); }
4: { value.append("c"); }
5: private PolarBear() {
6: value.append("b");
7: }
8: public PolarBear(String s) {
9: this();
10: value.append(s);
11: }
12: public PolarBear(CharSequence p) {
13: value.append(p);
14: }
15: public static void main(String[] args) {
16: Object bear = new PolarBear();
17: bear = new PolarBear("f");
18: System.out.println(((PolarBear)bear).value);
19: } }
```

A. tacb
B. tacf
C. tacbf
D. tcafb
E. taftacb
F. The code does not compile.
G. An exception is thrown.

**My Answer: F**
**Correct Answer: C**

**Line 16 initializes a PolarBear instance and assigns it to the bear reference. The variable declaration and instance initializers are run first, setting value to tac. The constructor declared on line 5 is called, resulting in value being set to tacb. Remember, a static main() method can access private constructors declared in the same class. Line 17 creates another PolarBear instance, replacing the bear reference declared on line 16. First, value is initialized to tac as before. Line 17 calls the constructor declared on line 8, since String is the narrowest match of a String literal. This constructor then calls the overloaded constructor declared on line 5, resulting in value being updated to tacb. Control returns to the previous constructor, with line 10 updating value to tacbf, and making option C the correct answer.**

---

12. How many lines of the following program contain a compilation error?

```java
1: public class Rodent {
2: public Rodent(Integer x) {}
3: protected static Integer chew() throws Exception {
4: System.out.println("Rodent is chewing");
5: return 1;
6: }
7: }
8: class Beaver extends Rodent {
9: public Number chew() throws RuntimeException {
10: System.out.println("Beaver is chewing on wood");
11: return 2;
12: } }
```

A. None
B. 1
C. 2
D. 3
E. 4
F. 5

**My Answer: B**
**Correct Answer: C**

**The first compilation error is on line 8. Since Rodent declares at least one constructor and it is not a no-argument constructor, Beaver must declare a constructor with an explicit call to a super() constructor. Line 9 contains two compilation errors. First, the return types are not covariant since Number is a supertype, not a subtype, of Integer. Second, the inherited method is static, but the overridden method is not, making this an invalid override**

---

13. Which of these classes compile and will include a default constructor created by the compiler? (Choose all that apply.)

```java
A.
public class Bird {}
B.
public class Bird {
public bird() {}
}
C.
public class Bird {
public bird(String name) {}
}
D.
public class Bird {
public Bird() {}
}
E.
public class Bird {
Bird(String name) {}
}
F.
public class Bird {
private Bird(int age) {}
}
G.
public class Bird {
public Bird bird() { return null; }
}
```

**My Answer: A,G**
**Correct Answer: A,G**

---

14.  Which of the following statements about inheritance are correct? (Choose all that apply.)

A. A class can directly extend any number of classes.
B. A class can implement any number of interfaces.
C. All variables inherit java.lang.Object.
D. If class A is extended by B, then B is a superclass of A.
E. If class C implements interface D, then C is a subtype of D.
F. Multiple inheritance is the property of a class to have multiple direct superclasses.

**My Answer: B,E,F**
**Correct Answer: B,E,F**

**A class that implements an interface is a subtype of that interface, making option E correct.**

---

15. Which statements about the following program are correct? (Choose all that apply.)

```java
1: abstract class Nocturnal {
2: boolean isBlind();
3: }
4: public class Owl extends Nocturnal {
5: public boolean isBlind() { return false; }
6: public static void main(String[] args) {
7: var nocturnal = (Nocturnal)new Owl();
8: System.out.println(nocturnal.isBlind());
9: } }
```

A. It compiles and prints true.
B. It compiles and prints false.
C. The code will not compile because of line 2.
D. The code will not compile because of line 5.
E. The code will not compile because of line 7.
F. The code will not compile because of line 8.
G. None of the above

**My Answer: C**
**Correct Answer: C**

**The code does not compile because the isBlind() method in Nocturnal is not marked abstract and does not contain a method body. The rest of the lines compile without issue, making option C the only correct answer**

---

16. What is the result of the following?

```java
1: class Arachnid {
2: static StringBuilder sb = new StringBuilder();
3: { sb.append("c"); }
4: static
5: { sb.append("u"); }
6: { sb.append("r"); }
7: }
8: public class Scorpion extends Arachnid {
9: static
10: { sb.append("q"); }
11: { sb.append("m"); }
12: public static void main(String[] args) {
13: System.out.print(Scorpion.sb + " ");
14: System.out.print(Scorpion.sb + " ");
15: new Arachnid();
16: new Scorpion();
17: System.out.print(Scorpion.sb);
18: } }
```

A. qu qu qumrcrc
B. u u ucrcrm
C. uq uq uqmcrcr
D. uq uq uqcrcrm
E. qu qu qumcrcr
F. qu qu qucrcrm
G. The code does not compile.

**My Answer: D**
**Correct Answer: D**

**==Based on order of initialization, the static components are initialized first, starting with the Arachnid class, since it is the parent of the Scorpion class, which initializes the StringBuilder to u. The static initializer in Scorpion then updates sb to contain uq==, which is printed twice by lines 13 and 14 along with spaces separating the values. Next, an instance of Arachnid is initialized on line 15. There are two instance initializers in Arachnid, and they run in order, appending cr to the  StringBuilder, resulting in a value of uqcr. An instance of Scorpion is then initialized on line 16. The instance initializers in the superclass Arachnid run first, appending cr again and updating the value of sb to uqcrcr. Finally, the instance initializer in Scorpion runs and appends m.**

---

17. Which of the following are true? (Choose all that apply.)
A. this() can be called from anywhere in a constructor.
B. this() can be called from anywhere in an instance method.
C. this.variableName can be called from any instance method in the class.
D. this.variableName can be called from any static method in the class.
E. You can call the default constructor written by the compiler using this().
F. You can access a private constructor with the main() method in the same class.

**My Answer: C,F**
**Correct Answer: C,F**

---

18. Which statements about the following classes are correct? (Choose all that apply.)

```java
1: public class Mammal {
2: private void eat() {}
3: protected static void drink() {}
4: public Integer dance(String p) { return null; }
5: }
6: class Primate extends Mammal {
7: public void eat(String p) {}
8: }
9: class Monkey extends Primate {
10: public static void drink() throws RuntimeException {}
11: public Number dance(CharSequence p) { return null; }
12: public int eat(String p) {}
13: }
```

A. The eat() method in Mammal is correctly overridden on line 7.
B. The eat() method in Mammal is correctly overloaded on line 7.
C. The drink() method in Mammal is correctly overridden on line 10.
D. The drink() method in Mammal is correctly hidden on line 10.
E. The dance() method in Mammal is correctly overridden on line 11.
F. The dance() method in Mammal is correctly overloaded on line 11.
G. The eat() method in Primate is correctly hidden on line 12.
H. The eat() method in Primate is correctly overloaded on line 12.

**My Answer: H**
**Correct Answer: E,F**

**The eat() method is private in the Mammal class. Since it is not inherited in the Primate class, it is neither overridden nor overloaded, making options A and B incorrect. The drink() method in Mammal is correctly hidden in the Monkey class, as the signature is the same and both are static, making option D correct and option C incorrect. The version in the Monkey class throws a new exception, but it is unchecked; therefore, it is allowed. The dance() method in Mammal is correctly overloaded in the Monkey class because the signaturesare not the same, making option E incorrect and option F correct.**

---

19. What is the output of the following code?

```java
1: class Reptile {
2: {System.out.print("A");}
3: public Reptile(int hatch) {}
4: void layEggs() {
5: System.out.print("Reptile");
6: } }
7: public class Lizard extends Reptile {
8: static {System.out.print("B");}
9: public Lizard(int hatch) {}
10: public final void layEggs() {
11: System.out.print("Lizard");
12: }
13: public static void main(String[] args) {
14: var reptile = new Lizard(1);
15: reptile.layEggs();
16: } }
```

A. AALizard
B. BALizard
C. BLizardA
D. ALizard
E. The code will not compile because of line 3.
F. None of the above

**My Answer: F**
**Correct Answer: F**

**The Reptile class defines a constructor, but it is not a no-argument constructor. Therefore, the Lizard constructor must explicitly call super(), passing in an int value. For this reason, line 9 does not compile, and option F is the correct answer.**

---

20. Which statement about the following program is correct?

```java
1: class Bird {
2: int feathers = 0;
3: Bird(int x) { this.feathers = x; }
4: Bird fly() {
5: return new Bird(1);
6: } }
7: class Parrot extends Bird {
8: protected Parrot(int y) { super(y); }
9: protected Parrot fly() {
10: return new Parrot(2);
11: } }
12: public class Macaw extends Parrot {
13: public Macaw(int z) { super(z); }
14: public Macaw fly() {
15: return new Macaw(3);
16: }
17: public static void main(String... sing) {
18: Bird p = new Macaw(4);
19: System.out.print(((Parrot)p.fly()).feathers);
20: } }
```

A. One line contains a compiler error.
B. Two lines contain compiler errors.
C. Three lines contain compiler errors.
D. The code compiles but throws a ClassCastException at runtime.
E. The program compiles and prints 3.
F. The program compiles and prints 0.

**My Answer: E**
**Correct Answer: E**

**The fly() method is correctly overridden in each subclass since the signature is the same, the access modifier is less restrictive, and the return types are covariant. For covariance, Macaw is a subtype of Parrot, which is a subtype of Bird, so overridden return types are valid. Likewise, the constructors are all implemented properly, with explicit calls to the parent constructors as needed. Line 19 calls the overridden version of fly() defined in the Macaw class, as overriding replaces the method regardless of the reference type. This results in feathers being assigned a value of 3. The Macaw object is then cast to Parrot, which is allowed because Macaw inherits Parrot. The feathers variable is visible since it is defined in the Bird class, and line 19 prints 3,**

---

21. Which of the following are properties of immutable classes? (Choose all that apply.)

A. The class can contain setter methods, provided they are marked final.
B. The class must not be able to be extended outside the class declaration.
C. The class may not contain any instance variables.
D. The class must be marked static.
E. The class may not contain any static variables.
F. The class may only contain private constructors.
G. The data for mutable instance variables may be read, provided they cannot be modified by the caller.

**My Answer: B,G**
**Correct Answer: B,G**

---

22. What does the following program print?
```java
1: class Person {
	2: static String name;
	3: void setName(String q) { name = q; } }
4: public class Child extends Person {
	5: static String name;
	6: void setName(String w) { name = w; }
	7: public static void main(String[] p) {
		8: final Child m = new Child();
		9: final Person t = m;
		10: m.name = "Elysia";
		11: t.name = "Sophia";
		12: m.setName("Webby");
		13: t.setName("Olivia");
		14: System.out.println(m.name + " " + t.name);
15: } }
```

A. Elysia Sophia
B. Webby Olivia
C. Olivia Olivia
D. Olivia Sophia
E. The code does not compile.
F. None of the above

**My Answer: D**
**Correct Answer: D**

**The Child class overrides the setName() method and hides the static name variable defined in the inherited Person class. Since variables are only hidden, not overridden, there are two distinct name variables accessible, depending on the location and reference type. Line 8 creates a Child instance, which is implicitly cast to a Person reference type on line 9. Line 10 uses the Child reference type, updating Child.name to Elysia. Line 11 uses the Person referencetype, updating Person.name to Sophia. Lines 12 and 13 both call the overridden setName() instance method declared on line 6. This sets Child.name to Webby on line 12 and then to Olivia on line 13. The final values of Child.name and Person.name are Olivia and Sophia, respectively, making option D the correct answer.**

---

23. What is the output of the following program?

```java
1: class Canine {
2: public Canine(boolean t) { logger.append("a"); }
3: public Canine() { logger.append("q"); }
4:
5: private StringBuilder logger = new StringBuilder();
6: protected void print(String v) { logger.append(v); }
7: protected String view() { return logger.toString(); }
8: }
9:
10: class Fox extends Canine {
11: public Fox(long x) { print("p"); }
12: public Fox(String name) {
13: this(2);
14: print("z");
15: }
16: }
17:
18: public class Fennec extends Fox {
19: public Fennec(int e) {
20: super("tails");
21: print("j");
22: }
23: public Fennec(short f) {
24: super("eevee");
25: print("m");
26: }
27:
28: public static void main(String... unused) {
29: System.out.println(new Fennec(1).view());
30: } }
```

A. qpz
B. qpzj
C. jzpa
D. apj
E. apjm
F. The code does not compile.
G. None of the above

**My Answer: F**
**Correct Answer: B**

**The constructors are called from the child class upward, but since each line of a constructor is a call to another constructor, via this() or super(), they are ultimately executed in a top-down manner. On line 29, the main() method calls the Fennec() constructor declared on line 19. Remember, integer literals in Java are considered int by default. This constructor calls the Fox() constructor defined on line 12, which in turn calls the overloaded Fox() constructor declared on line11. Since the constructor on line 11 does not explicitly call a parent constructor, the compiler inserts a call to the no-argument super() constructor, which exists on line 3 of the Canine class. Line 3 is then executed, adding q to the output, and the compiler chain is unwound. Line 11 then executes, adding p, followed by line 14, adding z. Finally, line 21 is executed, and j is added, resulting in a final value for logger of qpzj, and making option B correct. For the exam, remember to follow constructors from the lowest level upward to determine the correct pathway, but then execute them from the top down using the established order.**

---

24. What is printed by the following program?

```java
1: class Antelope {
2: public Antelope(int p) {
3: System.out.print("4");
4: }
5: { System.out.print("2"); }
6: static { System.out.print("1"); }
7: }
8: public class Gazelle extends Antelope {
9: public Gazelle(int p) {
10: super(6);
11: System.out.print("3");
12: }
13: public static void main(String hopping[]) {
14: new Gazelle(0);
15: }
16: static { System.out.print("8"); }
17: { System.out.print("9"); }
18: }
```

A. 182640
B. 182943
C. 182493
D. 421389
E. The code does not compile.
F. The output cannot be determined until runtime.

**My Answer: C**
**Correct Answer: C**

**First, the class is initialized, starting with the superclass Antelope and then the subclass Gazelle. This involves invoking the static variable declarations and static initializers. The program first prints 1, followed by 8. Then we follow the constructor pathway from the object created on line 14 upward, initializing each class instance using a top-down approach. Within each class, the instance initializers are run, followed by the referenced constructors. The Antelope instance is initialized, printing 24, followed by the Gazelle instance, printing 93. The final output is 182493**

---

 25. Which of the following are true about a concrete class? (Choose all that apply.)
A. A concrete class can be declared as abstract.
B. A concrete class must implement all inherited abstract methods.
C. A concrete class can be marked as final.
D. A concrete class must be immutable.
E. A concrete method that implements an abstract method must match the method declaration of the abstract method exactly.

**My Answer: B,C**
**Correct Answer: B,C**

---

26. What is the output of the following code?

```java
4: public abstract class Whale {
5: public abstract void dive();
6: public static void main(String[] args) {
7: Whale whale = new Orca();
8: whale.dive(3);
9: }
10: }
11: class Orca extends Whale {
12: static public int MAX = 3;
13: public void dive() {
14: System.out.println("Orca diving");
15: }
16: public void dive(int... depth) {
17: System.out.println("Orca diving deeper "+MAX);
18: } }
```

A. Orca diving
B. Orca diving deeper 3
C. The code will not compile because of line 4.
D. The code will not compile because of line 8.
E. The code will not compile because of line 11.
F. The code will not compile because of line 12.
G. The code will not compile because of line 17.
H. None of the above

**My Answer: D**
**Correct Answer: D**

**The classes are structured correctly, but the body of the main() method contains a compiler error. The Orca object is implicitly cast to a Whale reference on line 7. This is permitted because Orca is a subclass of Whale. By performing the cast, the whale reference on line 8 does not have access to the dive(int... depth) method. For this reason, line 8 does not compile, making option D correct.**

---

# Chapter 7 - Beyond Classes #Chapter

Java file may have at most one ``public`` top-level type, and it must match the name of the file. This applies to classes, enums, records, and so on. a top-level type can only be declared with ``public`` or package access.
## Implementing Interfaces

a class may implement any number of interfaces. An interface is an abstract data type that declares a list of abstract methods that any class implementing the interface must provide.

### Declaring and Using an Interface

In Java, an interface is defined with the ``interface`` keyword, analogous to the ``class`` keyword used when defining a class

![[Pasted image 20240330165738.png]]

**==Interface variables are referred to as constants because they are assumed to be ``public``, ``static``, and ``final``.==** They are initialized with a constant value when they are declared. Since they are ``public`` and ``static``, they can be used outside the interface declaration without requiring an instance of the interface

**==One aspect of an interface declaration that differs from an abstract class is that it contains implicit modifiers==**. An implicit modifier is a modifier that the compiler automatically inserts into the code. For example, an interface is always considered to be abstract, even if it is not marked so.

```java
public abstract interface WalksOnTwoLegs {}
```

The ``abstract`` modifier in this example is optional for interfaces, with the compiler inserting it if it is not provided.

```java
public class Biped {
	public static void main(String[] args) {
		var e = new WalksOnTwoLegs(); // DOES NOT COMPILE
	}
}
public final interface WalksOnEightLegs {} // DOES NOT COMPILE
```

- The first example doesn’t compile, as ``WalksOnTwoLegs`` is an interface and cannot be instantiated.
- The second example, ``WalksOnEightLegs``, doesn’t compile because **==interfaces cannot be marked as ``final``==** for the same reason that abstract classes cannot be marked as final. 

```java
public interface Climb {
	Number getSpeed(int age);
}
```

![[Pasted image 20240330170530.png]]

The ``FieldMouse`` class declares that it implements the ``Climb`` interface and includes an overridden version of ``getSpeed()`` inherited from the ``Climb`` interface. The method signature of ``getSpeed()`` matches exactly, and the return type is covariant, since a ``Float`` can be implicitly cast to a ``Number``. The access modifier of the interface method is implicitly ``public`` in Climb, although the concrete class ``FieldMouse`` must explicitly declare it.

**==If any of the interfaces define abstract methods, then the concrete class is required to override them.==**

### Extending an Interface

Like a class, an interface can extend another interface using the ``extends`` keyword.

```java
public interface Nocturnal {}
public interface HasBigEyes extends Nocturnal {}
```

Unlike a class, which can extend only one class, an interface can extend multiple interfaces.

```java
public interface Nocturnal {
	public int hunt();
}
public interface CanFly {
	public void flap();
}
public interface HasBigEyes extends Nocturnal, CanFly {}
	public class Owl implements HasBigEyes {
	public int hunt() { return 5; }
	public void flap() { System.out.println("Flap!"); }
}
```

Extending two interfaces is permitted because interfaces are not initialized as part of a class hierarchy. Unlike abstract classes, they do not contain constructors and are not part of instance initialization. Interfaces simply define a set of rules and methods that a class implementing them must follow.

### Inheriting an Interface

Like an abstract class, when a concrete class inherits an interface, all of the inherited abstract methods must be implemented.

```java
public interface HasTail {
	public int getTailLength();
}
public interface HasWhiskers {
	public int getNumberOfWhiskers();
}

public abstract class HarborSeal implements HasTail, HasWhiskers {}
public class CommonSeal extends HarborSeal {} // DOES NOT COMPILE
```

- The ``HarborSeal`` class compiles because it is abstract and not required to implement any of the abstract methods it inherits
- The concrete ``CommonSeal`` class, though, must override all inherited abstract methods.

#### Mixing Class and Interface Keywords

**==Although a class can implement an interface, a class cannot extend an interface. Likewise, while an interface can extend another interface, an interface cannot implement another interface.==**

```java
public interface CanRun {}
public class Cheetah extends CanRun {} // DOES NOT COMPILE
public class Hyena {}
public interface HasFur extends Hyena {} // DOES NOT COMPILE
```

#### Inheriting Duplicate Abstract Methods

Java supports inheriting two abstract methods that have compatible method declarations.

```java
public interface Herbivore { public void eatPlants(); }
public interface Omnivore { public void eatPlants(); }
public class Bear implements Herbivore, Omnivore {
public void eatPlants() {
	System.out.println("Eating plants");
} }
```

By compatible, we mean a method can be written that properly overrides both inherited methods:

```java
public interface Herbivore { public void eatPlants(); }
public interface Omnivore { public int eatPlants(); }
public class Tiger implements Herbivore, Omnivore { // DOES NOT COMPILE
	...
}
```

### Inserting Implicit Modifiers

**==an implicit modifier is one that the compiler will automatically insert.==**

-  ==**Interfaces are implicitly ``abstract``.**==
-  ==**Interface variables are implicitly ``public``, ``static``, and ``final``.**==
-  ==**Interface methods without a body are implicitly ``abstract``.**==
-  ==**Interface methods without the ``private`` modifier are implicitly ``public``.==**

The following two interface definitions are equivalent, as the compiler will convert them both to the second declaration:

```java
public interface Soar {
	int MAX_HEIGHT = 10;
	final static boolean UNDERWATER = true;
	void fly(int speed);
	abstract void takeoff();
	public abstract double dive();
}

public abstract interface Soar {
	public static final int MAX_HEIGHT = 10;
	public final static boolean UNDERWATER = true;
	public abstract void fly(int speed);
	public abstract void takeoff();
	public abstract double dive();
}
```

#### Conflicting Modifiers

What happens if a developer marks a method or variable with a modifier that conflicts with an implicit modifier?

```java
public interface Dance {
	private int count = 4; // DOES NOT COMPILE
	protected void step(); // DOES NOT COMPILE
}
```

Neither of these interface member declarations compiles, as the compiler will apply the ``public`` modifier to both, resulting in a conflict.

#### Differences between Interfaces and Abstract Classes

**==Even though abstract classes and interfaces are both considered abstract types, only interfaces make use of implicit modifiers.==**

```java
abstract class Husky { // abstract required in class declaration
	abstract void play(); // abstract required in method declaration
}
interface Poodle { // abstract optional in interface declaration
	void play(); // abstract optional in method declaration
}
```

```java
public class Webby extends Husky {
	void play() {} // OK -play() is declared with package access in Husky
}
public class Georgette implements Poodle {
	void play() {} // DOES NOT COMPILE -play() is public in Poodle
}
```

Even though the two method implementations are identical, the method in the ``Georgette`` class reduces the access modifier on the method from ``public`` to package access.

### Declaring Concrete Interface Methods

![[Pasted image 20240330172909.png]]

--- 
What About ``protected`` or Package Interface Members?

**Alongside ``public`` methods, interfaces now support ``private`` methods. ==They do not support protected access, though, as a class cannot extend an interface. They also do not support package access, although more likely for syntax reasons and backward compatibility==. Since interface methods without an access modifier have been considered implicitly public, changing this behavior to package access would break many existing programs!**

---

#### Writing a ``default`` Interface Method

A default method is a method defined in an interface with the ``default`` keyword and includes a method body. It may be optionally overridden by a class implementing the interface.

One use of ``default`` methods is for backward compatibility. You can add a new ``default`` method to an interface without the need to modify all of the existing classes that implement the interface. The older classes will just use the default implementation of the method defined in the interface

```java
public interface IsColdBlooded {
	boolean hasScales();
	default double getTemperature() {
		return 10.0;
	} 
}
```

```java
public class Snake implements IsColdBlooded {
	public boolean hasScales() { // Required override
		return true;
	}
	public double getTemperature() { // Optional override
		return 12;
	}
}

```

---

**the ``default`` interface method modifier is not the same as the ``default`` label used in a switch statement or expression. Likewise, even though package access is sometimes referred to as default access, that feature is implemented by omitting an access modifier.**

---

**Default Interface Method Definition Rules**
1. ==**A ``default`` method may be declared only within an interface.**==
2. ==**A ``default`` method must be marked with the ``default`` keyword and include a method body.**==
3. ==**A ``default`` method is implicitly public.**==
4. ==**A ``default`` method cannot be marked ``abstract``, ``final``, or ``static``.**==
5. ==**A ``default`` method may be overridden by a class that implements the interface.**==
6. ==**If a class inherits two or more ``default`` methods with the same method signature, then the**==
==**class must override the method.==**

```java
public interface Carnivore {
	public default void eatMeat(); // DOES NOT COMPILE
	public int getRequiredFoodAmount() { // DOES NOT COMPILE
		return 13;
} }
```

Unlike ``abstract`` methods, though, ``default`` interface methods cannot be marked abstract since they provide a body. They also cannot be marked as ``final``, because they are designed so that they can be overridden in classes implementing the interface, just like ``abstract`` methods. Finally, they cannot be marked ``static`` since they are associated with the instance of the class implementing the interface.

##### Inheriting Duplicate ``default`` Methods

```java
public interface Walk {
	public default int getSpeed() { return 5; }
}
public interface Run {
	public default int getSpeed() { return 10; }
}
public class Cat implements Walk, Run {} // DOES NOT COMPILE
```

If the class implementing the interfaces overrides the duplicate default method, the code will compile without issue. By overriding the conflicting method, the ambiguity about which version of the method to call has been removed.

```java
public class Cat implements Walk, Run {
	public int getSpeed() { return 1; }
}
```

##### Calling a Hidden ``default`` Method

what if the ``Cat`` class wanted to access the version of ``getSpeed()`` in ``Walk`` or ``Run``? Is it still accessible?

```java
public class Cat implements Walk, Run {
	public int getSpeed() {
		return 1;
	}
	public int getWalkSpeed() {
		return Walk.super.getSpeed();
	}
}
```

we **==use the ``super`` keyword to show that we are following instance inheritance, not class inheritance==**. Note that calling ``Walk.getSpeed()`` or ``Walk.this.getSpeed()`` would not have worked.

#### Declaring ``static`` Interface Methods

**Static Interface Method Definition Rules**
1. ==**A ``static`` method must be marked with the ``static`` keyword and include a method body.**==
2. ==**A ``static`` method without an access modifier is implicitly ``public``.**==
3. ==**A ``static`` method cannot be marked ``abstract`` or ``final``.**==
4. ==**A ``static`` method is not inherited and cannot be accessed in a class implementing the interface without a reference to the interface name.**==

 can use the ``private`` access modifier with ``static`` methods.

```java
public interface Hop {
	static int getJumpHeight() {
		return 8;
	} 
}
```

Since the method is defined without an access modifier, the compiler will automatically insert the ``public`` access modifier. The method ``getJumpHeight()`` works just like a ``static`` method as defined in a class. In other words, it can be accessed without an instance of a class.

```java
public class Skip {
	public int skip() {
		return Hop.getJumpHeight();
	}
}
```

```java
public class Bunny implements Hop {
	public void printDetails() {
		System.out.println(getJumpHeight()); // DOES NOT COMPILE
	} 
}
```

Without an explicit reference to the name of the interface, the code will not compile, even though ``Bunny`` implements ``Hop``.

```java
public class Bunny implements Hop {
	public void printDetails() {
		System.out.println(Hop.getJumpHeight());
	} 
}
```

**==Java “solved” the multiple inheritance problem of ``static`` interface methods by not allowing them to be inherited!==**
#### Reusing Code with ``private`` Interface Methods

The last two types of concrete methods that can be added to interfaces are ``private`` and ``private`` ``static`` interface methods. **==Because both types of methods are ``private``, they can only be used in the interface declaration in which they are declared==**. For this reason, they were added primarily to reduce code duplication.

```java
public interface Schedule {
	default void wakeUp() { checkTime(7); }
	private void haveBreakfast() { checkTime(9); }
	static void workOut() { checkTime(18); }
	private static void checkTime(int hour) {
		if (hour> 17) {
			System.out.println("You're late!");
		} else {
			System.out.println("You have "+(17-hour)+" hours left " + "to make the appointment");
		} 
	} 
}
```

The difference between a ``non-static private`` method and a ``static`` one is analogous to the difference between an instance and static method declared within a class. In particular, it’s all about what methods each can be called from.

**Private Interface Method Definition Rules**
1. ==**A ``private`` interface method must be marked with the private modifier and include a method body.**==
2. ==**A ``private`` ``static`` interface method may be called by any method within the interface definition.**==
3. ==**A ``private`` interface method may only be called by ``default`` and other ``private non-static`` methods within the interface definition.**==

#### Calling Abstract Methods

``default`` and ``private non-static`` methods can access ``abstract`` methods declared in the interface. This is the primary reason we associate these methods with instance membership. When they are invoked, there is an instance of the interface.

```java
public interface ZooRenovation {
	public String projectName();
	abstract String status();
	default void printStatus() {
		System.out.print("The " + projectName() + " project " + status());
	} 
}
```

both ``projectName()`` and ``status()`` have the same modifiers (``abstract`` and ``public`` are implicit) and can be called by the default method ``printStatus()``.

### Reviewing Interface Members

![[Pasted image 20240330182307.png]]

quick tips for the exam:
-  ==**Treat ``abstract``, ``default``, and ``non-static private`` methods as belonging to an instance of the interface.**==
-  ==**Treat ``static`` methods and variables as belonging to the interface class object.**==
-  ==**All private interface method types are only accessible within the interface declaration.==**

```java
public interface ZooTrainTour {
	abstract int getTrainName();
	private static void ride() {}
	default void playHorn() { getTrainName(); ride(); }
	public static void slowDown() { playHorn(); }
	static void speedUp() { ride(); }
}
```

The ``slowDown()`` method does not compile. is ``static``, though, and cannot call a ``default`` or ``private`` method, such as ``playHorn()``, without an explicit reference object
## Working with Enums

An enumeration, or enum for short, is like a fixed set of constants. Using an enum is much better than using a bunch of constants because it provides type-safe checking. With enums, it is impossible to create an invalid enum value without introducing a compiler error.

**==Enumerations show up whenever you have a set of items whose types are known at compile time==**. Common examples include the compass directions, the months of the year, the planets in the solar system, and the cards in a deck
### Creating Simple Enums

![[Pasted image 20240330185501.png]]

an enum that only contains a list of values as a simple enum. **==When working with simple enums, the semicolon at the end of the list is optional.==**

---

**Enum values are considered constants and are commonly written using snake case. For example, an enum declaring a list of ice cream flavors might include values like VANILLA, ROCKY_ROAD, INT_CHOCOLATE_CHIP, and so on.**

---

```java
var s = Season.SUMMER;
System.out.println(Season.SUMMER); // SUMMER
System.out.println(s == Season.SUMMER); // true
```

enums print the name of the enum when ``toString()`` is called. They can be compared using ``==`` because they are like ``static final`` constants. In other words, you can use ``equals()`` or ``==`` to compare enums, since **==each enum value is initialized only once in the Java Virtual Machine (JVM).**== ==**One thing that you can’t do is extend an enum.==**

```java
public enum ExtendedSeason extends Season {} // DOES NOT COMPILE
```

The values in an enum are fixed. You cannot add more by extending the enum.
#### Calling the ``values()``, ``name()``, and ``ordinal()`` Methods

An enum provides a ``values()`` method to get an array of all of the values.

```java
for(var season: Season.values()) {
	System.out.println(season.name() + " " + season.ordinal());
}
```

The output shows that each enum value has a corresponding int value, and the values are listed in the order in which they are declared:

```text
WINTER 0
SPRING 1
SUMMER 2
FALL 3
```

You can’t compare an ``int`` and an enum value directly anyway since an enum is a type, like a Java class, and not a primitive ``int``.

```java
if ( Season.SUMMER == 2) {} // DOES NOT COMPILE
```

#### Calling the ``valueOf()`` Method

Another useful feature is retrieving an enum value from a ``String`` using the ``valueOf()`` method. **==The ``String`` passed in must match the enum value exactly, though.==**

```java
Season s = Season.valueOf("SUMMER"); // SUMMER
Season t = Season.valueOf("summer"); // IllegalArgumentException
```

**==Each enum value is created once when the enum is first loaded. Once the enum has been loaded, it retrieves the single enum value with the matching name==**.

### Using Enums in ``switch`` Statements

```java
Season summer = Season.SUMMER;
switch(summer) {
	case WINTER:
		System.out.print("Get out the sled!");
		break;
	case SUMMER:
		System.out.print("Time for the pool!");
		break;
	default:
		System.out.print("Is it summer yet?");
}
```

**==Java treats the enum type as implicit==**. In fact, if you were to type case ``Season.WINTER``, it would not compile.

```java
Season summer = Season.SUMMER;
var message = switch(summer) {
	case Season.WINTER -> "Get out the sled!"; // DOES NOT COMPILE
	case 0 -> "Time for the pool!"; // DOES NOT COMPILE
	default -> "Is it summer yet?";
};
System.out.print(message);
```

- The first case statement does not compile because ``Season`` is used in the case value. If we changed ``Season.FALL`` to just ``FALL``, then the line would compile.
- can’t compare enums with ``int`` values
### Adding Constructors, Fields, and Methods

```java
1: public enum Season {
	2: WINTER("Low"), SPRING("Medium"), SUMMER("High"), FALL("Medium");
	3: private final String expectedVisitors;
	4: private Season(String expectedVisitors) {
		5: this.expectedVisitors = expectedVisitors;
	6: }
	7: public void printExpectedVisitors() {
		8: System.out.println(expectedVisitors);
	9: } 
}
```

- On line 2, the list of enum values ends with a semicolon ``(;)``. While this is optional when our enum is composed solely of a list of values, it is required if there is anything in the enum besides the values.
- Lines 3–9 are regular Java code.

---

**Although it is possible to create an enum with instance variables that can be modified, it is a very poor practice to do so since they are shared within the JVM. When designing an enum, the values should be immutable.**

---

**==All enum constructors are implicitly ``private``, with the modifier being optional. In fact, an enum constructor will not compile if it contains a ``public`` or ``protected`` modifier.==**

the parentheses on line 2? Those are constructor calls, but without the new keyword normally used for objects. The first time we ask for any of the enum values, Java constructs all of the enum values. After that, Java just returns the already constructed enum values.

```java
public enum OnlyOne {
	ONCE(true);
	private OnlyOne(boolean b) {
		System.out.print("constructing,");
	}
}

public class PrintTheOne {
	public static void main(String[] args) {
		System.out.print("begin,");
		OnlyOne firstCall = OnlyOne.ONCE; // Prints constructing,
		OnlyOne secondCall = OnlyOne.ONCE; // Doesn't print anything
		System.out.print("end");
	} // begin,constructing,end
}
```

If the ``OnlyOne`` enum was used earlier in the program, and therefore initialized sooner, then the line that declares the ``firstCall`` variable would not print anything.

```java
Season.SUMMER.printExpectedVisitors();
```

to define different methods for each enum.

```java
public enum Season {
	WINTER {
		public String getHours() { return "10am-3pm";}
	},
	SPRING {
		public String getHours() { return "9am-5pm";}
	},
	SUMMER {
		public String getHours() { return "9am-7pm";}
	},
	FALL {
		public String getHours() { return "9am-5pm";}
	};
	public abstract String getHours();
}
```

The enum itself has an ``abstract`` method. This means that each and every enum value is required to implement this method. If we forget to implement the method for one of the values, we get a compiler error:

But what if we don’t want each and every enum value to have a method? We can create an implementation for all values and override it only for the special cases.

```java
public enum Season {
	WINTER {
		public String getHours() { return "10am-3pm";}
	},
	SUMMER {
		public String getHours() { return "9am-7pm";}
	},
	SPRING, FALL;
		public String getHours() { return "9am-5pm";}
}
```

---

```java
public enum Operation {
    PLUS("+") {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS("-") {
        public double apply(double x, double y) { return x - y; }
    },
    TIMES("*") {
        public double apply(double x, double y) { return x * y; }
    },
    DIVIDE("/") {
        public double apply(double x, double y) { return x / y; }
    };

    private final String symbol;

    Operation(String symbol) {
        this.symbol = symbol;
    }

    @Override public String toString() { return symbol; }

    public abstract double apply(double x, double y);
}
```

---

An enum can even implement an interface, as this just requires overriding the ``abstract`` methods:

```java
public interface Weather { int getAverageTemperature(); }
public enum Season implements Weather {
	WINTER, SPRING, SUMMER, FALL;
	public int getAverageTemperature() { return 30; }
}
```

---

**==the list of values came first. This was not an accident. Whether the enum is simple or complex, the list of values always comes first.==**

---

## Sealing Classes

A sealed class is a class that restricts which other classes may **==directly==** extend it

### Declaring a Sealed Class

A sealed class declares a list of classes that can extend it, while the subclasses declare that they extend the sealed class.

![[Pasted image 20240330230403.png]]

**Sealed Class Keywords**
- ==**sealed: Indicates that a class or interface may only be extended/implemented by named classes or interfaces**==
- ==**permits: Used with the sealed keyword to list the classes and interfaces allowed**==
- ==**non-sealed: Applied to a class or interface that extends a sealed class, indicating that it can be extended by unspecified classes**==

```java
public class sealed Frog permits GlassFrog {} // DOES NOT COMPILE
public final class GlassFrog extends Frog {}
public abstract sealed class Wolf permits Timber {}
public final class Timber extends Wolf {}
public final class MyWolf extends Wolf {} // DOES NOT COMPILE
```

- The first example does not compile because the ``class`` and ``sealed`` modifiers are in the wrong order.
- The second example does not compile because ``MyWolf`` isn’t listed in the declaration of ``Wolf``.

---

**Sealed classes are commonly declared with the abstract modifier, although this is certainly not required**

---

Declaring a sealed class with the ``sealed`` modifier is the easy part. Most of the time, if you see a question on the exam about sealed classes, they are testing your knowledge of whether the subclass ``extends`` the ``sealed`` class properly

### Compiling Sealed Classes

```java
// Penguin.java
package zoo;
public sealed class Penguin permits Emperor {} // Emperor must declared already
```

**==a sealed class needs to be declared (and compiled) in the same package as its direct subclasses==**. But what about the subclasses themselves? They must each extend the sealed class

```java
// Penguin.java
package zoo;
public sealed class Penguin permits Emperor {} // DOES NOT COMPILE

// Emperor.java
package zoo;
public final class Emperor {} // Does Not Extends Penguin Class
```

### Specifying the Subclass Modifier

**==Every class that directly extends a sealed class must specify exactly one of the following three modifiers: ``final``, ``sealed``, or ``non-sealed``.==**

#### A ``final`` Subclass

```java
public sealed class Antelope permits Gazelle {}
public final class Gazelle extends Antelope {}
public class George extends Gazelle {} // DOES NOT COMPILE
```

#### A ``sealed`` Subclass

```java
public sealed class Mammal permits Equine {}
public sealed class Equine extends Mammal permits Zebra {}
public final class Zebra extends Equine {}
```

The ``sealed`` modifier applied to the subclass ``Equine`` means the same kind of rules that we applied to the parent class ``Mammal`` must be present. Namely, ``Equine`` defines its own list of permitted subclasses.

Despite allowing indirect subclasses not named in ``Mammal``, the list of classes that can inherit ``Mammal`` is still fixed. If you have a reference to a ``Mammal`` object, it must be a ``Mammal``, ``Equine``, or ``Zebra``.

#### A ``non-sealed`` Subclass

The ``non-sealed`` modifier is used to open a sealed parent class to potentially unknown subclasses.

```java
public sealed class Wolf permits Timber {}
public non-sealed class Timber extends Wolf {}
public class MyWolf extends Timber {}
public class MyFurryWolf extends MyWolf {}
```

### Omitting the ``permits`` Clause

```java
// Snake.java
public sealed class Snake permits Cobra {}
final class Cobra extends Snake {}
```

In this case, the ``permits`` clause is optional and can be omitted. The ``extends`` keyword is still required in the subclass, though:

```java
// Snake.java
public sealed class Snake {}
final class Cobra extends Snake {}
```

If these classes were in separate files, this code would not compile! This rule also applies to sealed classes with nested subclasses.

```java
// Snake.java
public sealed class Snake {
final class Cobra extends Snake {}
}
```

---
**Referencing Nested Subclasses**

**While it makes the code easier to read if you omit the ``permits`` clause for nested subclasses, you are welcome to name them. However, the syntax might be different than you expect.**

```java
public sealed class Snake permits Cobra { // DOES NOT COMPILE
	final class Cobra extends Snake {}
}
```

**This code does not compile because ``Cobra`` requires a reference to the ``Snake`` namespace. The following fixes this issue:**

```java
public sealed class Snake permits Snake.Cobra {
	final class Cobra extends Snake {}
}
```

**When all of your subclasses are nested, we strongly recommend omitting the ``permits`` class.**

---

![[Pasted image 20240330231930.png]]

### Sealing Interfaces

Besides classes, interfaces can also be sealed. The idea is analogous to classes, and many of the same rules apply. For example, the ``sealed`` interface must appear in the same package or named module as the classes or interfaces that directly extend or implement it. **==One distinct feature of a ``sealed`` interface is that the ``permits`` list can apply to a class that implements the interface or an interface that extends the interface==**.

```java
// Sealed interface
public sealed interface Swims permits Duck, Swan, Floats {}
// Classes permitted to implement sealed interface
public final class Duck implements Swims {}
public final class Swan implements Swims {}
// Interface permitted to extend sealed interface
public non-sealed interface Floats extends Swims {}
```

**==Interfaces are implicitly ``abstract`` and cannot be marked ``final``. For this reason, interfaces that ``extend`` a ``sealed`` interface can only be marked ``sealed`` or ``non-sealed``. They cannot be marked ``final``.==**

### Reviewing Sealed Class Rules

**Sealed Class Rules**
- ==**Sealed classes are declared with the ``sealed`` and ``permits`` modifiers.**==
- ==**Sealed classes must be declared in the same package or named module as their direct subclasses.**==
- ==**Direct subclasses of ``sealed`` classes must be marked ``final``, ``sealed``, or ``non-sealed``.**==
- ==**The permits clause is optional if the ``sealed`` class and its direct subclasses are declared within the same file or the subclasses are nested within the ``sealed`` class.**==
- ==**Interfaces can be ``sealed`` to limit the classes that implement them or the interfaces that extend them.**==

## Encapsulating Data with Records

### Understanding Encapsulation

A *POJO*, which stands for Plain Old Java Object, is a class used to model and pass data around, often with few or no complex methods

```java
public class Crane {
	int numberEggs;
	String name;
	public Crane(int numberEggs, String name) {
		this.numberEggs = numberEggs;
		this.name = name;
	}
}
```

```java
public class Poacher {
	public void badActor() {
		var mother = new Crane(5, "Cathy");
		mother.numberEggs = -100;
	}
}
```

*Encapsulation* is a way to protect class members by restricting access to them. In Java, it is commonly implemented by declaring all instance variables ``private``. Callers are required to use methods to retrieve or modify instance variables. Encapsulation is about protecting a class from unexpected use. It also allows us to modify the methods and behavior of the class later without someone already having direct access to an instance variable within the class.

```java
1: public final class Crane {
	2: private final int numberEggs;
	3: private final String name;
	4: public Crane(int numberEggs, String name) {
		5: if (numberEggs >= 0) this.numberEggs = numberEggs; // guard condition
		6: else throw new IllegalArgumentException();
		7: this.name = name;
	8: }
	9: public int getNumberEggs() { // getter
		10: return numberEggs;
	11: }
	12: public String getName() { // getter
		13: return name;
	14: }
15: }
```


- the instance variables are now ``private`` on lines 2 and 3. This means only code within the class can read or write their values.
- added a method on lines 9–11 to read the value, which is called an accessor method or a getter.
- marked the class and its instance variables ``final``, and we don’t have any mutator methods, or setters, to modify the value of the instance variables. That’s because we want our class to be immutable in addition to being well encapsulated.
### Applying Records

![[Pasted image 20240330233434.png]]

A record is a special type of data-oriented class in which the compiler inserts boilerplate code for you
As a bonus, the compiler inserts useful implementations of the ``Object`` methods ``equals()``, ``hashCode()``, and ``toString()``. 
Creating an instance of a ``Crane`` and printing some fields is easy:

```java
var mommy = new Crane(4, "Cammy");
System.out.println(mommy.numberEggs()); // 4
System.out.println(mommy.name()); // Cammy
```

Behind the scenes, it **==creates a constructor for you with the parameters in the same order in which they appear in the record declaration==**. Omitting or changing the type order will lead to compiler errors:

```java
var mommy1 = new Crane("Cammy", 4); // DOES NOT COMPILE
var mommy2 = new Crane("Cammy"); // DOES NOT COMPILE
```

For each field, it also creates an accessor as the field name, plus a set of parentheses. Unlike traditional *POJOs* or *JavaBeans*, the methods don’t have the prefix ``get`` or ``is``.

**Members Automatically Added to Records**
- ==**Constructor: A constructor with the parameters in the same order as the record declaration**==
- ==**Accessor method: One accessor for each field**==
- ==**``equals()``: A method to compare two elements that returns ``true`` if each field is equal in terms of ``equals()``**==
- ==**``hashCode()``: A consistent ``hashCode()`` method using all of the fields**==
- ==**``toString()``: A ``toString()`` implementation that prints each field of the record in a convenient, easy-to- read format**==

```java
var father = new Crane(0, "Craig");
System.out.println(father); // Crane[numberEggs=0, name=Craig]
var copy = new Crane(0, "Craig");
System.out.println(copy); // Crane[numberEggs=0, name=Craig]
System.out.println(father.equals(copy)); // true
System.out.println(father.hashCode() + ", " + copy.hashCode()); // 1007, 1007
```

it is legal to have a record without any fields. It is simply declared with the ``record`` keyword and parentheses:

```java
public record Crane() {}
```

### Understanding Record Immutability

records don’t have setters. Every field is inherently ``final`` and cannot be modified after it has been written in the constructor. In order to “modify” a record, you have to make a new object and copy all of the data you want to preserve.

```java
var cousin = new Crane(3, "Jenny");
var friend = new Crane(cousin.numberEggs(), "Janeice");
```

Just as interfaces are implicitly ``abstract``, **==records are also implicitly ``final``. The ``final`` modifier is optional but assumed.==**

```java
public final record Crane(int numberEggs, String name) {}
```

**==Like enums, that means you can’t extend or inherit a record.==**

```java
public record BlueCrane() extends Crane {} // DOES NOT COMPILE
```

**==Also like enums, a record can implement a regular or sealed interface, provided it implements all of the abstract methods.==**

```java
public interface Bird {}
public record Crane(int numberEggs, String name) implements Bird {}
```

### Declaring Constructors

What if you need to declare a record with some guards ? 
#### The Long Constructor

can just declare the constructor the compiler normally inserts automatically, which we refer to as the long constructor.

```java
public record Crane(int numberEggs, String name) {
	public Crane(int numberEggs, String name) {
		if (numberEggs < 0) throw new IllegalArgumentException();
		this.numberEggs = numberEggs;
		this.name = name;
	}
}
```

**==The compiler will not insert a constructor if you define one with the same list of parameters in the same order. Since each field is ``final``, the constructor must set every field.==**

```java
public record Crane(int numberEggs, String name) {
	public Crane(int numberEggs, String name) {} // DOES NOT COMPILE
}
```

While being able to declare a constructor is a nice feature of records, it’s also problematic. If we have 20 fields, we’ll need to declare assignments for every one, introducing the boilerplate we sought to remove.

#### Compact Constructors

A *compact constructor* is a special type of constructor used for records to process validation and transformations succinctly. It takes no parameters and implicitly sets all fields.

![[Pasted image 20240330234703.png]]

we can check the values we want, and we don’t have to list all the constructor parameters and trivial assignments. Java will execute the full constructor after the compact constructor. also remember that a compact constructor is declared without parentheses, as the exam might try to trick you on this. we can even transform constructor parameters as we discuss more in the next section.
##### Transforming Parameters

Compact constructors give you the opportunity to apply transformations to any of the input values.

```java
public record Crane(int numberEggs, String name) {
	public Crane {
		if (name == null || name.length() < 1)
			throw new IllegalArgumentException();
		name = name.substring(0,1).toUpperCase() + name.substring(1).toLowerCase();
	}
}
```

**==While compact constructors can modify the constructor parameters, they cannot modify the fields of the record.==**

```java
public record Crane(int numberEggs, String name) {
	public Crane {
		this.numberEggs = 10; // DOES NOT COMPILE
	}
}
```

#### Overloaded Constructors

can also create overloaded constructors that take a completely different list of parameters. They are more closely related to the long-form constructor and don’t use any of the syntactical features of compact constructors.

```java
public record Crane(int numberEggs, String name) {
	public Crane(String firstName, String lastName) {
		this(0, firstName + " " + lastName);
	}
}
```

**==The first line of an overloaded constructor must be an explicit call to another constructor via ``this()``. If there are no other constructors, the long constructor must be called.==**
Also, unlike compact constructors, you can only transform the data on the first line. After the first line, all of the fields will already be assigned, and the object is immutable.

```java
public record Crane(int numberEggs, String name) {
	public Crane(int numberEggs, String firstName, String lastName) {
		this(numberEggs + 1, firstName + " " + lastName);
		numberEggs = 10; // NO EFFECT (applies to parameter, not instance field)
		this.numberEggs = 20; // DOES NOT COMPILE
	}
}
```

also can’t declare two record constructors that call each other infinitely or as a cycle.

```java
public record Crane(int numberEggs, String name) {
	public Crane(String name) {
		this(1); // DOES NOT COMPILE
	}
	public Crane(int numberEggs) {
		this(""); // DOES NOT COMPILE
	}
}
```
### Customizing Records

Records actually support many of the same features as a class.

be familiar with for the exam:
- Overloaded and compact constructors
- Instance methods including overriding any provided methods (accessors, ``equals()``, ``hashCode()``, ``toString()``)
- Nested classes, interfaces, annotations, enum, and records

```java
public record Crane(int numberEggs, String name) {
	@Override public int numberEggs() { return 10; }
	@Override public String toString() { return name; }
}
```

While you can add methods, ``static`` fields, and other data types, **==you cannot add instance fields outside the record declaration, even if they are ``private``==**. Doing so defeats the purpose of using a record and could break immutability!

```java
public record Crane(int numberEggs, String name) {
	private static int type = 10;
	public int size; // DOES NOT COMPILE
	private boolean friendly; // DOES NOT COMPILE
}
```

Records also do not support instance initializers. **==All initialization for the fields of a record must happen in a constructor.==**
 
## Creating Nested Classes

A nested class is a class that is defined within another class. A nested class can come in one of four flavors.

-  ==**Inner class: A non-static type defined at the member level of a class**==
-  ==**Static nested class: A static type defined at the member level of a class**==
-  ==**Local class: A class defined within a method body**==
-  ==**Anonymous class: A special case of a local class that does not have a name==**

There are many benefits of using nested classes. They can define helper classes and restrict them to the containing class, thereby improving encapsulation. They can make it easy to create a class that will be used in only one place. They can even make the code cleaner and easier to read.

### Declaring an Inner Class

**==An inner class, also called a member inner class, is a non-static type defined at the member level of a class (the same level as the methods, instance variables, and constructors)==**. Because they are not top-level types, ==**they can use any of the four access levels**==, not just public and package access.

Inner classes have the following properties:
-  Can be declared ``public``, ``protected``, package, or ``private``
-  Can extend a class and implement interfaces
-  Can be marked ``abstract`` or ``final``
-  Can access members of the outer class, including ``private`` members

the inner class can access variables in the outer class without doing anything special

```java
1: public class Home {
	2: private String greeting = "Hi"; // Outer class instance variable
	3:
	4: protected class Room { // Inner class declaration
		5: public int repeat = 3;
		6: public void enter() {
			7: for (int i = 0; i < repeat; i++) greet(greeting);
		8: }
		9: private static void greet(String message) {
			10: System.out.println(message);
		11: }
	12: }
	13:
	14: public void enterRoom() { // Instance method in outer class
	15: var room = new Room(); // Create the inner class instance
	16: room.enter();
	17: }
	18: public static void main(String[] args) {
	19: var home = new Home(); // Create the outer class instance
	20: home.enterRoom();
	21: } 
}
```

- An inner class declaration looks just like a stand-alone class declaration except that it happens to be located inside another class. Line 7 shows that the inner class just refers to greeting as if it were available in the ``Room`` class. Even though the variable is private, it is accessed within that same class.
- **==Since an inner class is not ``static``, it has to be called using an instance of the outer class==**. That means you have to create two objects. Line 19 creates the outer ``Home`` object, while line 15 creates the inner ``Room`` object. It’s important to notice that line 15 doesn’t require an explicit instance of ``Home`` because it is an instance method within ``Home``. This works because ``enterRoom()`` is an instance method within the ``Home`` class. Both ``Room`` and ``enterRoom()`` are members of ``Home``.

---
**Nested Classes Can Now Have ``static`` Member**

**With the introduction of records in Java 16, the existing rule that prevented an inner class from having any ``static`` members (other than static constants) was removed. ==All four types of nested classes can now define ``static`` variables and methods!**==**

---
#### Instantiating an Instance of an Inner Class

```java
20: public static void main(String[] args) {
	21: var home = new Home();
	22: Room room = home.new Room(); // Create the inner class instance
	23: room.enter();
24: }
```

We need an instance of ``Home`` to create a ``Room``. We can’t just call new ``Room()`` inside the ``static main()`` method, because Java won’t know which instance of ``Home`` it is associated with. Java solves this by calling new as if it were a method on the room variable. We can shorten lines 21–23 to a single line:

```java
21: new Home().new Room().enter(); // Sorry, it looks ugly to us too!
```

#### Referencing Members of an Inner Class

Inner classes can have the same variable names as outer classes, making scope a little tricky. There is a special way of calling this to say which variable you want to access. Here is how to nest multiple classes and access
a variable with the same name in each:

```java
1: public class A {
	2: private int x = 10;
	3: class B {
		4: private int x = 20;
		5: class C {
			6: private int x = 30;
			7: public void allTheX() {
				8: System.out.println(x); // 30
				9: System.out.println(this.x); // 30
				10: System.out.println(B.this.x); // 20
				11: System.out.println(A.this.x); // 10
			12: } 
		} 
	}
	13: public static void main(String[] args) {
		14: A a = new A();
		15: A.B b = a.new B();
		16: A.B.C c = b.new C();
		17: c.allTheX();
	18: }
}
```

- Line 14 instantiates the outermost one.
- Line 15 uses the awkward syntax to instantiate ``a B.`` Notice that the type is ``A.B.``
- On line 16, we instantiate a ``C``. This time, the ``A.B.C`` type is necessary to specify. ``C`` is too deep for Java to know where to look. 
- Then line 17 calls a method on the instance variable ``c``.
- Line 10 uses ``this`` in a special way. We still want an instance variable. But this time, we want the one on the ``B`` class, which is the variable on line 4. 
- Line 11 does the same thing for class ``A``, getting the variable from line 2.

---
**Inner Classes Require an Instance**

```java
public class Fox {
	private class Den {}
	public void goHome() {
		new Den();
	}
	public static void visitFriend() {
		new Den(); // DOES NOT COMPILE
	}
}
	
public class Squirrel {
	public void visitFox() {
		new Den(); // DOES NOT COMPILE
	}
}
```

**The first constructor call compiles because ``goHome()`` is an instance method, and therefore the call is associated with the this instance. The second call does not compile because it is called inside a static method. You can still call the constructor, but you have to explicitly give it a reference to a ``Fox`` instance.**

**The last constructor call does not compile for two reasons. Even though it is an instance method, it is not an instance method inside the ``Fox`` class. Adding a ``Fox`` reference would not fix the problem entirely, though. ``Den`` is ``private`` and not accessible in the ``Squirrel`` class.**

---

### Creating a ``static`` Nested Class
 
 A static nested class is a static type defined at the member level. **==Unlike an inner class, a static nested class can be instantiated without an instance of the enclosing class. The trade-off, though, is that it can’t access instance variables or methods declared in the outer class==**.

In other words, it is like a top-level class except for the following:
-  ==**The nesting creates a namespace because the enclosing class name must be used to refer to it.**==
-  ==**It can additionally be marked ``private`` or ``protected``.**==
-  ==**The enclosing class can refer to the fields and methods of the ``static`` nested class.==**

```java
1: public class Park {
	2: static class Ride {
		3: private int price = 6;
	4: }
	5: public static void main(String[] args) {
		6: var ride = new Ride();
		7: System.out.println(ride.price);
	8: } 
}
```

Since the class is ``static``, you do not need an instance of ``Park`` to use it.

### Writing a Local Class

**==A local class is a nested class defined within a method. Like local variables, a local class declaration does not exist until the method is invoked, and it goes out of scope when the method returns.==** This means you can create instances only from within the method. Those instances can still be returned from the method.

---

**Local classes are not limited to being declared only inside methods. For example, they can be declared inside constructors and initializers.**

---


Local classes have the following properties:
-  ==**They do not have an access modifier.**==
-  ==**They can be declared ``final`` or ``abstract``.**==
-  ==**They have access to all fields and methods of the enclosing class (when defined in an instance method).**==
-  ==**They can access ``final`` and effectively final local variables.==**

```java
1: public class PrintNumbers {
	2: private int length = 5;
	3: public void calculate() {
		4: final int width = 20;
		5: class Calculator {
		6: public void multiply() {
			7: System.out.print(length * width);
		8: }
	9: }
		10: var calculator = new Calculator();
		11: calculator.multiply();
	12: }
	13: public static void main(String[] args) {
		14: var printer = new PrintNumbers();
		15: printer.calculate(); // 100
	16: }
17: }
```

- Lines 5–9 are the local class. That class’s scope ends on line 12, where the method ends.
- Line 7 refers to an instance variable and a final local variable, so both variable references are allowed from within the local class.

```java
public void processData() {
	final int length = 5;
	int width = 10;
	int height = 2;
	class VolumeCalculator {
		public int multiply() {
			return length * width * height; // DOES NOT COMPILE
		}
	}
	width = 2;
}
```

The ``length`` and ``height`` variables are ``final`` and effectively final, respectively, so neither causes a compilation issue. On the other hand, the ``width`` variable is reassigned during the method, so it cannot be effectively final. For this reason, the local class declaration does not compile.

---

**Why Can Local Classes Only Access ``final`` or Effectively Final Variables?**

==**the compiler generates a separate ``.class`` file for each inner class. A separate class has no way to refer to a local variable. However, if the local variable is ``final`` or effectively final, Java can handle it by passing a copy of the value or reference variable to the constructor of the local class==. If it weren’t ``final`` or effectively final, these tricks wouldn’t work because the value could change after the copy was made.**

---

### Defining an Anonymous Class

An anonymous class is a specialized form of a local class that does not have a name. **==It is declared and instantiated all in one statement using the ``new`` keyword, a type name with parentheses, and a set of braces ``{}``. Anonymous classes must extend an existing class or implement an existing interface.==** They are useful when you have a short implementation that will not be used anywhere else.

```java
1: public class ZooGiftShop {
	2: abstract class SaleTodayOnly {
		3: abstract int dollarsOff();
	4: }
	5: public int admission(int basePrice) {
		6: SaleTodayOnly sale = new SaleTodayOnly() {
			7: int dollarsOff() { return 3; }
	8: }; // Don't forget the semicolon!
	9: return basePrice - sale.dollarsOff();
	10: }
}
```

- Lines 2–4 define an ``abstract`` class. 
- Lines 6–8 define the anonymous class anonymous class does not have a name. The code says to instantiate a new ``SaleTodayOnly`` object. ``SaleTodayOnly`` is abstract. This is okay because we provide the class body right there—anonymously.
- Pay special attention to the semicolon on line 8. We are declaring a local variable on these lines. Local variable declarations are required to end with semicolons, just like other Java statements—even if they are long and happen to contain an anonymous class.

```java
1: public class ZooGiftShop {
	2: interface SaleTodayOnly {
		3: int dollarsOff();
	4: }
	5: public int admission(int basePrice) {
		6: SaleTodayOnly sale = new SaleTodayOnly() {
			7: public int dollarsOff() { return 3; }
		8: };
		9: return basePrice - sale.dollarsOff();
	10: } 
}
```

- Lines 2–4 declare an interface instead of an ``abstract`` class. 
- Line 7 is public instead of using default access since interfaces require ``public`` methods. The anonymous class is the same whether you implement an interface or extend a class! Java figures out which one you want automatically.


**==what if we want to both implement an interface and extend a class? You can’t do so with an anonymous class unless the class to extend is ``java.lang.Object``. The ``Object`` class doesn’t count in the rule==**. Remember that an anonymous class is just an unnamed local class. You can write a local class and give it a name if you have this problem. Then you can extend a class and implement as many interfaces as you like. If your code is this complex, a local class probably isn’t the most readable option anyway. 

You can even define anonymous classes outside a method body. The following may look like we are instantiating an interface as an instance variable, but the ``{}`` after the interface name indicates that this is an anonymous class implementing the interface:

```java
public class Gorilla {
	interface Climb {}
	Climb climbing = new Climb() {};
}
```

### Reviewing Nested Classes

![[Pasted image 20240331170453.png]]

![[Pasted image 20240331170503.png]]

## Understanding Polymorphism

the property of an object to take on many different forms. To put this more precisely, a Java object may be accessed using:

- ==**A reference with the same type as the object**==
- ==**A reference that is a superclass of the object**==
- ==**A reference that defines an interface the object implements or inherits==**

**==Furthermore, a cast is not required if the object is being reassigned to a supertype or interface of the object==.**

```java
public class Primate {
    public boolean hasHair() {
        return true;
    }
}

public interface HasTail {
    public abstract boolean isTailStriped();
}

public class Lemur extends Primate implements HasTail {
    public boolean isTailStriped() {
        return false;
    }

    public int age = 10;

    public static void main(String[] args) {
        Lemur lemur = new Lemur();
        System.out.println(lemur.age); // 10
        HasTail hasTail = lemur;
        System.out.println(hasTail.isTailStriped()); // false
        Primate primate = lemur;
        System.out.println(primate.hasHair()); // true
    }
}
```

**==The most important thing to note about this example is that only one object, ``Lemur``, is created==**. Polymorphism enables an instance of ``Lemur`` to be reassigned or passed to a method using one of its supertypes, such as Primate or ``HasTail``.

Once the object has been assigned to a new reference type, only the methods and variables available to that reference type are callable on the object without an explicit cast.

```java
HasTail hasTail = new Lemur();
System.out.println(hasTail.age); // DOES NOT COMPILE
Primate primate = new Lemur();
System.out.println(primate.isTailStriped()); // DOES NOT COMPILE
```

- the reference ``hasTail`` has direct access only to methods defined with the ``HasTail`` interface; therefore, it doesn’t know that the variable age is part of the object.
- Likewise, the reference primate has access only to methods defined in the ``Primate`` class, and it doesn’t have direct access to the ``isTailStriped()`` method.
### Object vs. Reference

In Java, all objects are accessed by reference, so as a developer you never have direct access to the object itself. Conceptually, though, you should consider the object as the entity that exists in memory, allocated by the Java Runtime Environment. Regardless of the type of the reference you have for the object in memory, the object itself doesn’t change.

Since all objects inherit ``java.lang.Object``, they can all be reassigned to`` java.lang.Object``,

```java
Lemur lemur = new Lemur();
Object lemurAsObject = lemur;
```

Even though the ``Lemur`` object has been assigned to a reference with a different type, the object itself has not changed and still exists as a ``Lemur`` object in memory. What has changed, then, is our ability to access methods within the ``Lemur`` class with the ``lemurAsObject`` reference. Without an explicit cast back to ``Lemur``, we no longer have access to the ``Lemur`` properties of the object.
summarize this principle with the following two rules:
1. ==**The type of the object determines which properties exist within the object in memory.**==
2. ==**The type of the reference to the object determines which methods and variables are accessible to the Java program.**==


![[Pasted image 20240331192333.png]]

**==the same object exists in memory regardless of which reference is pointing to it. Depending on the type of the reference, we may only have access to certain methods.==**

---

**Using Interface References**

**When working with a group of objects that implement a common interface, it is considered a good coding practice to use an interface as the reference type. This is especially common with collections**

```java
public void sortAndPrintZooAnimals(List<String> animals) {
	Collections.sort(animals);
	for(String a : animals) System.out.println(a);
}
```

**At no point is this class interested in what the actual underlying object for ``animals`` is. It might be an ``ArrayList`` or another type. The point is, our code works on any of these types because we used the interface reference type rather than a class type.**

---
### Casting Objects

```java
Lemur lemur = new Lemur();
Primate primate = lemur; // Implicit Cast to supertype
Lemur lemur2 = (Lemur)primate; // Explicit Cast to subtype
Lemur lemur3 = primate; // DOES NOT COMPILE (missing cast)
```

- first create a ``Lemur`` object and implicitly cast it to a ``Primate`` reference. Since ``Lemur`` is a subtype of ``Primate``, this can be done without a cast operator.
- then cast it back to a ``Lemur`` object using an explicit cast, gaining access to all of the methods and fields in the ``Lemur`` class.
- The last line does not compile because an explicit cast is required. Even though the object is stored in memory as a ``Lemur`` object, we need an explicit cast to assign it to ``Lemur``.

Casting objects is similar to casting primitives. 
- **==When casting objects, you do not need a cast operator if casting to an inherited supertype. This is referred to as an implicit cast and applies to classes or interfaces the object inherits.==**
- **==Alternatively, to access a subtype of the current reference, you need to perform an explicit cast with a compatible type. If the underlying object is not compatible with the type, then a ``ClassCastException`` will be thrown at runtime.==**

When reviewing a question on the exam that involves casting and polymorphism, be sure to remember what the instance of the object actually is. Then, focus on whether the compiler will allow the object to be referenced with or without explicit casts.

1. ==**Casting a reference from a subtype to a supertype doesn’t require an explicit cast.**==
2. ==**Casting a reference from a supertype to a subtype requires an explicit cast.**==
3. ==**At runtime, an invalid cast of a reference to an incompatible type results in a ``ClassCastException`` being thrown.**==
4. ==**The compiler disallows casts to unrelated types.==**

#### Disallowed Casts

The exam may try to trick you with a cast that the compiler knows is not permitted (aka impossible). 

```java
public class Bird {}

public class Fish {
	public static void main(String[] args) {
		Fish fish = new Fish();
		Bird bird = (Bird)fish; // DOES NOT COMPILE
	}
}
```

the classes ``Fish`` and ``Bird`` are not related through any class hierarchy that the compiler is aware of; therefore, the code will not compile. While they both extend Object implicitly, they are considered unrelated types since one cannot be a subtype of the other.

#### Casting Interfaces

While the compiler can enforce rules about casting to unrelated types for classes, it cannot always do the same for interfaces. instances support multiple inheritance, which limits what the compiler can reason about them. While a given class may not implement an interface, it’s possible that some subclass may implement the interface. When holding a reference to a particular class, the compiler doesn’t know which specific subtype it is holding.

```java
1: interface Canine {}
2: interface Dog {}
3: class Wolf implements Canine {}
4:
5: public class BadCasts {
	6: public static void main(String[] args) {
		7: Wolf wolfy = new Wolf();
		8: Dog badWolf = (Dog)wolfy;
	9: } 
}
```

- a ``Wolf`` object is created and then assigned to a ``Wolf`` reference type on line 7. With interfaces, the compiler has limited ability to enforce many rules because even though a reference type may not implement an interface, one of its subclasses could. 
- Therefore, it allows the invalid cast to the ``Dog`` reference type on line 8, even though ``Dog`` and ``Wolf`` are not related. even though the code compiles, it still throws a ``ClassCastException`` at runtime.

**==the compiler can enforce one rule around interface casting. The compiler does not allow a cast from an interface reference to an object reference if the object type cannot possibly implement the interface, such as if the class is marked ``final``==**

if the ``Wolf`` interface is marked final on line 3, then line 8 no longer compiles. The compiler recognizes that there are no possible subclasses of ``Wolf`` capable of implementing the ``Dog`` interface.
###  The ``instanceof`` Operator

The ``instanceof`` operator can be used to check whether an object belongs to a particular class or interface and to prevent a ``ClassCastException`` at runtime.

```java
1: class Rodent {}
2:
3: public class Capybara extends Rodent {
	4: public static void main(String[] args) {
		5: Rodent rodent = new Rodent();
		6: var capybara = (Capybara)rodent; // ClassCastException
	7: }
8: }
```

```java
6: if(rodent instanceof Capybara c) {
	7: // Do stuff
8: }
```

Now the code snippet doesn’t throw an exception at runtime and performs the cast only if the ``instanceof`` operator is successful. **==Just as the compiler does not allow casting an object to unrelated types, it also does not allow ``instanceof`` to be used with unrelated types==**

```java
public class Bird {}
public class Fish {
	public static void main(String[] args) {
		Fish fish = new Fish();
		if (fish instanceof Bird b) { // DOES NOT COMPILE
			// Do stuff
		}
	}
}
```

### Polymorphism and Method Overriding

In Java, polymorphism states that when you override a method, you replace all calls to it, even those defined in the parent class.

```java
class Penguin {
	public int getHeight() { return 3; }
	public void printInfo() {
		System.out.print(this.getHeight());
	}
}
public class EmperorPenguin extends Penguin {
	public int getHeight() { return 8; }
	public static void main(String []fish) {
		new EmperorPenguin().printInfo(); // 8
	}
}
```

- In this example, the object being operated on in memory is an ``EmperorPenguin``.
- The ``getHeight()`` method is overridden in the subclass, meaning all calls to it are replaced at runtime. Despite ``printInfo()`` being defined in the ``Penguin`` class, calling ``getHeight()`` on the object calls the method associated with the precise object in memory, not the current reference type where it is called.
- Even using the ``this`` reference, which is optional in this example, does not call the parent version because the method has been replaced.

***==Polymorphism’s ability to replace methods at runtime via overriding is one of the most important properties of Java.==***

can choose to limit polymorphic behavior by marking methods ``final``, which prevents them from being overridden by a subclass

---

**Calling the Parent Version of an Overridden Method**

**can use the ``super`` reference to access it.**

```java
class Penguin {
	public int getHeight() { return 3; }
	public void printInfo() {
		System.out.print(super.getHeight()); // DOES NOT COMPILE
	}
}
```

**``super`` refers to the superclass of ``Penguin``; in this case, ``Object``. The solution is to override ``printInfo()`` in the child ``EmperorPenguin`` class and use super there.**

```java
public class EmperorPenguin extends Penguin {
	public int getHeight() { return 8; }
	public void printInfo() {
		System.out.print(super.getHeight());
	}
	public static void main(String []fish) {
		new EmperorPenguin().printInfo(); // 3
	}
}
```

---

#### Overriding vs. Hiding Members

While method overriding replaces the method everywhere it is called, ``static`` method and variable hiding do not. hiding members is not a form of polymorphism since the methods and variables maintain their individual properties. Unlike method overriding, hiding members is very sensitive to the reference type and location where the member is being used.

```java
class Penguin {
	public static int getHeight() { return 3; }
	public void printInfo() {
		System.out.println(this.getHeight());
	}
}
public class CrestedPenguin extends Penguin {
	public static int getHeight() { return 8; }
	public static void main(String... fish) {
		new CrestedPenguin().printInfo(); //3 
	}
}
```

The ``getHeight()`` method is static and is therefore hidden, not overridden. The result is that calling ``getHeight()`` in ``CrestedPenguin`` returns a different value than calling it in ``Penguin``, even if the underlying object is the same 

while you are permitted to use an instance reference to access a ``static`` variable or method, doing so is often discouraged. The compiler will warn you when you access ``static`` members in a non-static way. In this case, the ``this`` reference had no impact on the program output. Besides the location, the reference type can also determine the value you get when you are working with hidden members

```java
class Marsupial {
    protected int age = 2;

    public static boolean isBiped() {
        return false;
    }
}

public class Kangaroo extends Marsupial {
    protected int age = 6;

    public static boolean isBiped() {
        return true;
    }

    public static void main(String[] args) {
        Kangaroo joey = new Kangaroo();
        Marsupial moey = joey;
        System.out.println(joey.isBiped()); // true
        System.out.println(moey.isBiped()); // false
        System.out.println(joey.age); // 6 
        System.out.println(moey.age); // 2
    }
}
```

only one object (of type ``Kangaroo``) is created and stored in memory! Since ``static`` methods can only be hidden, not overridden, Java uses the reference type to determine which version of ``isBiped()`` should be called, resulting in ``joey.isBiped()`` printing true and ``moey.isBiped()`` printing false.
Likewise, the ``age`` variable is hidden, not overridden, so the reference type is used to determine which value to output. This results in`` joey.age`` returning 6 and ``moey.age`` returning 2.
## Summary #OCP_Summary 

**==with interfaces and described how they can support multiple inheritance. Remember, interfaces and their members can include a number of implicit modifiers inserted by the compiler automatically. We then covered all six types of interface members you need to know for the exam: ``abstract`` methods, ``static`` constants, default methods, ``static`` methods, ``private`` methods, and ``private static`` methods.**==

==**enums, which are compile-time constant properties. Simple enums are composed of a list of values, while complex enums can include constructors, methods, and fields. Enums can also be used in ``switch`` statements and expressions. When an enum method is marked ``abstract``, each enum value must provide an implementation.**==

==**sealed classes and how they allow classes to function like enumerated types in which only certain subclasses are permitted. For the exam, it’s important to remember that the subclasses of a sealed class must be marked ``final``, ``sealed``, or ``non-sealed``. If the subclasses of the sealed class are defined in the same file, then the permits clause may be omitted in the sealed class declaration. Finally, sealed interfaces may be used to limit which classes can implement an interface, which interfaces may extend an interface, or both.**==

==**Records are another new feature available in Java. Records are a compact way of declaring an immutable and encapsulated POJO in which the compiler adds a lot of the boilerplate code for you. Remember, encapsulation is the practice of preventing external callers from accessing the internal components of an object. Records include automatic creation of the accessor methods, a long constructor, and useful implementations of ``equals()``, ``hashCode()``, and ``toString()``. Records can include overloaded and compact constructors to support data validation and transformation. Records do not permit instance variables, since this could break immutability, but they do allow methods, static members, and nested types**==

==**An inner class requires an instance of the outer class to use, while a static nested class does not. A local class is commonly defined within a method or block. Local classes can only access local variables that are ``final`` and effectively final. Anonymous classes are a special type of local class that does not have a name. Anonymous classes are required to extend exactly one class or implement one interface. Inner, local, and anonymous classes can access private members of the class in which they are defined, provided the latter two are used inside an instance method.**==

==**polymorphism, which is central to the Java language, and showed how objects can be accessed in a variety of forms. Make sure you understand when casts are needed for accessing objects, and be able to spot the difference between compile-time and runtime cast problems.==**

## Exam Essentials #Essential 

**Be able to write code that creates, extends, and implements interfaces**. Interfaces are specialized abstract types that focus on abstract methods and constant variables. An interface may extend any number of interfaces and, in doing so, inherits their abstract methods. An interface cannot extend a class, nor can a class extend an interface. A class may implement any number of interfaces.

==**Know which interface methods an interface method can reference**. Non-static ``private``, default, and ``abstract`` interface methods are associated with an instance of an interface. Non-static private and default interface methods may reference any method within the interface declaration. Alternatively, ``static`` interface methods are associated with class membership and can only reference other ``static`` members. Finally, ``private`` methods can only be referenced within the interface declaration.==

**Be able to create and use enum types**. An enum is a data structure that defines a list of values. If the enum does not contain any other elements, the semicolon (;) after the values is optional. An enum can be used in ``switch`` statements and contain instance variables, constructors, and methods. Enum constructors are implicitly ``private``. Enums can include methods, both as members or within individual enum values. If the enum declares an abstract method, each enum value must implement it.

**Be able to recognize when sealed classes are being correctly used**. A sealed class is one that defines a list of permitted subclasses that extend it. Be able to use the correct modifier ``(final``, ``sealed``, or ``non-sealed``) with sealed classes. Understand when the permits clause may be excluded.

**Identify properly encapsulated classes**. Instance variables in encapsulated classes are private. All code that retrieves the value or updates it uses methods. Encapsulated classes may include accessor (getter) or mutator (setter) methods, although this is not required.

**Understand records and know which members the compiler is adding automatically**. Records are encapsulated and immutable types in which the compiler inserts a long constructor, accessor methods, and useful implementations of ``equals()``, ``hashCode()``, and ``toString()``. Each of these elements may be overridden. Be able to recognize **==compact constructors and know that they are used only for validation and transformation of constructor parameters, not for accessing fields==**. Recognize that when a record is declared with an instance member, it does not compile.

**Be able to declare and use nested classes**. There are four types of nested types: inner classes, static classes, local classes, and anonymous classes. Instantiating an inner class requires an instance of the outer class. On the other hand, static nested classes can be created without a reference to the outer class. Local and anonymous classes cannot be declared with an access modifier. **==Anonymous classes are limited to extending a single class or implementing one interface==**.

**Understand polymorphism**. An object may take on a variety of forms, referred to as polymorphism. **==The object is viewed as existing in memory in one concrete form but is accessible in many forms through reference variables. Changing the reference type of an object may grant access to new members, but the members always exist in memory.==**

## Review Questions

1. Which of the following are valid record declarations? (Choose all that apply.)

```java
public record Iguana(int age) {
private static final int age = 10; }
public final record Gecko() {}
public abstract record Chameleon() {
private static String name; }
public record BeardedDragon(boolean fun) {
@Override public boolean fun() { return false; } }
public record Newt(long size) {
@Override public boolean equals(Object obj) { return false; }
public void setSize(long size) {
this.size = size;
} }
```

A. Iguana
B. Gecko
C. Chameleon
D. BeardedDragon
E. Newt
F. None of the above

**My Answer: A, B
Correct Answer: B,D**

**Iguana does not compile, as it declares a static field with the same name as an instance field. ==Records are implicitly final and cannot be marked abstract==, which is why Gecko compiles and Chameleon does not**

---

2. Which of the following statements can be inserted in the blank line so that the code will compile
successfully? (Choose all that apply.)

```java
interface CanHop {}
public class Frog implements CanHop {
	public static void main(String[] args) {
	    ???	frog = new TurtleFrog();
	}
}
class BrazilianHornedFrog extends Frog {}
class TurtleFrog extends Frog {}
```

A. Frog
B. TurtleFrog
C. BrazilianHornedFrog
D. CanHop
E. var
F. Long
G. None of the above; the code contains a compilation error.

**My Answer: A,B,D,E**
**Correct Answer: A,B,D,E**

**The blank can be filled with any class or interface that is a supertype of TurtleFrog. Option A is the direct superclass of TurtleFrog, and option B is the same class, so both are correct. TurtleFrog inherits the CanHop interface, so option D is correct. Option E is also correct, as var is permitted when the type is known.**

---

3. What is the result of the following program?

```java
public class Favorites {
enum Flavors {
VANILLA, CHOCOLATE, STRAWBERRY
static final Flavors DEFAULT = STRAWBERRY;
}
public static void main(String[] args) {
for(final var e : Flavors.values())
System.out.print(e.ordinal()+" ");
}
}
```

A. 0 1 2
B. 1 2 3
C. Exactly one line of code does not compile.
D. More than one line of code does not compile.
E. The code compiles but produces an exception at runtime.
F. None of the above

**My Answer: C**
**Correct Answer: C**

**When an enum contains only a list of values, the semicolon (;) after the list is optional. When an enum contains any other members, such as a constructor or variable, the semicolon is required. Since the enum list does not end with a semicolon, the code does not compile, making option C the correct answer**

---

4. What is the output of the following program?

```java
public sealed class ArmoredAnimal permits Armadillo {
public ArmoredAnimal(int size) {}
@Override public String toString() { return "Strong"; }
public static void main(String[] a) {
var c = new Armadillo(10, null);
System.out.println(c);
}
}
class Armadillo extends ArmoredAnimal {
@Override public String toString() { return "Cute"; }
public Armadillo(int size, String name) {
super(size);
}
}
```

A. Strong
B. Cute
C. The program does not compile.
D. The code compiles but produces an exception at runtime.
E. None of the above

**My Answer: C**
**Correct Answer: C**

**A class extending a sealed class must be marked final, sealed, or non-sealed. Since Armadillo is missing a modifier, the code does not compile**

---

5.  Which statements about the following program are correct? (Choose all that apply.)

```java
1: interface HasExoskeleton {
2: double size = 2.0f;
3: abstract int getNumberOfSections();
4: }
5: abstract class Insect implements HasExoskeleton {
6: abstract int getNumberOfLegs();
7: }
8: public class Beetle extends Insect {
9: int getNumberOfLegs() { return 6; }
10: int getNumberOfSections(int count) { return 1; }
11: }
```

A. It compiles without issue.
B. The code will produce a ClassCastException if called at runtime.
C. The code will not compile because of line 2.
D. The code will not compile because of line 5.
E. The code will not compile because of line 8.
F. The code will not compile because of line 10.

**My Answer: F**
**Correct Answer: E**

**The concrete class Beetle extends Insect and inherits two abstract methods, getNumberOfSections() and getNumberOfLegs(). The Beetle class includes an overloaded version of getNumberOfSections() that takes an int value. The method declaration is valid, making option F incorrect, although it does not satisfy the abstract method requirement inherited from HasExoskeleton. For this reason, only one of the two abstract methods is properly overridden. The Beetle class therefore does not compile, and option E is correct.**

---

6. Which statements about the following program are correct? (Choose all that apply.)

```JAVA
1: public abstract interface Herbivore {
2: int amount = 10;
3: public void eatGrass();
4: public abstract int chew() { return 13; }
5: }
6:
7: abstract class IsAPlant extends Herbivore {
8: Object eatGrass(int season) { return null; }
9: }
```

A. It compiles and runs without issue.
B. The code will not compile because of line 1.
C. The code will not compile because of line 2.
D. The code will not compile because of line 4.
E. The code will not compile because of line 7.
F. The code will not compile because line 8 contains an invalid method override.

**My Answer: D,E**
**Correct Answer: D,E**

**Line 4 does not compile, since an abstract method cannot include a body. Line 7 also does not compile because the wrong keyword is used. A class implements an interface; it does not extend it.**

---

7. What is the output of the following program?

```JAVA
1: interface Aquatic {
2: int getNumOfGills(int p);
3: }
4: public class ClownFish implements Aquatic {
5: String getNumOfGills() { return "14"; }
6: int getNumOfGills(int input) { return 15; }
7: public static void main(String[] args) {
8: System.out.println(new ClownFish().getNumOfGills(-1));
9: } }
```

A. 14
B. 15
C. The code will not compile because of line 4.
D. The code will not compile because of line 5.
E. The code will not compile because of line 6.
F. None of the above

**My Answer: B**
**Correct Answer: E**

**The inherited interface method getNumOfGills(int) is implicitly public; therefore, it must be declared public in any concrete class that implements the interface. Since the method uses the package (default) modifier in the ClownFish class, line 6 does not compile, making option E the correct answer.**

---

8. When inserted in order, which modifiers can fill in the blank to create a properly encapsulated class? (Choose all that apply.)

```java
public class Rabbits {
?? int numRabbits = 0;
?? void multiply() {
numRabbits *= 6;
}
?? int getNumberOfRabbits() {
return numRabbits;
}
}
```

A. private, public, and public
B. private, protected, and private
C. private, private, and protected
D. public, public, and public
E. The class cannot be properly encapsulated since multiply() does not begin with set.
F. None of the above

**My Answer: A**
**Correct Answer: A,B,C**

**Instance variables must include the private access modifier, making option D incorrect. While it is common for methods to be public, this is not required.**

---

9. Which of the following statements can be inserted in the blank so that the code will compile successfully? (Choose all that apply.)

```JAVA
abstract class Snake {}
class Cobra extends Snake {}
class GardenSnake extends Cobra {}
public class SnakeHandler {
private Snake snakey;
public void setSnake(Snake mySnake) { this.snakey = mySnake; }
public static void main(String[] args) {
new SnakeHandler().setSnake( );
}
}
```

A. new Cobra()
B. new Snake()
C. new Object()
D. new String("Snake")
E. new GardenSnake()
F. null
G. None of the above. The class does not compile, regardless of the value inserted in the
blank.

**My Answer: C,F**
**Correct Answer: A,E,F**

**The setSnake() method requires an instance of Snake. Cobra is a direct subclass, while GardenSnake is an indirect subclass. For these reasons, options A and E are correct. Option B is incorrect because Snake is abstract and requires a concrete subclass for instantiation. Option C is incorrect because Object is a supertype of Snake, not a subtype. Option D is incorrect as String is an unrelated class and does not inherit Snake. Finally, a null value can always be passed as an object value, regardless of type, so option F is also correct.**

---

10. What types can be inserted in the blanks on the lines marked X and Z that allow the code to compile? (Choose all that apply.)

```java
interface Walk { private static List move() { return null; } }
interface Run extends Walk { public ArrayList move(); }
class Leopard implements Walk {
public ??? move() { // X
return null;
}
}
class Panther implements Run {
public ??? move() { // Z
return null;
}
}
```

A. Integer on the line marked X
B. ArrayList on the line marked X
C. List on the line marked X
D. List on the line marked Z
E. ArrayList on the line marked Z
F. None of the above, since the Run interface does not compile
G. The code does not compile for a different reason.

**My Answer: G**
**Correct Answer: A,B,C,E**

**Walk declares a private method that is not inherited in any of its subtypes. For this reason, any valid class is supported on line X, making options A, B, and C correct. Line Z is more restrictive, with only ArrayList or subtypes of ArrayList supported, making option E correct**

---

11. What is the result of the following code? (Choose all that apply.)

```java
1: public class Movie {
2: private int butter = 5;
3: private Movie() {}
4: protected class Popcorn {
5: private Popcorn() {}
6: public static int butter = 10;
7: public void startMovie() {
8: System.out.println(butter);
9: }
10: }
11: public static void main(String[] args) {
12: var movie = new Movie();
13: Movie.Popcorn in = new Movie().new Popcorn();
14: in.startMovie();
15: } }
```

A. The output is 5.
B. The output is 10.
C. Line 6 generates a compiler error.
D. Line 12 generates a compiler error.
E. Line 13 generates a compiler error.
F. The code compiles but produces an exception at runtime.

**My Answer: B**
**Correct Answer: E**

**Starting with Java 16, inner classes can contain static variables, so the code compiles. Remember that ==private constructors can be used by any methods within the outer class==. The butter reference on line 8 refers to the inner class variable defined on line 6, with the output being 10 at runtime, and making option B correct**

---

12. Which of the following are true about encapsulation? (Choose all that apply.)

A. It allows getters.
B. It allows setters.
C. It requires specific naming conventions.
D. It requires public instance variables.
E. It requires private instance variables.

**My Answer: A,B,E**
**Correct Answer: A,B,E**



---

13. What is the result of the following program?

```JAVA
	public class Weather {
	enum Seasons {
		WINTER, SPRING, SUMMER, FALL
	}
	public static void main(String[] args) {
		Seasons v = null;
		switch (v) {
		case Seasons.SPRING -> System.out.print("s");
		case Seasons.WINTER -> System.out.print("w");
		case Seasons.SUMMER -> System.out.print("m");
		default -> System.out.println("missing data"); }
	}
}
```

A. s
B. w
C. m
D. missing data
E. Exactly one line of code does not compile.
F. More than one line of code does not compile.
G. The code compiles but produces an exception at runtime.

**My Answer: F**
**Correct Answer: F**

**When using an enum in a switch expression, the case statement must be made up of the enum values only. If the enum name is used in the case statement value, then the code does not compile.** 

---

14. Which statements about sealed classes are correct? (Choose all that apply.)

A. A sealed interface restricts which subinterfaces may extend it.
B. A sealed class cannot be indirectly extended by a class that is not listed in its permits clause.
C. A sealed class can be extended by an abstract class.
D. A sealed class can be extended by a subclass that uses the non-sealed modifier.
E. A sealed interface restricts which subclasses may implement it.
F. A sealed class cannot contain any nested subclasses.
G. None of the above

**My Answer: C,D**
**Correct Answer: A,C,E**

**A sealed interface restricts which interfaces may extend it, or which classes may implement it, making options A and E correct. Option C is correct. While a sealed class is commonly extended by a subclass**
**marked final, it can also be extended by a sealed or non-sealed subclass marked abstract**

---

15. Which lines, when entered independently into the blank, allow the code to print Not scared at runtime? (Choose all that apply.)

```JAVA
public class Ghost {
public static void boo() {
System.out.println("Not scared");
}
protected final class Spirit {
public void boo() {
System.out.println("Booo!!!");
}
}
public static void main(String... haunt) {
var g = new Ghost().new Spirit() {};
???;
}
}
```

A. g.boo()
B. g.super.boo()
C. new Ghost().boo()
D. g.Ghost.boo()
E. new Spirit().boo()
F. Ghost.boo()
G. None of the above

**My Answer: B,C,D,F**
**Correct Answer: G**

**Trick question—the code does not compile! For this reason, option G is correct. The Spirit class is marked final, so it cannot be extended. The main() method uses an anonymous class that inherits from Spirit, which is not allowed**

---

16. The following code appears in a file named Ostrich.java. What is the result of compiling the source file?

```java
1: public class Ostrich {
2: private int count;
3: static class OstrichWrangler {
4: public int stampede() {
5: return count;
6: } } }
```

A. The code compiles successfully, and one bytecode file is generated: Ostrich.class.
B. The code compiles successfully, and two bytecode files are generated: Ostrich.class and OstrichWrangler.class.
C. The code compiles successfully, and two bytecode files are generated: Ostrich.class and Ostrich$OstrichWrangler.class.
D. A compiler error occurs on line 3.
E. A compiler error occurs on line 5.

**My Answer: E**
**Correct Answer: E**

**The OstrichWrangler class is a static nested class; therefore, it cannot access the instance member count. For this reason, line 5 does not compile, and option E is correct.**

---

17.  Which lines of the following interface declarations do not compile? (Choose all that apply.)

```java
1: public interface Omnivore {
2: int amount = 10;
3: static boolean gather = true;
4: static void eatGrass() {}
5: int findMore() { return 2; }
6: default float rest() { return 2; }
7: protected int chew() { return 13; }
8: private static void eatLeaves() {}
9: }
```

A. All of the lines compile without issue.
B. Line 2
C. Line 3
D. Line 4
E. Line 5
F. Line 6
G. Line 7
H. Line 8

**My Answer: E,G**
**Correct Answer: E,G**

**Lines 2 and 3 compile with interface variables implicitly public, static, and final. Line 4 also compiles, as static methods are implicitly public. Line 5 does not compile, making option E correct. Non-static interface methods with a body must be explicitly marked private or default. Line 6 compiles, with the public modifier being added by the compiler. Line 7 does not compile, as interfaces do not have protected members, making option G correct. Finally, line 8 compiles without issue.**

---

18. What is printed by the following program?

```java
public class Deer {
enum Food {APPLES, BERRIES, GRASS}
protected class Diet {
private Food getFavorite() {
return Food.BERRIES;
}
}
public static void main(String[] seasons) {
System.out.print(switch(new Diet().getFavorite()) {
case APPLES -> "a";
case BERRIES -> "b";
default -> "c";
});
} }
```

A. a
B. b
C. c
D. The code declaration of the Diet class does not compile.
E. The main() method does not compile.
F. The code compiles but produces an exception at runtime.
G. None of the above

**My Answer: B**
**Correct Answer: E**

**Diet is an inner class, which requires an instance of Deer to instantiate. Since the main() method is static, there is no such instance. Therefore, the main() method does not compile, and option E is correct**

---

19. Which of the following are printed by the Bear program? (Choose all that apply.)

```JAVA
public class Bear {
enum FOOD {
BERRIES, INSECTS {
public boolean isHealthy() { return true; }},
FISH, ROOTS, COOKIES, HONEY;
public abstract boolean isHealthy();
}
public static void main(String[] args) {
System.out.print(FOOD.INSECTS);
System.out.print(FOOD.INSECTS.ordinal());
System.out.print(FOOD.INSECTS.isHealthy());
System.out.print(FOOD.COOKIES.isHealthy());
}
}
```

A. insects
B. INSECTS
C. 0
D. 1
E. false
F. true
G. The code does not compile.

**My Answer: G**
**Correct Answer: G**



---

20. Which statements about polymorphism and method inheritance are correct? (Choose all that apply.)
A. Given an arbitrary instance of a class, it cannot be determined until runtime which overridden method will be executed in a parent class.
B. It cannot be determined until runtime which hidden method will be executed in a parent class.
C. Marking a method static prevents it from being overridden or hidden.
D. Marking a method final prevents it from being overridden or hidden.
E. The reference type of the variable determines which overridden method will be called at runtime.
F. The reference type of the variable determines which hidden method will be called at runtime.

**My Answer: A,D,F**
**Correct Answer: A,D,F**

**Polymorphism is the property of an object to take on many forms. Part of polymorphism is that methods are replaced through overriding wherever they are called, regardless of whether they’re in a parent or child class. For this reason, option A is correct, and option E is incorrect. With hidden static methods, Java relies on the location and reference type to determine which method is called, making option B incorrect and option F correct. Finally, making a method final, not static, prevents it from being overridden, making option D correct and option C incorrect.**

---

21. Given the following record declaration, which lines of code can fill in the blank and allow the code to compile? (Choose all that apply.)

```java
public record RabbitFood(int size, String brand, LocalDate expires) {
public static int MAX_STORAGE = 100;
public RabbitFood() {
???;
}
}
```

A. size = MAX_STORAGE
B. this.size = 10
C. if(expires.isAfter(LocalDate.now())) throw new
RuntimeException()
D. if(brand== null) super.brand = "Unknown"
E. throw new RuntimeException()
F. None of the above

**My Answer: A,C,F**
**Correct Answer: F**

**==The record defines an overloaded constructor using parentheses, not a compact one. For this reason, the first line must be a call to another constructor, such as this(500, "Acme", LocalDate.now())==. For this reason, the code does not compile and option F is correct**

---

22. Which of the following can be inserted in the rest() method? (Choose all that apply.)

```JAVA
public class Lion {
class Cub {}
static class Den {}
static void rest() {
???;
} }
```

A. Cub a = Lion.new Cub()
B. Lion.Cub b = new Lion().Cub()
C. Lion.Cub c = new Lion().new Cub()
D. var d = new Den()
E. var e = Lion.new Cub()
F. Lion.Den f = Lion.new Den()
G. Lion.Den g = new Lion.Den()
H. var h = new Cub()

**My Answer: C,D,H**
**Correct Answer: C,D,G**

**Option C correctly creates an instance of an inner class Cub using an instance of the outer class Lion. Options A, B, E, and H use incorrect syntax for creating an instance of the Cub class. Options D and G correctly create an instance of the static nested Den class, which does not require an instance of Lion, while option F uses invalid syntax.**

---

23. Given the following program, what can be inserted into the blank line that would allow it to print Swim! at runtime?

```java
interface Swim {
default void perform() { System.out.print("Swim!"); }
}
interface Dance {
default void perform() { System.out.print("Dance!"); }
}
public class Penguin implements Swim, Dance {
public void perform() { System.out.print("Smile!"); }
private void doShow() {
;
}
public static void main(String[] eggs) {
new Penguin().doShow();
}
}
```

A. super.perform()
B. Swim.perform()
C. super.Swim.perform()
D. Swim.super.perform()
E. The code does not compile regardless of what is inserted into the blank.
F. The code compiles, but due to polymorphism, it is not possible to produce the requested
output without creating a new object.

**My Answer: D**
**Correct Answer: D**

**if a class or interface inherits two interfaces containing default methods with the same signature, it must override the method with its own implementation. The Penguin class does this correctly, so option E is incorrect. The way to access an inherited default method is by using the syntax Swim.super.perform(), making option D correct**

---

24. Which lines of the following interface do not compile? (Choose all that apply.)

```JAVA
1: public interface BigCat {
2: abstract String getName();
3: static int hunt() { getName(); return 5; }
4: default void climb() { rest(); }
5: private void roar() { getName(); climb(); hunt(); }
6: private static boolean sneak() { roar(); return true; }
7: private int rest() { return 2; };
8: }
```

A. Line 2
B. Line 3
C. Line 4
D. Line 5
E. Line 6
F. Line 7
G. None of the above

**My Answer: B,E**
**Correct Answer: B,E**

**Line 3 does not compile because the static method hunt() cannot access an abstract instance method getName(), making option B correct. Line 6 does not compile because the private static method sneak() cannot access the private instance method roar(), making option E correct. The rest of the lines compile without issue.**

---

25. What does the following program print?

```java
1: public class Zebra {
2: private int x = 24;
3: public int hunt() {
4: String message = "x is ";
5: abstract class Stripes {
6: private int x = 0;
7: public void print() {
8: System.out.print(message + Zebra.this.x);
9: }
10: }
11: var s = new Stripes() {};
12: s.print();
13: return x;
14: }
15: public static void main(String[] args) {
16: new Zebra().hunt();
17: } }
```

A. x is 0
B. x is 24
C. Line 6 generates a compiler error.
D. Line 8 generates a compiler error.
E. Line 11 generates a compiler error.
F. None of the above

**My Answer: A**
**Correct Answer: B**

**Zebra.this.x is the correct way to refer to x in the Zebra class. Line 5 defines an abstract local class within a method, while line 11 defines a concrete anonymous class that extends the Stripes class. The code compiles without issue and prints x is 24 at runtime, making option B the correct answer.**

---

26.   Which statements about the following enum are true? (Choose all that apply.)

```JAVA
1: public enum Animals {
2: MAMMAL(true), INVERTEBRATE(Boolean.FALSE), BIRD(false),
3: REPTILE(false), AMPHIBIAN(false), FISH(false) {
4: public int swim() { return 4; }
5: }
6: final boolean hasHair;
7: public Animals(boolean hasHair) {
8: this.hasHair = hasHair;
9: }
10: public boolean hasHair() { return hasHair; }
11: public int swim() { return 0; }
12: }
```

A. Compiler error on line 2
B. Compiler error on line 3
C. Compiler error on line 7
D. Compiler error on line 8
E. Compiler error on line 10
F. Compiler error on another line
G. The code compiles successfully.

**My Answer: C,F**
**Correct Answer: C,F**

**Enums are required to have a semicolon (;) after the list of values if there is anything else in the enum. Don’t worry; you won’t be expected to track down missing semicolons on the whole exam—only on enum questions. For this reason, line 5 should have a semicolon after it since it is the end of the list of enums, making option F correct. Enum constructors are implicitly private, making option C correct as well. The rest of the enum compiles without issue.**

---

27. Assuming a record is defined with at least one field, which components does the compiler always insert, each of which may be overridden or redeclared? (Choose all that apply.)
A. A no-argument constructor
B. An accessor method for each field
C. The toString() method
D. The equals() method
E. A mutator method for each field
F. A sort method for each field
G. The hashCode() method

**My Answer: B,C,D,G**
**Correct Answer: B,C,D,G**


---

28. Which of the following classes and interfaces do not compile? (Choose all that apply.)

```java
public abstract class Camel { void travel(); }
public interface EatsGrass { private abstract int chew(); }
public abstract class Elephant {
abstract private class SleepsAlot {
abstract int sleep();
} }
public class Eagle { abstract soar(); }
public interface Spider { default void crawl() {} }
```

A. Camel
B. EatsGrass
C. Elephant
D. Eagle
E. Spider
F. None of the classes or interfaces compile.

**My Answer: B,D,E**
**Correct Answer: A,B,D**

**Camel does not compile because the travel() method does not declare a body, nor is it marked abstract, making option A correct. EatsGrass also does not compile because an interface method cannot be marked both private and abstract, making option B correct. Finally, Eagle does not compile because it declares an abstract method soar() in a concrete class, making option D correct. The other classes compile without issue.**

---

29. How many lines of the following program contain a compilation error?

```JAVA
1: class Primate {
2: protected int age = 2;
3: { age = 1; }
4: public Primate() {
5: this().age = 3;
6: }
7: }
8: public class Orangutan {
9: protected int age = 4;
10: { age = 5; }
11: public Orangutan() {
12: this().age = 6;
13: }
14: public static void main(String[] bananas) {
15: final Primate x = (Primate)new Orangutan();
16: System.out.println(x.age);
17: }
18: }
```

A. None, and the program prints 1 at runtime.
B. None, and the program prints 3 at runtime.
C. None, but it causes a ClassCastException at runtime.
D. 1
E. 2
F. 3
G. 4

**My Answer: F**
**Correct Answer: F**

**The code does not compile, so options A through C are incorrect. Both lines 5 and 12 do not compile, as this() is used instead of this. Remember, this() refers to calling a constructor, whereas this is a reference to the current instance. Next, the compiler does not allow casting to an unrelated class type. Since Orangutan is not a subclass of Primate, the cast on line 15 is invalid, and the code does not compile. Due to these three lines containing compilation errors, option F is the correct answer.**

---

30. Assuming the following classes are declared as top-level types in the same file, which classes contain compiler errors? (Choose all that apply.)

```JAVA
sealed class Bird {
public final class Flamingo extends Bird {}
}
sealed class Monkey {}
class EmperorTamarin extends Monkey {}
non-sealed class Mandrill extends Monkey {}
sealed class Friendly extends Mandrill permits Silly {}
final class Silly {}
```

A. Bird
B. Monkey
C. EmperorTamarin
D. Mandrill
E. Friendly
F. Silly
G. All of the classes compile without issue.

**My Answer: G**
**Correct Answer: C,E**
 
 **Bird and its nested Flamingo subclass compile without issue. The permits clause is optional if the subclass is nested or declared in the same file. For this reason, Monkey and its subclass Mandrill also compile without issue. ==EmperorTamarin does not compile, as it is missing a non-sealed, sealed, or final modifier, making option C correct==. ==Friendly also does not compile, since it lists a subclass Silly that does not extend it, making option E correct==. While the permits clause is optional, the extends clause is not. Silly compiles just fine. Even though it does not extend Friendly, the compiler error is in the sealed class.**

---


# Chapter 8 - Lambdas and Functional Interfaces #Chapter

## Writing Simple Lambdas

Functional programming is a way of writing code more declaratively. You specify what you want to do rather than dealing with the state of objects. You focus more on expressions than loops.

Functional programming uses lambda expressions to write code. A lambda expression is a block of code that gets passed around. a lambda expression as an unnamed method existing inside an anonymous class. **==It has parameters and a body just like full-fledged methods do, but it doesn’t have a name like a real method.==**
### Looking at a Lambda Example

```java
public record Animal(String species, boolean canHop, boolean canSwim) { }

public interface CheckTrait {
	boolean test(Animal a);
}

public class CheckIfHopper implements CheckTrait {
	public boolean test(Animal a) {
		return a.canHop();
	}
}
```

This is part of the problem that lambdas solve

```java
1: import java.util.*;
public class TraditionalSearch {  
    public static void main(String[] args) {  
  
        // list of animals  
        var animals = new ArrayList<Animal>();  
        animals.add(new Animal("fish", false, true));  
        animals.add(new Animal("kangaroo", true, false));  
        animals.add(new Animal("rabbit", true, false));  
        animals.add(new Animal("turtle", false, true));  
  
        // pass class that does check  
        print(animals, new CheckIfHopper());  
  
        print(animals, new CheckIfSwims());  
  
        print(animals, a -> a.canHop());  
  
        print(animals, a -> a.canSwim());  
  
        print(animals, a -> !a.canSwim());  
  
    }  
  
    private static void print(List<Animal> animals, CheckTrait checker) {  
        for (Animal animal : animals) {  
// General check  
            if (checker.test(animal))  
                System.out.print(animal + " ");  
        }  
        System.out.println();  
    }  
}```

What happens if we want to print the ``Animals`` that swim? Sigh. We need to write another class, ``CheckIfSwims``. Granted, it is only a few lines, but it is a whole new file.

```java
13: print(animals, a -> a.canHop());
```

We only have to add one line of code—no need for an extra class to do something simple. Here’s that other line:

```java
13: print(animals, a -> a.canSwim());
// ...
13: print(animals, a -> !a.canSwim());
```

The point is that it is really easy to write code that uses lambdas once you get the basics in place. **==This code uses a concept called deferred execution. Deferred execution means that code is specified now but will run later.==**
### Learning Lambda Syntax

One of the simplest lambda expressions is

```java
a -> a.canHop()
```

**==Lambdas work with interfaces that have exactly one abstract method.==** **==Java relies on *context* when figuring out what lambda expressions mean. Context refers to where and how the lambda is interpreted.==**

```java
print(animals, a -> a.canHop());
```

The ``print()`` method expects a ``CheckTrait`` as the second parameter:

```java
private static void print(List<Animal> animals, CheckTrait checker) { ... }
```

Since we are passing a lambda instead, Java tries to map our lambda to the abstract method declaration in the ``CheckTrait`` interface:

```java
boolean test(Animal a);
```

Since that interface’s method takes an ``Animal``, the lambda parameter has to be an ``Animal``. And since that interface’s method returns a ``boolean``, we know the lambda returns a ``boolean``.

```java
a -> a.canHop()
(Animal a) -> { return a.canHop(); } // Identical !
```

The first example, shown in Figure 8.1, has three parts:

![[Pasted image 20240402190013.png]]

-  ==**A single parameter specified with the name a**==
-  ==**The arrow operator (->) to separate the parameter and body**==
-  ==**A body that calls a single method and returns the result of that method==**


The second example shows the most verbose form of a lambda that returns a ``boolean`` in Figure 8.2

![[Pasted image 20240402190127.png]]

-  ==**A single parameter specified with the name a and stating that the type is ``Animal``**==
-  ==**The arrow operator (->) to separate the parameter and body**==
-  ==**A body that has one or more lines of code, including a semicolon and a ``return`` statement==**

**==The parentheses around the lambda parameters can be omitted only if there is a single parameter and its type is not explicitly stated. We can omit braces when we have only a single statement. Java allows you to omit a ``return`` statement and semicolon ``(;)`` when no braces are used.==** This special shortcut doesn’t work when you have two or more statements.

The syntax in Figure 8.1 and Figure 8.2 can be mixed and matched.

```java
a -> { return a.canHop(); }
(Animal a) -> a.canHop()
```

---

**fun fact:`` s -> {}`` is a valid lambda. If there is no code on the right side of the expression, you don’t need the semicolon or return statement.** #TIP 

---

![[Pasted image 20240402191012.png]]

The final two rows take two parameters and ignore one of them—there isn’t a rule that says you must use all defined parameters.

![[Pasted image 20240402191042.png]]

Remember that the parentheses are optional only when there is one parameter and it doesn’t have a type declared.

---

**Assigning Lambdas to ``var``**

```java
var invalid = (Animal a) -> a.canHop(); // DOES NOT COMPILE
```

**Java inferring information about the lambda from the context? Well, ``var`` assumes the type based on the context as well. There’s not enough context here! ==Neither the lambda nor ``var`` have enough information to determine what type of functional interface should be used==.**

----
## Coding Functional Interfaces

**==A functional interface is an interface that contains a single abstract method.==**
###  Defining a Functional Interface

```java
@FunctionalInterface
public interface Sprint {
	public void sprint(int speed);
}
public class Tiger implements Sprint {
	public void sprint(int speed) {
		System.out.println("Animal is sprinting fast! " + speed);
	}
}
```

the ``Sprint`` interface is a functional interface because it contains exactly one abstract method, and the ``Tiger`` class is a valid class that implements the interface.

---
**The ``@FunctionalInterface`` Annotation**

**The ``@FunctionalInterface`` annotation tells the compiler that you intend for the code to be a functional interface. If the interface does not follow the rules for a functional interface, the compiler will give you an error**

```java
@FunctionalInterface
public interface Dance { // DOES NOT COMPILE
	void move();
	void rest();
}
```

**Java includes ``@FunctionalInterface`` on some, but not all, functional interfaces. This annotation means the authors of the interface promise it will be safe to use in a lambda in the future. However, just because you don’t see the annotation doesn’t mean it’s not a functional interface. Remember that having exactly one abstract method is what makes it a functional interface, not the annotation.**

---

```java
public interface Dash extends Sprint {}
public interface Skip extends Sprint {
	void skip();
}
public interface Sleep {
	private void snore() {}
	default int getZzz() { return 1; }
}
public interface Climb {
	void reach();
	default void fall() {}
	static int getBackUp() { return 100; }
	private static boolean checkHeight() { return true; }
}
```

- The ``Dash`` interface is a functional interface because it extends the ``Sprint`` interface and inherits the single abstract method ``sprint()``.
- The ``Skip`` interface is not a valid functional interface because it has two abstract methods: the inherited ``sprint()`` method and the declared ``skip()`` method.
- The ``Sleep`` interface is also not a valid functional interface. Neither ``snore()`` nor ``getZzz()`` meets the criteria of a single abstract method. **==Even though default methods function like abstract methods, in that they can be overridden in a class implementing the interface, they are insufficient for satisfying the single abstract method requirement.==**
- the ``Climb`` interface is a functional interface. Despite defining a slew of methods, it contains only one abstract method: ``reach()``.

### Adding Object Methods

All classes inherit certain methods from ``Object``.

-  `public String toString()`
-  `public boolean equals(Object)`
-  `public int hashCode()`

**==there is one exception to the single abstract method rule that you should be familiar with. If a functional interface includes an ``abstract`` method with the same signature as a ``public`` method found in ``Object``, those methods do not count toward the single abstract method test.==** The motivation behind this rule is that any class that implements the interface will inherit from ``Object``, as all classes do, and therefore always implement these methods.

---

**Since Java assumes all classes ``extend`` from ``Object``, you also cannot declare an interface method that is incompatible with Object. For example, declaring an abstract method ``int toString()`` in an interface would not compile since Object’s version of the method returns a ``String``.**

---

```java
public interface Soar {
	abstract String toString(); // Not functional interface
}
```

Since ``toString()`` is a public method implemented in ``Object``, it does not count toward the single abstract method test

```java
public interface Dive {
	String toString();
	public boolean equals(Object o);
	public abstract int hashCode();
	public void dive(); // Functional Interface
}
```

The ``dive()`` method is the single ``abstract`` method, while the others are not counted since they are ``public`` methods defined in the ``Object`` class.

Be wary of examples that resemble methods in the ``Object`` class but are not actually defined in the ``Object`` class

```java
public interface Hibernate {
	String toString();
	public boolean equals(Hibernate o);
	public abstract int hashCode();
	public void rest();
}
```

Despite looking a lot like our ``Dive`` interface, the ``Hibernate`` interface uses ``equals(Hibernate)`` instead of ``equals(Object)``. Because this does not match the method signature of the ``equals(Object)`` method defined in the ``Object`` class, this interface is counted as containing two abstract methods: ``equals(Hibernate)`` and ``rest()``
## Using Method References

Method references are another way to make the code easier to read, such as simply mentioning the name of the method.

```java
public interface LearnToSpeak {
	void speak(String sound);
}

	public class DuckHelper {
	public static void teacher(String name, LearnToSpeak trainer) {
		// Exercise patience (omitted)
		trainer.speak(name);
	}
}

public class Duckling {
	public static void makeSound(String sound) {
		LearnToSpeak learner = s -> System.out.println(s);
		DuckHelper.teacher(sound, learner);
	}
}
```

There’s a bit of redundancy, though. The lambda declares one parameter named ``s``. However, it does nothing other than pass that parameter to another method. A method reference lets us remove that redundancy and instead write this:

```java
LearnToSpeak learner = System.out::println;
```

The ``::`` operator tells Java to call the ``println()`` method later

**==A method reference and a lambda behave the same way at runtime==**. You can pretend the compiler turns your method references into lambdas for you. There are four formats for method references:

-  ==**static methods**==
-  ==**Instance methods on a particular object**==
-  ==**Instance methods on a parameter to be determined at runtime**==
-  ==**Constructors==**

### Calling ``static`` Methods

```java
interface Converter {
	long round(double num);
}
```

can implement this interface with the ``round()`` method in ``Math``. Here we assign a method reference and a lambda to this functional interface:

```java
14: Converter methodRef = Math::round;
15: Converter lambda = x -> Math.round(x);
16:
17: System.out.println(methodRef.round(100.1)); // 100
```

On line 14, we reference a method with one parameter, and Java knows that it’s like a lambda with one parameter. Additionally, Java knows to pass that parameter to the method. With both lambdas and method references, Java infers information from the *context*. **==Java looks for a method that matches that description. If it can’t find it or finds multiple matches, then the compiler will report an error. The latter is sometimes called an ambiguous type error.==**

```java
public class CallingStaticMethods {  
  
    public static void main(String[] args) {  
  
        Converter methodRef = Math::round;  
        Converter lambda = x -> Math.round(x);  
        Converter lambda2 = (double x) -> Math.round(x);  
        Converter methodRef2 = StaticMethodRef::deferred;  
  
        System.out.println(methodRef.round(101.1));  
        System.out.println(lambda.round(101.1));  
        System.out.println(methodRef2.round(101.1));  
  
        GreetingInterface greetingInterfaceMethodRef = StaticMethodRef::printMessage;  
  
        GreetingInterface greetingInterfaceLamda = () -> StaticMethodRef.printMessage();  
  
        greetingInterfaceMethodRef.message();  
        greetingInterfaceLamda.message();  
  
        // GreetingInterface greetingInterfaceLamda2 =  -> StaticMethodRef.printMessage(); // DOES NOT COMPILE  
        // GreetingInterface greetingInterfaceLamda3 =  x -> StaticMethodRef.printMessage(); // DOES NOT COMPILE  
        GreetingInterface greetingInterfaceLambda4 = () -> StaticMethodRef.printMessageV2();  
        GreetingInterface greetingInterfaceLambda5 = () -> {  
            StaticMethodRef.printMessageV2();  
        };  
        // GreetingInterface greetingInterfaceLambda6 = () -> { return StaticMethodRef.printMessageV2(); }; // DOES NOT COMPILE  
        GreetingInterface greetingInterfaceMethodRef2 = StaticMethodRef::printMessageV2;  
  
        GreetingInterface greetingInterfaceLambda7 = () -> StaticMethodRef.printMessageV3("hello printMessageV3");  
        // GreetingInterface greetingInterfaceMethodRef3 = StaticMethodRef::printMessageV3; // DOES NOT COMPILE  
  
        greetingInterfaceMethodRef2.message();  
        greetingInterfaceLambda4.message();  
        greetingInterfaceLambda5.message();  
        greetingInterfaceLambda7.message();  
    }  
  
}  
  
class StaticMethodRef {  
  
    static long deferred(double num) {  
        return (long) (num * 2);  
    }  
  
    static void printMessage() {  
        System.out.println("hello printMessage!");  
    }  
  
    static String printMessageV2() {  
        String message = "hello printMessageV2";  
        System.out.println(message);  
        return message;  
    }  
      
    static void printMessageV3(String message) {  
        System.out.println(message);  
    }  
}
```

### Calling Instance Methods on a Particular Object

```java
interface StringStart {
	boolean beginningCheck(String prefix);
}

18: var str = "Zoo";
19: StringStart methodRef = str::startsWith;
20: StringStart lambda = s -> str.startsWith(s);
21:
22: System.out.println(methodRef.beginningCheck("A")); // false
```

Line 19 shows that we want to call ``str.startsWith()`` and pass a single parameter to be supplied at runtime.
**==A method reference doesn’t have to take any parameters.==**

```java
interface StringChecker {
	boolean check();
}

18: var str = "";
19: StringChecker methodRef = str::isEmpty;
20: StringChecker lambda = () -> str.isEmpty();
21:
22: System.out.print(methodRef.check()); // true
```

Since the method on ``String`` is an instance method, we call the method reference on an instance of the ``String`` class. While all method references can be turned into lambdas, the opposite is not always true.

```java
var str = "";
StringChecker lambda = () -> str.startsWith("Zoo");

StringChecker methodReference = str::startsWith; // DOES NOT COMPILE
StringChecker methodReference = str::startsWith("Zoo"); // DOES NOT COMPILE
```

```java
public class CallingInstanceMethodsOnAParticularObject {  
  
    public static void main(String[] args) {  
  
        exampleMethod1StringStart();  
  
        exampleMethod2StringStart();  
  
        exampleMethod3StringStart();  
  
        var callingInstanceMethodsOnAParticularObject = new CallingInstanceMethodsOnAParticularObject();  
        callingInstanceMethodsOnAParticularObject.exampleMethod4StringStart();  
  
        exampleMethod1StringChecker();  
  
        exampleMethod2StringChecker();  
  
        exampleMethod3StringChecker();  
  
        exampleMethod1Calculator();  
    }  
  
    private static MyClass myClassStaticVariable = new MyClass();  
    private MyClass myClassInstanceVariable = new MyClass();  
  
    private static void exampleMethod1StringStart() {  
        System.out.println("### exampleMethod1StringStart ###");  
  
        var str = "Zoo";  
        StringStart methodRef = str::startsWith;  
        StringStart lambda = s -> str.startsWith(s);  
  
        System.out.println(methodRef.beginningCheck("A"));  
        System.out.println(lambda.beginningCheck("A"));  
    }  
  
    private static void exampleMethod2StringStart() {  
  
        System.out.println("### exampleMethod2StringStart ###");  
  
        StringStart stringStart1 = MyClass::staticMethod;  
        StringStart stringStart2 = new MyClass()::instanceMethod;  
        MyClass myClassRef = new MyClass();  
        StringStart stringStart3 = myClassRef::instanceMethod;  
        // Static method referenced through non-static qualifier  
        //StringStart stringStart4 = myClassRef::staticMethod; // DOES NOT COMPILE        StringStart stringStart5 = ss -> myClassRef.instanceMethod(ss);  
        StringStart stringStart6 = ss -> MyClass.staticMethod(ss);  
  
        System.out.println(stringStart1.beginningCheck("MyClass"));  
        System.out.println(stringStart2.beginningCheck("MyClass"));  
        System.out.println(stringStart3.beginningCheck("MyClass"));  
        System.out.println(stringStart5.beginningCheck("MyClass"));  
        System.out.println(stringStart6.beginningCheck("MyClass"));  
    }  
  
    private static void exampleMethod3StringStart() {  
  
        System.out.println("### exampleMethod3StringStart ###");  
  
        StringStart stringStart1 = myClassStaticVariable::instanceMethod;  
        //StringStart stringStart2 = myClassInstanceVariable::instanceMethod; // DOES NOT COMPILE  
  
        //Static method referenced through non-static qualifier        // StringStart stringStart3 = myClassStaticVariable::staticMethod; // DOES NOT COMPILE        StringStart stringStart4 = MyClass::staticMethod;  
  
        System.out.println(stringStart1.beginningCheck("MyClass"));  
    }  
  
    private void exampleMethod4StringStart() {  
  
        System.out.println("### exampleMethod4StringStart ###");  
  
        StringStart stringStart1 = myClassStaticVariable::instanceMethod;  
        StringStart stringStart2 = myClassInstanceVariable::instanceMethod;  
  
        // Static method referenced through non-static qualifier  
        // StringStart stringStart3 = myClassStaticVariable::staticMethod; // DOES NOT COMPILE        // StringStart stringStart4 = myClassStaticVariable::staticMethod; // DOES NOT COMPILE  
        StringStart stringStart5 = MyClass::staticMethod;  
  
        System.out.println(stringStart1.beginningCheck("MyClass"));  
        System.out.println(stringStart2.beginningCheck("MyClass"));  
        System.out.println(stringStart5.beginningCheck("MyClass"));  
    }  
  
    private static void exampleMethod1StringChecker() {  
  
        System.out.println("### exampleMethod1StringChecker ###");  
  
        var str = "";  
        StringChecker methodRef = str::isEmpty;  
        StringChecker lambda = () -> str.isEmpty();  
  
        System.out.println(methodRef.check());  
        System.out.println(lambda.check());  
    }  
  
    private static void exampleMethod2StringChecker() {  
  
        System.out.println("### exampleMethod2StringChecker ###");  
  
        MyClassEmptyCheck myClassEmptyCheck = new MyClassEmptyCheck();  
  
        StringChecker stringChecker1 = myClassEmptyCheck::instanceMethod;  
        StringChecker stringChecker2 = MyClassEmptyCheck::staticMethod;  
  
        System.out.println(stringChecker1.check());  
        System.out.println(stringChecker2.check());  
    }  
  
    private static void exampleMethod3StringChecker() {  
  
        System.out.println("### exampleMethod3StringChecker ###");  
  
        var str = "";  
        StringChecker lambda = () -> str.startsWith("Zoo");  
        //StringChecker lambda2 = s -> str.startsWith("Zoo"); // DOES NOT COMPILE  
        //StringChecker lambda3 = (String s) -> str.startsWith("Zoo"); // DOES NOT COMPILE  
        System.out.println(lambda.check());  
  
        // StringChecker methodReference = str::startsWith; // DOES NOT COMPILE  
        // StringChecker methodReference = str::startsWith ("Zoo"); // DOES NOT COMPILE    }  
  
    private static void exampleMethod1Calculator() {  
  
        System.out.println("### exampleMethod1Calculator ###");  
  
        Calculator lambda1 = (i, j) -> i * j;  
        Calculator lambda2 = (int i, int j) -> i + j;  
  
        // Incompatible parameter types in lambda expression: expected int but found Integer  
        //Calculator lambda3 = (Integer i, Integer j) -> i + j; // DOES NOT COMPILE  
        Calculator lambda4 = (var i, var j) -> i / j;  
        Calculator lambda5 = (int i, int j) -> {  
            return i - j;  
        };  
  
        CalculatorHelper calculatorHelper = new CalculatorHelper();  
        Calculator lambda6 = (int i, int j) -> calculatorHelper.sum(i, j);  
        Calculator lambda7 = (int i, int j) -> calculatorHelper.multiply(i, j);  
        Calculator lambda8 = (int i, int j) -> CalculatorHelper.subtraction(i, j);  
  
        Calculator methodReference1 = calculatorHelper::sum;  
        Calculator methodReference2 = calculatorHelper::multiply;  
  
        //Static method referenced through non-static qualifier  
        //Calculator methodReference3 = calculatorHelper::subtraction; // DOES NOT COMPILE        Calculator methodReference4 = CalculatorHelper::subtraction;  
  
        System.out.println(lambda1.calculate(10, 5));  
        System.out.println(lambda2.calculate(10, 5));  
        System.out.println(lambda4.calculate(10, 5));  
        System.out.println(lambda5.calculate(10, 5));  
        System.out.println(lambda6.calculate(10, 5));  
        System.out.println(lambda7.calculate(10, 5));  
        System.out.println(lambda8.calculate(10, 5));  
  
        System.out.println(methodReference1.calculate(10, 5));  
        System.out.println(methodReference2.calculate(10, 5));  
    }  
  
}  
  
  
class MyClass {  
  
    boolean instanceMethod(String str) {  
        return str.startsWith("My");  
    }  
  
    static boolean staticMethod(String str) {  
        return str.startsWith("My");  
    }  
}  
  
class MyClassEmptyCheck {  
    boolean instanceMethod() {  
        return "".isEmpty();  
    }  
  
    static boolean staticMethod() {  
        return "".isEmpty();  
    }  
}  
  
class CalculatorHelper {  
  
    int sum(int num1, int num2) {  
        return num1 + num2;  
    }  
  
    int multiply(int num1, int num2) {  
        return num1 * num2;  
    }  
  
    static int subtraction(int num1, int num2) {  
        return num1 - num2;  
    }  
}
```

### Calling Instance Methods on a Parameter

```java
interface StringParameterChecker {
	boolean check(String text);
}

23: StringParameterChecker methodRef = String::isEmpty;
24: StringParameterChecker lambda = s -> s.isEmpty();
25:
26: System.out.println(methodRef.check("Zoo")); // false
```

Line 23 says the method that we want to call is declared in ``String``. It looks like a ``static`` method, but it isn’t. Instead, Java knows that ``isEmpty()`` is an instance method that does not take any parameters. Java uses the parameter supplied at runtime as the instance on which the method is called.

can even combine the two types of instance method references.

```java
interface StringTwoParameterChecker {
	boolean check(String text, String prefix);
}
```

**==Pay attention to the parameter order when reading the implementation:==**

```java
26: StringTwoParameterChecker methodRef = String::startsWith;
27: StringTwoParameterChecker lambda = (s, p) -> s.startsWith(p);
28:
29: System.out.println(methodRef.check("Zoo", "A")); // false
```

Since the functional interface takes two parameters, Java has to figure out what they represent. The first one will always be the instance of the object for instance methods. Any others are to be method parameters.

line 26 may look like a ``static`` method, but it is really a method reference declaring that the instance of the object will be specified later. Line 27 shows some of the power of a method reference.

```java
public class CalingInstanceMethodsOnAParameter {  
  
    public static void main(String[] args) {  
  
        exampleMethodStringParameterChecker();  
  
        exampleMethodStringChecker();  
  
        exampleStringParameterCheckerHelperClass();  
  
        exampleHelperClassParameter();  
  
        exampleStringTwoParameterChecker();  
  
        exampleHelperClassParameter2();  
    }  
  
    private static void exampleMethodStringParameterChecker() {  
  
        System.out.println("### exampleMethodStringParameterChecker ###");  
  
        StringParameterChecker methodRef = String::isEmpty;  
        StringParameterChecker lambda = s -> s.isEmpty();  
        System.out.println(methodRef.check("Zoo"));  
        System.out.println(lambda.check("Zoo"));  
    }  
  
    private static void exampleMethodStringChecker() {  
  
        System.out.println("### exampleMethodStringChecker ###");  
  
        var str = "Zoo";  
  
        // StringParameterChecker methodRef = str::isEmpty; // DOES NOT COMPILE  
  
        StringChecker methodRef = str::isEmpty;  
        StringChecker lambda = () -> str.isEmpty();  
  
        System.out.println(methodRef.check());  
        System.out.println(lambda.check());  
    }  
  
    private static void exampleStringParameterCheckerHelperClass() {  
  
        System.out.println("### exampleStringParameterCheckerHelperClass ###");  
  
        StringParameterChecker stringParameterChecker1 = HelperClass::staticMethod;  
        StringParameterChecker stringParameterChecker2 = new HelperClass()::method;  
        HelperClass helperRef = new HelperClass();  
        StringParameterChecker stringParameterChecker3 = helperRef::method;  
        //Static method referenced through non-static qualifier  
        //StringParameterChecker stringParameterChecker4 = helperRef::staticMethod; // DOES NOT COMPILE  
        StringParameterChecker stringParameterChecker4 = s -> helperRef.method(s);  
        StringParameterChecker stringParameterChecker5 = (String s) -> HelperClass.staticMethod(s);  
        StringParameterChecker stringParameterChecker6 = (String s) -> true;  
  
        System.out.println(stringParameterChecker1.check("abc"));  
        System.out.println(stringParameterChecker2.check("abc"));  
        System.out.println(stringParameterChecker3.check("abc"));  
        System.out.println(stringParameterChecker4.check("abc"));  
        System.out.println(stringParameterChecker5.check("abc"));  
    }  
  
  
    private static void exampleHelperClassParameter() {  
  
        System.out.println("### exampleHelperClassParameter ###");  
  
        MyInterface lambda1 = hcp -> hcp.isNull();  
        MyInterface lambda2 = (HelperClassParameter hcp) -> hcp.isNull();  
        MyInterface lambda3 = (HelperClassParameter hcp) -> false;  
  
        MyInterface methodReference = HelperClassParameter::isNull;  
  
        System.out.println(lambda1.method(new HelperClassParameter()));  
        System.out.println(lambda2.method(new HelperClassParameter()));  
        System.out.println(lambda3.method(new HelperClassParameter()));  
  
        System.out.println(methodReference.method(new HelperClassParameter()));  
    }  
  
    private static void exampleStringTwoParameterChecker() {  
  
        System.out.println("### exampleStringTwoParameterChecker ###");  
  
        StringTwoParameterChecker lambda = (s, p) -> s.startsWith(p);  
        StringTwoParameterChecker lambda2 = (String s, String p) -> true;  
        StringTwoParameterChecker methodRef = String::startsWith;  
  
        System.out.println(methodRef.check("Zoo", "Z"));  
        System.out.println(lambda.check("Zoo", "A"));  
        System.out.println(lambda2.check("Zoo", "A"));  
    }  
  
  
    private static void exampleHelperClassParameter2() {  
  
        System.out.println("### exampleHelperClassParameter2 ###");  
  
        MyInterface2 lambda1 = (hpc, str) -> hpc.instanceMethod(str);  
        MyInterface2 lambda2 = (HelperClassParameter2 hpc, String str) ->  
        {  
            return hpc.instanceMethod(str);  
        };  
  
        MyInterface2 lambda3 = (HelperClassParameter2 hpc, String str) ->  
        {  
            return Integer.parseInt(str);  
        };  
  
        MyInterface2 lambda4 = (HelperClassParameter2 hpc, String str) ->  
        {  
            return new Random().nextInt();  
        };  
  
        MyInterface2 lambda5 = (hpc, str) -> 10;  
  
  
        MyInterface2 methodReference = HelperClassParameter2::instanceMethod;  
  
        // MyInterface2 methodReference2 = HelperClassParameter2::instanceMethod2; // DOES NOT COMPILE  
  
        // MyInterface2 methodReference3 = HelperClassParameter2::instanceMethod3; // DOES NOT COMPILE  
        // MyInterface2 methodReference4 = HelperClassParameter2::staticMethod; // DOES NOT COMPILE  
        MyInterface2 methodReference4 = HelperClassParameter2::staticMethod2;  
  
        System.out.println(lambda1.method(new HelperClassParameter2(), "100"));  
        System.out.println(lambda2.method(new HelperClassParameter2(), "100"));  
        System.out.println(lambda3.method(new HelperClassParameter2(), "100"));  
        System.out.println(lambda4.method(new HelperClassParameter2(), "100"));  
        System.out.println(methodReference.method(new HelperClassParameter2(), "100"));  
        System.out.println(methodReference4.method(new HelperClassParameter2(), "100"));  
  
    }  
}  
  
class HelperClass {  
  
    static boolean staticMethod(String str) {  
        return str.startsWith("a");  
    }  
  
    boolean method(String str) {  
        return str.startsWith("a");  
    }  
}  
  
interface MyInterface {  
    boolean method(HelperClassParameter hpc);  
}  
  
class HelperClassParameter {  
  
    boolean isNull() {  
        return this == null;  
    }  
}  
  
interface MyInterface2 {  
  
    Integer method(HelperClassParameter2 hpc, String str);  
}  
  
class HelperClassParameter2 {  
  
    Integer instanceMethod(String str) {  
        return Integer.parseInt(str);  
    }  
  
    Integer instanceMethod2(StringBuilder sb) {  
        return Integer.parseInt(sb.toString());  
    }  
  
    Integer instanceMethod3(String str, Integer number) {  
        return Integer.parseInt(str) + number;  
  
    }  
  
    static Integer staticMethod(String str) {  
        return Integer.parseInt(str);  
    }  
  
    static Integer staticMethod2(HelperClassParameter2 hpc, String str) {  
        return Integer.parseInt(str);  
    }  
  
}
```

### Calling Constructors

A constructor reference is a special type of method reference that uses ``new`` instead of a method and instantiates an object.

```java
interface EmptyStringCreator {
	String create();
}

30: EmptyStringCreator methodRef = String::new;
31: EmptyStringCreator lambda = () -> new String();
32:
33: var myString = methodRef.create();
34: System.out.println(myString.equals("Snake")); // false
```

```java
interface StringCopier {
	String copy(String value);
}
```

In the implementation, notice that line 32 in the following example has the same method reference as line 30 in the previous example:

```java
32: StringCopier methodRef = String::new;
33: StringCopier lambda = x -> new String(x);
34:
35: var myString = methodRef.copy("Zebra");
36: System.out.println(myString.equals("Zebra")); // true
```

This means you can’t always determine which method can be called by looking at the method reference. **==Instead, you have to look at the context to see what parameters are used and if there is a return type.==**

### Reviewing Method References

![[Pasted image 20240402200041.png]]

```java
public class CalingInstanceMethodsOnAParameter {  
  
    public static void main(String[] args) {  
  
        exampleMethodStringParameterChecker();  
  
        exampleMethodStringChecker();  
  
        exampleStringParameterCheckerHelperClass();  
  
        exampleHelperClassParameter();  
  
        exampleStringTwoParameterChecker();  
  
        exampleHelperClassParameter2();  
    }  
  
    private static void exampleMethodStringParameterChecker() {  
  
        System.out.println("### exampleMethodStringParameterChecker ###");  
  
        StringParameterChecker methodRef = String::isEmpty;  
        StringParameterChecker lambda = s -> s.isEmpty();  
        System.out.println(methodRef.check("Zoo"));  
        System.out.println(lambda.check("Zoo"));  
    }  
  
    private static void exampleMethodStringChecker() {  
  
        System.out.println("### exampleMethodStringChecker ###");  
  
        var str = "Zoo";  
  
        // StringParameterChecker methodRef = str::isEmpty; // DOES NOT COMPILE  
  
        StringChecker methodRef = str::isEmpty;  
        StringChecker lambda = () -> str.isEmpty();  
  
        System.out.println(methodRef.check());  
        System.out.println(lambda.check());  
    }  
  
    private static void exampleStringParameterCheckerHelperClass() {  
  
        System.out.println("### exampleStringParameterCheckerHelperClass ###");  
  
        StringParameterChecker stringParameterChecker1 = HelperClass::staticMethod;  
        StringParameterChecker stringParameterChecker2 = new HelperClass()::method;  
        HelperClass helperRef = new HelperClass();  
        StringParameterChecker stringParameterChecker3 = helperRef::method;  
        //Static method referenced through non-static qualifier  
        //StringParameterChecker stringParameterChecker4 = helperRef::staticMethod; // DOES NOT COMPILE  
        StringParameterChecker stringParameterChecker4 = s -> helperRef.method(s);  
        StringParameterChecker stringParameterChecker5 = (String s) -> HelperClass.staticMethod(s);  
        StringParameterChecker stringParameterChecker6 = (String s) -> true;  
  
        System.out.println(stringParameterChecker1.check("abc"));  
        System.out.println(stringParameterChecker2.check("abc"));  
        System.out.println(stringParameterChecker3.check("abc"));  
        System.out.println(stringParameterChecker4.check("abc"));  
        System.out.println(stringParameterChecker5.check("abc"));  
    }  
  
  
    private static void exampleHelperClassParameter() {  
  
        System.out.println("### exampleHelperClassParameter ###");  
  
        MyInterface lambda1 = hcp -> hcp.isNull();  
        MyInterface lambda2 = (HelperClassParameter hcp) -> hcp.isNull();  
        MyInterface lambda3 = (HelperClassParameter hcp) -> false;  
  
        MyInterface methodReference = HelperClassParameter::isNull;  
  
        System.out.println(lambda1.method(new HelperClassParameter()));  
        System.out.println(lambda2.method(new HelperClassParameter()));  
        System.out.println(lambda3.method(new HelperClassParameter()));  
  
        System.out.println(methodReference.method(new HelperClassParameter()));  
    }  
  
    private static void exampleStringTwoParameterChecker() {  
  
        System.out.println("### exampleStringTwoParameterChecker ###");  
  
        StringTwoParameterChecker lambda = (s, p) -> s.startsWith(p);  
        StringTwoParameterChecker lambda2 = (String s, String p) -> true;  
        StringTwoParameterChecker methodRef = String::startsWith;  
  
        System.out.println(methodRef.check("Zoo", "Z"));  
        System.out.println(lambda.check("Zoo", "A"));  
        System.out.println(lambda2.check("Zoo", "A"));  
    }  
  
  
    private static void exampleHelperClassParameter2() {  
  
        System.out.println("### exampleHelperClassParameter2 ###");  
  
        MyInterface2 lambda1 = (hpc, str) -> hpc.instanceMethod(str);  
        MyInterface2 lambda2 = (HelperClassParameter2 hpc, String str) ->  
        {  
            return hpc.instanceMethod(str);  
        };  
  
        MyInterface2 lambda3 = (HelperClassParameter2 hpc, String str) ->  
        {  
            return Integer.parseInt(str);  
        };  
  
        MyInterface2 lambda4 = (HelperClassParameter2 hpc, String str) ->  
        {  
            return new Random().nextInt();  
        };  
  
        MyInterface2 lambda5 = (hpc, str) -> 10;  
  
  
        MyInterface2 methodReference = HelperClassParameter2::instanceMethod;  
  
        // MyInterface2 methodReference2 = HelperClassParameter2::instanceMethod2; // DOES NOT COMPILE  
  
        // MyInterface2 methodReference3 = HelperClassParameter2::instanceMethod3; // DOES NOT COMPILE  
        // MyInterface2 methodReference4 = HelperClassParameter2::staticMethod; // DOES NOT COMPILE  
        MyInterface2 methodReference4 = HelperClassParameter2::staticMethod2;  
  
        System.out.println(lambda1.method(new HelperClassParameter2(), "100"));  
        System.out.println(lambda2.method(new HelperClassParameter2(), "100"));  
        System.out.println(lambda3.method(new HelperClassParameter2(), "100"));  
        System.out.println(lambda4.method(new HelperClassParameter2(), "100"));  
        System.out.println(methodReference.method(new HelperClassParameter2(), "100"));  
        System.out.println(methodReference4.method(new HelperClassParameter2(), "100"));  
  
    }  
}  
  
class HelperClass {  
  
    static boolean staticMethod(String str) {  
        return str.startsWith("a");  
    }  
  
    boolean method(String str) {  
        return str.startsWith("a");  
    }  
}  
  
interface MyInterface {  
    boolean method(HelperClassParameter hpc);  
}  
  
class HelperClassParameter {  
  
    boolean isNull() {  
        return this == null;  
    }  
}  
  
interface MyInterface2 {  
  
    Integer method(HelperClassParameter2 hpc, String str);  
}  
  
class HelperClassParameter2 {  
  
    Integer instanceMethod(String str) {  
        return Integer.parseInt(str);  
    }  
  
    Integer instanceMethod2(StringBuilder sb) {  
        return Integer.parseInt(sb.toString());  
    }  
  
    Integer instanceMethod3(String str, Integer number) {  
        return Integer.parseInt(str) + number;  
  
    }  
  
    static Integer staticMethod(String str) {  
        return Integer.parseInt(str);  
    }  
  
    static Integer staticMethod2(HelperClassParameter2 hpc, String str) {  
        return Integer.parseInt(str);  
    }  
  
}
```

## Working with Built-in Functional Interfaces

The core functional interfaces in Table 8.4 are provided in the ``java.util.function`` package.

**TABLE 8.4 Common functional interfaces**
![[Pasted image 20240403140214.png]]

### Implementing ``Supplier``

A ``Supplier`` is used when you want to generate or supply values without taking any input. The ``Supplier`` interface is defined as follows:

```java
@FunctionalInterface
public interface Supplier<T> {
    T get();
}

Supplier<LocalDate> s1 = LocalDate::now; 
Supplier<LocalDate> s2 = () -> LocalDate.now();

LocalDate d1 = s1.get(); 
LocalDate d2 = s2.get();
```

The ``LocalDate::now`` method reference is used to create a ``Supplier`` to assign to an intermediate variable ``s1``. A ``Supplier`` is often used when constructing new objects. We’ve been using generics to declare what type of Supplier we are using.

```java
Supplier<ArrayList<String>> s3 = ArrayList::new;
ArrayList<String> a1 = s3.get();
System.out.println(a1); // []
```

have a ``Supplier`` of a certain type. That type happens to be ``ArrayList<String>``. Then calling ``get()`` creates a new instance of ``ArrayList<String>``, which is the generic type of the ``Supplier``—in other words, a generic that contains another generic. Be sure to look at the code carefully when this type of thing comes up.
Notice how we called ``get()`` on the functional interface. What would happen if we tried to print out ``s3`` itself?

```java
System.out.println(s3); // functionalinterface.BuiltIns$$Lambda$1/0x0000000800066840@4909b8da
```

That’s the result of calling ``toString()`` on a lambda. 

```java
public class ImplementingSupplier {  
  
    public static void main(String[] args) {  
  
        localDateSupplierExample();  
        stringBuilderSupplierExample();  
        arrayListSupplierExample();  
        randomSupplierExample();  
        stringSupplierExample();  
        supplierHelperExample();  
    }  
  
    private static void localDateSupplierExample() {  
  
        System.out.println("### localDateSupplierExample ###");  
        Supplier<LocalDate> s1 = LocalDate::now;  
        Supplier<LocalDate> s2 = () -> LocalDate.now();  
  
        LocalDate d1 = s1.get();  
        LocalDate d2 = s2.get();  
  
        System.out.println(d1);  
        System.out.println(d2);  
    }  
  
    private static void stringBuilderSupplierExample() {  
  
        System.out.println("### stringBuilderSupplierExample ###");  
        Supplier<StringBuilder> s1 = StringBuilder::new;  
        Supplier<StringBuilder> s2 = () -> new StringBuilder();  
  
        System.out.println(s1.get());  
        System.out.println(s2.get());  
  
    }  
  
    private static void arrayListSupplierExample() {  
  
        System.out.println("### arrayListSupplierExample ###");  
        Supplier<ArrayList<String>> s1 = ArrayList::new;  
        Supplier<ArrayList<String>> s2 = () -> new ArrayList<>();  
  
        ArrayList<String> a1 = s1.get();  
        ArrayList<String> a2 = s2.get();  
        System.out.println(a1); // []  
        System.out.println(a2);  
  
        System.out.println(s1);  
  
    }  
  
    private static void randomSupplierExample() {  
  
        System.out.println("### randomSupplierExample ###");  
        Supplier<Double> s1 = () -> Math.random();  
        Supplier<Double> s2 = Math::random;  
        Supplier<Integer> s3 = new Random()::nextInt;  
        Supplier<Integer> s4 = () -> 10;  
  
        System.out.println(s1.get());  
        System.out.println(s2.get());  
        System.out.println(s3.get());  
        System.out.println(s4.get());  
    }  
  
    private static void stringSupplierExample() {  
  
        System.out.println("### stringSupplierExample ###");  
        Supplier<String> s1 = String::new;  
        Supplier<String> s2 = () -> "value";  
  
        // Supplier<Integer> s3 = Integer::new; // DOES NOT COMPILE  
        Supplier<Integer> s4 = () -> 100;  
        Supplier<Integer> s5 = () -> Integer.valueOf(100);  
  
  
        System.out.println(s1.get());  
        System.out.println(s2.get());  
        System.out.println(s4.get());  
        System.out.println(s5.get());  
    }  
  
  
    private static void supplierHelperExample() {  
  
        System.out.println("### supplierHelperExample ###");  
  
        Supplier<Integer> s1 = SupplierHelper::method1;  
        Supplier<Integer> s2 = () -> SupplierHelper.method1();  
        Supplier<Integer> s3 = () -> {  
            return SupplierHelper.method1();  
        };  
        Supplier<Integer> s4 = () -> 10;  
  
        Supplier<Integer> s5 = SupplierHelper::method2;  
  
        // Bad return type in method reference: cannot convert long to java.lang.Integer  
        //Supplier<Integer> s6 = SupplierHelper::method3; // DOES NOT COMPILE  
        // ad return type in method reference: cannot convert short to java.lang.Integer        //Supplier<Integer> s7 = SupplierHelper::method4; // DOES NOT COMPILE  
        // Supplier<Integer> s8 = SupplierHelper::instanceMethod; // DOES NOT COMPILE  
        Supplier<Integer> s9 = new SupplierHelper()::instanceMethod;  
  
        System.out.println(s1.get());  
        System.out.println(s2.get());  
        System.out.println(s3.get());  
        System.out.println(s4.get());  
        System.out.println(s5.get());  
        System.out.println(s9.get());  
  
    }  
  
}  
  
class SupplierHelper {  
  
    static int method1() {  
        return new Random().nextInt();  
    }  
  
    static Integer method2() {  
        return new Random().nextInt();  
    }  
  
    static long method3() {  
        return new Random().nextInt();  
    }  
  
    static short method4() {  
        return (short) new Random().nextInt();  
    }  
  
    int instanceMethod() {  
        return new Random().nextInt();  
    }  
}
```

### Implementing ``Consumer`` and ``BiConsumer``
 
 use a ``Consumer`` when you want to do something with a parameter but not return anything. ``BiConsumer`` does the same thing, except that it takes two parameters. The interfaces are defined as follows:

```java
@FunctionalInterface
public interface Consumer<T> {
	void accept(T t);
	// omitted default method
}
@FunctionalInterface
public interface BiConsumer<T, U> {
	void accept(T t, U u);
	// omitted default method
}
```

```java
Consumer<String> c1 = System.out::println;
Consumer<String> c2 = x -> System.out.println(x);

c1.accept("Annie"); // Annie
c2.accept("Annie"); // Annie
```

**==``BiConsumer`` is called with two parameters. They don’t have to be the same type.==**

```java
var map = new HashMap<String, Integer>();
BiConsumer<String, Integer> b1 = map::put;
BiConsumer<String, Integer> b2 = (k, v) -> map.put(k, v);

b1.accept("chicken", 7);
b2.accept("chick", 1);
System.out.println(map); // {chicken=7, chick=1}
```

```java
var map = new HashMap<String, String>();
BiConsumer<String, String> b1 = map::put;
BiConsumer<String, String> b2 = (k, v) -> map.put(k, v);

b1.accept("chicken", "Cluck");
b2.accept("chick", "Tweep");
System.out.println(map); // {chicken=Cluck, chick=Tweep}
```

```java
public class ImplementingConsumerAndBiConsumer {  
  
    public static void main(String[] args) {  
  
        consumerExample();  
        consumerHelperExample();  
        biConsumerExample1();  
        biConsumerHelperExample();  
        biConsumerExample2();  
        biConsumerExample3();  
  
  
    }  
  
    private static void consumerExample() {  
  
        System.out.println("### consumerExample ###");  
        Consumer<String> c1 = System.out::println;  
        Consumer<String> c2 = x -> System.out.println(x);  
  
        PrintStream ps = System.out;  
        Consumer<String> c3 = ps::println;  
  
  
        Consumer<StringBuilder> c4 = System.out::println;  
        Consumer<List> c5 = System.out::println;  
  
        c1.accept("Annie");  
        c2.accept("Annie");  
        c3.accept("Annie");  
        c4.accept(new StringBuilder("Annie"));  
        c5.accept(List.of("Annie"));  
  
    }  
  
    private static void consumerHelperExample() {  
  
        System.out.println("### consumerHelperExample ###");  
        Consumer<String> c1 = ConsumerHelper::method;  
        Consumer<Integer> c2 = ConsumerHelper::method;  
        Consumer<Integer> c3 = ConsumerHelper::methodWithReturn;  
  
        Consumer<String> c4 = s -> ConsumerHelper.method(s);  
        // Consumer<String> c5 = s -> "value"; // DOES NOT COMPILE  
  
        Consumer<String> c6 = s -> {  
            System.out.println(s);  
            System.out.println(s.length());  
        };  
  
        Consumer<StringBuilder> c7 = ConsumerHelper::method;  
        Consumer<List<String>> c8 = ConsumerHelper::method;  
  
        c1.accept("hello world!");  
        c2.accept(10);  
        c3.accept(20);  
        c4.accept("hello world!");  
        c6.accept("hello world!");  
        c7.accept(new StringBuilder("hello world!"));  
        c8.accept(List.of("v1", "v2", "v3"));  
    }  
  
    private static void biConsumerExample1() {  
  
        System.out.println("### biConsumerExample1 ###");  
        var map = new HashMap<String, Integer>();  
        BiConsumer<String, Integer> b1 = map::put;  
        BiConsumer<String, Integer> b2 = (k, v) -> map.put(k, v);  
  
        b1.accept("chicken", 7);  
        b2.accept("chick", 1);  
  
        System.out.println(map);  
    }  
  
    private static void biConsumerHelperExample() {  
  
        System.out.println("### biConsumerHelperExample ###");  
        BiConsumer<Integer, Integer> bc1 = BiConsumerHelper::method;  
        BiConsumer<String, Integer> bc2 = BiConsumerHelper::method;  
  
        bc1.accept(5, 10);  
        bc2.accept("10", 20);  
    }  
  
    private static void biConsumerExample2() {  
  
        System.out.println("### biConsumerExample2 ###");  
        BiConsumer<String, String> bc1 = String::concat;  
        BiConsumer<String, String> bc2 = (str1, str2) -> str1.concat(str2);  
        BiConsumer<String, String> bc3 = (str1, str2) ->  
        {  
            System.out.println(str1.concat(str2));  
        };  
  
        BiConsumer<BiConsumerHelper, String> bc4 = BiConsumerHelper::instanceMethod;  
  
  
        bc1.accept("hello", "world");  
        bc2.accept("hello", "world");  
        bc3.accept("hello", "world");  
        bc4.accept(new BiConsumerHelper(), "message!");  
    }  
  
    private static void biConsumerExample3() {  
  
        System.out.println("### biConsumerExample3 ###");  
        var map = new HashMap<String, String>();  
        BiConsumer<String, String> b1 = map::put;  
        BiConsumer<String, String> b2 = (k, v) -> map.put(k, v);  
  
        b1.accept("chicken", "Cluck");  
        b2.accept("chick", "Tweep");  
  
        System.out.println(map);  
    }  
}  
  
class ConsumerHelper {  
  
    static void method(String str) {  
        System.out.println(str);  
    }  
  
    static void method(Integer i) {  
        System.out.println(i);  
    }  
  
    static int methodWithReturn(Integer i) {  
        System.out.println(i * 2);  
        return i * 2;  
    }  
  
    static void method(StringBuilder sb) {  
        System.out.println(sb);  
    }  
  
    static void method(List<String> list) {  
        System.out.println(list);  
    }  
}  
  
class BiConsumerHelper {  
  
    static void method(Integer i, Integer j) {  
        System.out.println(i + j);  
    }  
  
    static void method(String str, Integer j) {  
        System.out.println(Integer.parseInt(str) * j);  
    }  
  
    void instanceMethod(String str) {  
        System.out.println(str);  
    }  
  
}
```

### Implementing ``Predicate`` and ``BiPredicate``

``Predicate`` is often used when filtering or matching. Both are common operations. A ``BiPredicate`` is just like a ``Predicate``, except that it takes two parameters instead of one. The interfaces are defined as follows:

```java
@FunctionalInterface
public interface Predicate<T> {
	boolean test(T t);
	// omitted default and static methods
}
@FunctionalInterface
public interface BiPredicate<T, U> {
	boolean test(T t, U u);
	// omitted default methods
}
```

```java
Predicate<String> p1 = String::isEmpty;
Predicate<String> p2 = x -> x.isEmpty();

System.out.println(p1.test("")); // true
System.out.println(p2.test("")); // true
```

```java
BiPredicate<String, String> b1 = String::startsWith;
BiPredicate<String, String> b2 = (string, prefix) -> string.startsWith(prefix);

System.out.println(b1.test("chicken", "chick")); // true
System.out.println(b2.test("chicken", "chick")); // true
```

**==The method reference includes both the instance variable and parameter for ``startsWith()``==**. This is a good example of how method references save quite a lot of typing. The downside is that they are less explicit, and you really have to understand what is going on!

```java
public class ImplementingPredicateAndBiPredicate {  
  
    public static void main(String[] args) {  
  
        predicateExample1();  
        predicateExample2();  
        predicateExample3();  
        predicateHelperExample();  
        biPredicateExample();  
        biPredicateHelperExample();  
    }  
  
    private static void predicateExample1() {  
  
        System.out.println("### predicateExample1 ###");  
        Predicate<String> p1 = String::isEmpty;  
        Predicate<String> p2 = x -> x.isEmpty();  
        Predicate<String> p3 = (String str) -> str.length() > 5;  
        Predicate<String> p4 = (String str) -> true;  
  
  
        System.out.println(p1.test("")); // true  
        System.out.println(p2.test("")); // true  
        System.out.println(p3.test("Hello Predicate!"));  
        System.out.println(p4.test("always-true"));  
    }  
  
    private static void predicateExample2() {  
  
        System.out.println("### predicateExample2 ###");  
        Predicate<Integer> p1 = number -> number > 100;  
        Predicate<Integer> p2 = (Integer number) -> {  
            return number > 100;  
        };  
  
  
        System.out.println(p1.test(20));  
        System.out.println(p1.test(120));  
  
        System.out.println(p2.test(20));  
        System.out.println(p2.test(120));  
    }  
  
    private static void predicateExample3() {  
  
        System.out.println("### predicateExample3 ###");  
        Predicate<List<Integer>> p1 = (List<Integer> list) -> list.contains(100);  
  
        Predicate<List<Integer>> p2 = List::isEmpty;  
        //Predicate<List<Integer>> p3 = ArrayList::isEmpty; // DOES NOT COMPILE  
        p1.test(List.of(10, 20, 50, 100));  
        p2.test(List.of(1, 2, 3));  
    }  
  
    private static void predicateHelperExample() {  
  
        System.out.println("### predicateHelperExample ###");  
        Predicate<Long> p1 = PredicateHelper::checkSize;  
        Predicate<Integer> p2 = PredicateHelper::checkSize;  
  
        Predicate<PredicateHelper> p3 = PredicateHelper::sampleMethod;  
        //Predicate<PredicateHelper> p4 = PredicateHelper::sampleStaticMethod; // DOES NOT COMPILE  
        Predicate<PredicateHelper> p5 = PredicateHelper::sampleStaticMethod2; // DOES NOT COMPILE  
  
        System.out.println(p1.test(20L));  
        p2.test(10);  
        p3.test(new PredicateHelper(100));  
        p5.test(new PredicateHelper(10));  
    }  
  
    private static void biPredicateExample() {  
  
        System.out.println("### biPredicateExample ###");  
        BiPredicate<String, String> b1 = String::startsWith;  
        BiPredicate<String, String> b2 = (string, prefix) -> string.startsWith(prefix);  
  
        BiPredicate<String, String> b3 = String::endsWith;  
        BiPredicate<String, String> b4 = (string, suffix) -> string.endsWith(suffix);  
  
        BiPredicate<String, String> b5 = String::contains;  
  
        System.out.println(b1.test("chicken", "chick")); // true  
        System.out.println(b2.test("chicken", "chick")); // true  
        System.out.println(b3.test("hello", "world"));  
        System.out.println(b4.test("hello", "world"));  
        System.out.println(b5.test("injavawetrust", "java"));  
  
    }  
  
    private static void biPredicateHelperExample() {  
  
        System.out.println("### biPredicateHelperExample ###");  
        BiPredicate<Integer, Integer> b1 = BiPredicateHelper::check;  
        BiPredicate<String, Integer> b2 = BiPredicateHelper::check2;  
  
        System.out.println(b1.test(1, 5));  
        System.out.println(b2.test("hello", 5));  
    }  
}  
  
class PredicateHelper {  
  
    private int size;  
  
    public PredicateHelper(int size) {  
        this.size = size;  
    }  
  
    static boolean checkSize(long size) {  
        return size > 10;  
    }  
  
    static boolean checkSize(int size) {  
        return size > 10;  
    }  
  
    boolean sampleMethod() {  
        return this.size == 10;  
    }  
  
    static boolean sampleStaticMethod() {  
        return false;  
    }  
  
    static boolean sampleStaticMethod2(PredicateHelper ph) {  
        return ph == null;  
    }  
}  
  
class BiPredicateHelper {  
    static boolean check(Integer i, Integer j) {  
        return i > j;  
    }  
  
    static Boolean check2(String s, Integer i) {  
        return s.length() > i;  
    }  
}
```

### Implementing ``Function`` and ``BiFunction``

A ``Function`` is responsible for turning one parameter into a value of a potentially different type and returning it. Similarly, a ``BiFunction`` is responsible for turning two parameters into a value and returning it.

```java
@FunctionalInterface
public interface Function<T, R> {
	R apply(T t);
	// omitted default and static methods
}
@FunctionalInterface
public interface BiFunction<T, U, R> {
	R apply(T t, U u);
	// omitted default method
}
```

```java
Function<String, Integer> f1 = String::length;
Function<String, Integer> f2 = x -> x.length();
System.out.println(f1.apply("cluck")); // 5
System.out.println(f2.apply("cluck")); // 5
```

This function turns the ``String`` into an int, which is autoboxed into an ``Integer``.

```java
BiFunction<String, String, String> b1 = String::concat;
BiFunction<String, String, String> b2 = (string, toAdd) -> string.concat(toAdd);

System.out.println(b1.apply("baby ", "chick")); // baby chick
System.out.println(b2.apply("baby ", "chick")); // baby chick
```

**==The first two types in the ``BiFunction`` are the input types. The third is the result type==**. For the method reference, the first parameter is the instance that ``concat()`` is called on, and the second is passed to ``concat()``.

```java
public class ImplementingFunctionAndBiFunction {  
  
    public static void main(String[] args) {  
  
        functionExample();  
        functionExample2();  
        functionExample3();  
        functionHelperExample();  
        biFunctionExample();  
        biFunctionHelperExample();  
    }  
  
    private static void functionExample() {  
  
        System.out.println("### functionExample ###");  
        Function<String, Integer> f1 = String::length;  
        Function<String, Integer> f2 = x -> x.length();  
  
        Function<String, String> f3 = String::toUpperCase;  
        Function<String, String> f4 = s -> s.toUpperCase();  
  
        System.out.println(f1.apply("cluck"));  
        System.out.println(f2.apply("cluck"));  
        System.out.println(f3.apply("hello"));  
        System.out.println(f4.apply("hello"));  
    }  
  
    private static void functionExample2() {  
  
        System.out.println("### functionExample2 ###");  
        String str = "content";  
        Function<String, Integer> f1 = str::indexOf;  
        System.out.println(f1.apply("o"));  
    }  
  
    private static void functionExample3() {  
  
        System.out.println("### functionExample3 ###");  
        Function<List<Integer>, Integer> f1 = List::size;  
        Function<List<Integer>, Integer> f2 = (list) -> list.size();  
  
        System.out.println(f1.apply(List.of(1, 2, 3)));  
        System.out.println(f2.apply(List.of(1, 2, 3)));  
    }  
  
    private static void functionHelperExample() {  
  
        System.out.println("### functionHelperExample ###");  
        Function<String, Integer> f1 = FunctionHelper::length;  
        Function<String, Integer> f2 = s -> FunctionHelper.length(s);  
        Function<FunctionHelper, Integer> f3 = FunctionHelper::multiply;  
  
        System.out.println(f1.apply("hello world!"));  
        System.out.println(f2.apply("hello world"));  
        System.out.println(f3.apply(new FunctionHelper(10)));  
    }  
  
    private static void biFunctionExample() {  
  
        System.out.println("### biFunctionExample ###");  
        BiFunction<String, String, String> b1 = String::concat;  
        BiFunction<String, String, String> b2 = (string, toAdd) -> string.concat(toAdd);  
  
        System.out.println(b1.apply("baby ", "chick")); // baby chick  
        System.out.println(b2.apply("baby ", "chick")); // baby chick  
    }  
  
    private static void biFunctionHelperExample() {  
  
        System.out.println("### biFunctionHelperExample ###");  
        BiFunction<String, String, String> bf1 = BiFunctionHelper::concat;  
        BiFunction<String, String, Integer> bf2 = BiFunctionHelper::length;  
  
        BiFunction<BiFunctionHelper, String, Integer> bf3 = BiFunctionHelper::compareTo;  
        BiFunction<BiFunctionHelper, String, Integer> bf4 = BiFunctionHelper::compareToV2;  
  
        System.out.println(bf1.apply("hello", "world"));  
        System.out.println(bf2.apply("hello", "world"));  
        System.out.println(bf3.apply(new BiFunctionHelper("hello-world"), "sample"));  
        System.out.println(bf4.apply(new BiFunctionHelper("hello-world"), "sample"));  
    }  
  
}  
  
class FunctionHelper {  
  
    private int size;  
  
    public FunctionHelper(int size) {  
        this.size = size;  
    }  
  
    static Integer length(String s) {  
        return s.length();  
    }  
  
    Integer multiply() {  
        return size * 5;  
    }  
}  
  
class BiFunctionHelper {  
  
    private String content;  
  
    public BiFunctionHelper(String content) {  
        this.content = content;  
    }  
  
    static String concat(String str, String str2) {  
        return "Prefix -".concat(str).concat(str2).concat(" - suffix");  
    }  
  
    static Integer length(String str, String str2) {  
        return str.concat(str2).length();  
    }  
  
    Integer compareTo(String str) {  
        return content.compareTo(str);  
    }  
  
    static Integer compareToV2(BiFunctionHelper bfh, String str) {  
        return 10;  
    }  
}
```

### Implementing UnaryOperator and BinaryOperator

``UnaryOperator`` and ``BinaryOperator`` are special cases of a ``Function``. **==They require all type parameters to be the same type==**. A ``UnaryOperator`` transforms its value into one of the same type. For example, incrementing by one is a unary operation. In fact, ``UnaryOperator`` extends ``Function``. A ``BinaryOperator`` merges two values into one of the same type. Adding two numbers is a binary operation. Similarly, ``BinaryOperator`` extends ``BiFunction``.

```java
@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T> {
	T apply(T t); // UnaryOperator
	// omitted static method
}
@FunctionalInterface
public interface BinaryOperator<T> extends BiFunction<T, T, T> {
	T apply(T t1, T t2); // BinaryOperator
	// omitted static methods
}
```


In the Javadoc, you’ll notice that these methods are inherited from the ``Function/BiFunction`` superclass. **==The generic declarations on the subclass are what force the type to be the same.==**

```java
UnaryOperator<String> u1 = String::toUpperCase;
UnaryOperator<String> u2 = x -> x.toUpperCase();

System.out.println(u1.apply("chirp")); // CHIRP
System.out.println(u2.apply("chirp")); // CHIRP
```

We don’t need to specify the return type in the generics because ``UnaryOperator`` requires it to be the same as the parameter

```java
BinaryOperator<String> b1 = String::concat;
BinaryOperator<String> b2 = (string, toAdd) -> string.concat(toAdd);

System.out.println(b1.apply("baby ", "chick")); // baby chick
System.out.println(b2.apply("baby ", "chick")); // baby chick
```

Notice that this does the same thing as the ``BiFunction`` example. The code is more succinct, which shows the importance of using the best functional interface

```java
public class ImplementingUnaryOperatorAndBinaryOperator {  
  
    public static void main(String[] args) {  
  
        unaryOperatorExample();  
        unaryOperatorExample2();  
        unaryOperatorHelperExample();  
        binaryOperatorExample();  
        binaryOperatorExample2();  
        binaryOperatorHelperExample();  
  
    }  
  
    private static void unaryOperatorExample() {  
  
        System.out.println("### unaryOperatorExample ###");  
        UnaryOperator<String> u1 = String::toUpperCase;  
        UnaryOperator<String> u2 = x -> x.toUpperCase();  
  
        System.out.println(u1.apply("chirp")); // CHIRP  
        System.out.println(u2.apply("chirp")); // CHIRP  
    }  
  
    private static void unaryOperatorExample2() {  
  
        System.out.println("### unaryOperatorExample2 ###");  
        String str = "content ";  
        UnaryOperator<String> u1 = str::concat;  
        // UnaryOperator<String> u2 = String::concat; // DOES NOT COMPILE  
  
        System.out.println(u1.apply("chirp")); // CHIRP  
  
    }  
  
    private static void unaryOperatorHelperExample() {  
  
        System.out.println("### unaryOperatorHelperExample ###");  
        UnaryOperator<Integer> u1 = UnaryOperatorHelper::square;  
  
        // Bad return type in method reference: cannot convert long to java.lang.Integer  
        // UnaryOperator<Integer> u2 = UnaryOperatorHelper::square2;  
        UnaryOperator<Long> u3 = UnaryOperatorHelper::square2;  
  
        System.out.println(u1.apply(25));  
        System.out.println(u3.apply(10L));  
    }  
  
  
    private static void binaryOperatorExample() {  
  
        System.out.println("### binaryOperatorExample ###");  
        BinaryOperator<String> b1 = String::concat;  
        BinaryOperator<String> b2 = (string, toAdd) -> string.concat(toAdd);  
        System.out.println(b1.apply("baby ", "chick")); // baby chick  
        System.out.println(b2.apply("baby ", "chick")); // baby chick  
    }  
  
  
    private static void binaryOperatorExample2() {  
  
        System.out.println("### binaryOperatorExample ###");  
        BinaryOperator<Double> b1 = Math::pow;  
        BinaryOperator<Integer> b2 = Math::max;  
  
        System.out.println(b1.apply(2.0, 5.0));  
        System.out.println(b2.apply(12, 15));  
    }  
  
    private static void binaryOperatorHelperExample() {  
  
        System.out.println("### binaryOperatorHelperExample ###");  
        BinaryOperator<Integer> b1 = BinaryOperatorHelper::multiply;  
        BinaryOperator<Integer> b2 = (Integer i, Integer j) -> BinaryOperatorHelper.multiply(i, j);  
  
        System.out.println(b1.apply(10, 6));  
        System.out.println(b2.apply(10, 6));  
    }  
}  
  
class UnaryOperatorHelper {  
  
    static int square(int i) {  
        return i * i;  
    }  
  
    static long square2(long i) {  
        return i * i;  
    }  
}  
  
class BinaryOperatorHelper {  
  
    static int multiply(int i, int j) {  
        return i * j;  
    }
```

### Checking Functional Interfaces

-  Returns a ``String`` without taking any parameters -> ``Supplier<String>``
-  Returns a ``Boolean`` and takes a ``String`` -> ``Function<String, Boolean>``
-  Returns an ``Integer`` and takes two ``Integers`` -> ``BinaryOperator<Integer>``

The second one is a ``Function<String,Boolean>`` because it takes one parameter and returns another type. It’s a little tricky. You might think it is a ``Predicate<String>``. Note that a **==Predicate returns a boolean primitive and not a Boolean object==**.

```java
6: ?? <List> ex1 = x -> "".equals(x.get(0)); //Predicate
7: ?? <Long> ex2 = (Long l) -> System.out.println(l); //Consumer
8: ?? <String, String> ex3 = (s1, s2) -> false; // BiPredicate
```

- Line 6 passes one List parameter to the lambda and returns a ``boolean``. This tells us that it is a ``Predicate`` or ``Function``. Since the generic declaration has only one parameter, it is a ``Predicate``.
- Line 7 passes one ``Long`` parameter to the lambda and doesn’t return anything. This tells us that it is a ``Consumer``.
- Line 8 takes two parameters and returns a ``boolean``. When you see a ``boolean`` returned, think ``Predicate`` unless the generics specify a ``Boolean`` return type. In this case, there are two parameters, so it is a ``BiPredicate``.

```java
6: Function<List<String>> ex1 = x -> x.get(0); // DOES NOT COMPILE
7: UnaryOperator<Long> ex2 = (Long l) -> 3.14; // DOES NOT COMPILE
```

- Line 6 claims to be a ``Function``. A ``Function`` needs to specify two generic types: the input parameter type and the return value type. The return value type is missing from line 6, causing the code not to compile.
- Line 7 is a ``UnaryOperator``, which returns the same type as it is passed in. The example returns a double rather than a Long, causing the code not to compile.

### Using Convenience Methods on Functional Interfaces

By definition, all functional interfaces have a single abstract method. Several of the common functional interfaces provide a number of helpful ``default`` interface methods.

The ``BiConsumer``, ``BiFunction``, and ``BiPredicate`` interfaces have similar methods available.

![[Pasted image 20240403143832.png]]

```java
Predicate<String> egg = s -> s.contains("egg");
Predicate<String> brown = s -> s.contains("brown");

Predicate<String> brownEggs = s -> s.contains("egg") && s.contains("brown");
Predicate<String> otherEggs = s -> s.contains("egg") && !s.contains("brown");
```

This works, but it’s not great. It’s a bit long to read, and it contains duplication. better way to deal with this situation is to use two of the default methods on Predicate.

```java
Predicate<String> brownEggs = egg.and(brown);
Predicate<String> otherEggs = egg.and(brown.negate());
```


```java
Consumer<String> c1 = x -> System.out.print("1: " + x);
Consumer<String> c2 = x -> System.out.print(",2: " + x);
Consumer<String> combined = c1.andThen(c2); combined.accept("Annie"); // 1: Annie,2: Annie
```

Notice how the same parameter is passed to both ``c1`` and ``c2``. This shows that **==the ``Consumer`` instances are run in sequence and are independent of each other. By contrast, the ``compose()`` method on ``Function`` chains functional interfaces==**. However, it passes along the output of one to the input of another.

```java
Function<Integer, Integer> before = x -> x + 1;
Function<Integer, Integer> after = x -> x * 2;
Function<Integer, Integer> combined = after.compose(before);
System.out.println(combined.apply(3)); // 8
```

This time, the before runs first, turning the 3 into 4. Then the after runs, doubling the 4 to 8.

### Learning the Functional Interfaces for Primitives

There are also a large number of special functional interfaces for primitives. 

Most of them are for the double, int, and long types. There is one exception, which is BooleanSupplier.

#### Functional Interfaces for ``boolean``

``BooleanSupplier`` is a separate type. It has one method to implement:

```java
@FunctionalInterface
public interface BooleanSupplier {
	boolean getAsBoolean();
}
```

```java
12: BooleanSupplier b1 = () -> true;
13: BooleanSupplier b2 = () -> Math.random()> .5;
14: System.out.println(b1.getAsBoolean()); // true
15: System.out.println(b2.getAsBoolean()); // false
```

```java
public class PrimitiveTypesSupplierInterfaceForBoolean {  
  
    public static void main(String[] args) {  
  
        BooleanSupplier b1 = () -> true;  
        BooleanSupplier b2 = () -> Math.random() > .5;  
        BooleanSupplier b3 = PrimitiveBooleanHelper::isRandomNumGreaterThan5;  
  
        String str = "not-empty";  
        BooleanSupplier b4 = str::isEmpty;  
  
        System.out.println(b1.getAsBoolean());  
        System.out.println(b2.getAsBoolean());  
        System.out.println(b3.getAsBoolean());  
        System.out.println(b4.getAsBoolean());  
  
    }  
}  
  
class PrimitiveBooleanHelper {  
  
    static boolean isRandomNumGreaterThan5() {  
        return new Random().nextInt(10) > 5;  
    }  
}
```

#### Functional Interfaces for ``double``, ``int``, and ``long``

Table 8.6 shows the equivalent of Table 8.4 for these primitives.

![[Pasted image 20240403145305.png]]

There are a few things to notice that are different between Table 8.4 and Table 8.6:

-  **==Generics are gone from some of the interfaces, and instead the type name tells us what primitive type is involved. In other cases, such as IntFunction, only the return type generic is needed because we’re converting a primitive int into an object.**==
-  ==**The single abstract method is often renamed when a primitive type is returned.==**


**PrimitiveTypesSupplierInterfaces**

```java
public class PrimitiveTypesSupplierInterfaces {  
  
    public static void main(String[] args) {  
  
        doubleSupplierExample();  
        intSupplierExample();  
        longSupplierExample();  
  
    }  
  
    private static void doubleSupplierExample() {  
  
        System.out.println("### doubleSupplierExample ###");  
  
        DoubleSupplier ds1 = () -> 10.0;  
        DoubleSupplier ds2 = () -> Math.random();  
        DoubleSupplier ds3 = Math::random;  
        DoubleSupplier ds4 = () -> new Random().nextDouble();  
        DoubleSupplier ds5 = PrimitiveSupplierHelper::randomDouble;  
        Supplier<Double> s1 = Math::random;  
        Supplier<Double> s2 = () -> Math.random();  
  
        System.out.println(ds1.getAsDouble());  
        System.out.println(ds2.getAsDouble());  
        System.out.println(ds3.getAsDouble());  
        System.out.println(ds4.getAsDouble());  
        System.out.println(ds5.getAsDouble());  
        System.out.println(s1.get());  
        System.out.println(s2.get());  
    }  
  
  
    private static void intSupplierExample() {  
  
        System.out.println("### intSupplierExample ###");  
  
        IntSupplier is1 = () -> 10;  
        IntSupplier is2 = () -> (int) Math.random();  
        IntSupplier is3 = () -> new Random().nextInt();  
        IntSupplier is4 = PrimitiveSupplierHelper::randomInt;  
        Supplier<Integer> s1 = PrimitiveSupplierHelper::randomInt;  
  
        System.out.println(is1.getAsInt());  
        System.out.println(is2.getAsInt());  
        System.out.println(is3.getAsInt());  
        System.out.println(is4.getAsInt());  
        System.out.println(s1.get());  
    }  
  
    private static void longSupplierExample() {  
  
        System.out.println("### longSupplierExample ###");  
  
        LongSupplier ls1 = () -> 10;  
        LongSupplier ls2 = new Random()::nextInt;  
        LongSupplier ls3 = new Random()::nextLong;  
        LongSupplier ls4 = PrimitiveSupplierHelper::randomInt;  
        LongSupplier ls5 = PrimitiveSupplierHelper::randomLong;  
  
        // Supplier<Long> s1 = PrimitiveSupplierHelper::randomInt; // DOES NOT COMPILE  
        Supplier<Long> s2 = PrimitiveSupplierHelper::randomLong;  
  
        System.out.println(ls1.getAsLong());  
        System.out.println(ls2.getAsLong());  
        System.out.println(ls3.getAsLong());  
        System.out.println(ls4.getAsLong());  
        System.out.println(ls5.getAsLong());  
        System.out.println(s2.get());  
    }  
  
}  
  
  
class PrimitiveSupplierHelper {  
  
    static double randomDouble() {  
        Random random = new Random();  
        return random.nextDouble();  
    }  
  
    static int randomInt() {  
        Random random = new Random();  
        return random.nextInt();  
    }  
  
    static long randomLong() {  
        Random random = new Random();  
        return random.nextLong();  
    }  
}
```

**PrimitiveTypesConsumerInterfaces**

```java
public class PrimitiveTypesConsumerInterfaces {  
  
    public static void main(String[] args) {  
  
        doubleConsumerExample();  
        intConsumerExample();  
        longConsumerExample();  
  
    }  
  
    private static void doubleConsumerExample() {  
  
        System.out.println("### doubleConsumerExample ###");  
  
        DoubleConsumer dc1 = (value) -> System.out.println(value);  
        DoubleConsumer dc2 = System.out::println;  
        DoubleConsumer dc3 = PrimitiveConsumerHelper::consumeDouble;  
  
        Consumer<Double> c1 = (value) -> System.out.println(value);  
        Consumer<Double> c2 = System.out::println;  
        Consumer<Double> c3 = PrimitiveConsumerHelper::consumeDouble;  
  
        dc1.accept(10);  
        dc2.accept(10);  
        dc3.accept(10);  
        c1.accept(10d);  
        c2.accept(10D);  
        c3.accept(10.0);  
    }  
  
    private static void intConsumerExample() {  
  
        System.out.println("### intConsumerExample ###");  
  
        IntConsumer ic1 = value -> System.out.println(value);  
        IntConsumer ic2 = System.out::println;  
        IntConsumer ic3 = PrimitiveConsumerHelper::consumeDouble;  
        IntConsumer ic4 = PrimitiveConsumerHelper::consumeInt;  
  
        Consumer<Integer> c1 = (value) -> System.out.println(value);  
        Consumer<Integer> c2 = System.out::println;  
        Consumer<Integer> c3 = PrimitiveConsumerHelper::consumeDouble;  
        Consumer<Integer> c4 = PrimitiveConsumerHelper::consumeInt;  
  
        ic1.accept(10);  
        ic2.accept(10);  
        ic3.accept(10);  
        ic4.accept(10);  
  
        c1.accept(10);  
        c2.accept(10);  
        c3.accept(10);  
        c4.accept(10);  
  
    }  
  
  
    private static void longConsumerExample() {  
  
        System.out.println("### longConsumerExample ###");  
  
        LongConsumer lc1 = (value) -> System.out.println(value);  
        LongConsumer lc2 = System.out::println;  
        // LongConsumer lc3 = PrimitiveConsumerHelper::consumeInt; // DOES  NOT COMPILE  
        LongConsumer lc4 = PrimitiveConsumerHelper::consumeLong;  
        LongConsumer lc5 = PrimitiveConsumerHelper::consumeDouble;  
  
        Consumer<Long> c1 = (value) -> System.out.println(value);  
        Consumer<Long> c2 = System.out::println;  
        // Consumer<Long> c3 = PrimitiveConsumerHelper::consumeInt; // DOES NOT COMPILE  
        Consumer<Long> c4 = PrimitiveConsumerHelper::consumeLong;  
        Consumer<Long> c5 = PrimitiveConsumerHelper::consumeDouble;  
  
        lc1.accept(1);  
        lc2.accept(1);  
        lc4.accept(1);  
        lc5.accept(1);  
  
        c1.accept(1L);  
        c2.accept(1L);  
        c4.accept(1L);  
        c5.accept(1L);  
    }  
  
}  
  
class PrimitiveConsumerHelper {  
  
    static void consumeDouble(double d) {  
        System.out.println(d * 2);  
    }  
  
    static void consumeInt(int d) {  
        System.out.println(d * 2);  
    }  
  
    static void consumeLong(long l) {  
        System.out.println(l * 2);  
    }  
}
```

**PrimitiveTypesPredicateInterfaces**

```java
public class PrimitiveTypesPredicateInterfaces {  
  
    public static void main(String[] args) {  
  
        doublePredicateExample();  
        intPredicateExample();  
        longPredicateExample();  
    }  
  
    private static void doublePredicateExample() {  
  
        System.out.println("### doublePredicateExample ###");  
  
        DoublePredicate dp1 = (d) -> d > 1.5;  
        DoublePredicate dp2 = PredicatePrimitiveHelper::predicateDouble;  
        DoublePredicate dp3 = d -> PredicatePrimitiveHelper.predicateDouble(d);  
  
        DoublePredicate dp4 = Double::isInfinite;  
        DoublePredicate dp5 = Double::isNaN;  
        DoublePredicate dp6 = Double::isFinite;  
  
        System.out.println(dp1.test(0.5));  
        System.out.println(dp2.test(1.1));  
        System.out.println(dp3.test(2.5));  
  
        System.out.println(dp4.test(Double.POSITIVE_INFINITY));  
        System.out.println(dp5.test(Double.NaN));  
        System.out.println(dp6.test(Double.MAX_VALUE));  
    }  
  
    private static void intPredicateExample() {  
  
        System.out.println("### intPredicateExample ###");  
  
        IntPredicate dp1 = (d) -> d > 1.5;  
        IntPredicate dp2 = PredicatePrimitiveHelper::predicateDouble;  
        IntPredicate dp3 = PredicatePrimitiveHelper::predicateInt;  
        IntPredicate dp4 = d -> PredicatePrimitiveHelper.predicateDouble(d);  
        IntPredicate dp5 = d -> PredicatePrimitiveHelper.predicateInt(d);  
  
        System.out.println(dp1.test(5));  
        System.out.println(dp2.test(5));  
        System.out.println(dp3.test(34));  
        System.out.println(dp3.test(54));  
        System.out.println(dp4.test(26));  
        System.out.println(dp5.test(36));  
    }  
  
    private static void longPredicateExample() {  
  
        System.out.println("### longPredicateExample ###");  
  
        LongPredicate dp1 = (long d) -> d > 1.5;  
        LongPredicate dp2 = PredicatePrimitiveHelper::predicateLong;  
        LongPredicate dp3 = PredicatePrimitiveHelper::predicateDouble;  
        // LongPredicate dp4 = PredicatePrimitiveHelper::predicateInt; // DOES NOT COMPILE  
        LongPredicate dp5 = d -> PredicatePrimitiveHelper.predicateLong(d);  
        LongPredicate dp6 = d -> PredicatePrimitiveHelper.predicateDouble(d);  
        //LongPredicate dp7 = d -> PredicatePrimitiveHelper.predicateInt(d); // DOES NOT COMPILE  
  
        System.out.println(dp1.test(5));  
        System.out.println(dp2.test(5));  
        System.out.println(dp3.test(26));  
        System.out.println(dp5.test(26));  
        System.out.println(dp6.test(26));  
  
    }  
}  
  
  
class PredicatePrimitiveHelper {  
  
    static boolean predicateDouble(double d) {  
        return d > 1.2;  
    }  
  
    static boolean predicateInt(int i) {  
        return i > 2;  
    }  
  
    static boolean predicateLong(long i) {  
        return i > 2;  
    }  
}
```

**PrimitiveTypesFunctionInterfaces**

```java
public class PrimitiveTypesFunctionInterfaces {  
  
    public static void main(String[] args) {  
  
        doubleFunctionExample();  
        intFunctionExample();  
        longFunctionExample();  
    }  
  
    private static void doubleFunctionExample() {  
        System.out.println("### doubleFunctionExample ### ");  
        DoubleFunction<String> df1 = Double::toHexString;  
        DoubleFunction<String> df2 = (d) -> Double.toHexString(d);  
        DoubleFunction<Double> df3 = Double::valueOf;  
        DoubleFunction<Double> df4 = Math::sqrt;  
        DoubleFunction<String> df5 = PrimitiveFunctionHelper::convertFromDouble;  
  
        DoubleFunction<Double> df6 = new Random()::nextDouble;  
  
        System.out.println(df1.apply(10.5));  
        System.out.println(df2.apply(10.5));  
        System.out.println(df3.apply(10.5));  
        System.out.println(df4.apply(10.5));  
        System.out.println(df5.apply(10.5));  
        System.out.println(df6.apply(10.5));  
  
    }  
  
    private static void intFunctionExample() {  
  
        System.out.println("### intFunctionExample ### ");  
        IntFunction<String> if1 = Double::toHexString;  
        IntFunction<String> if2 = Integer::toHexString;  
  
        IntFunction<String> if3 = (d) -> Double.toHexString(d);  
        IntFunction<String> if4 = (d) -> Integer.toHexString(d);  
  
        IntFunction<Double> if5 = Double::valueOf;  
        IntFunction<Integer> if6 = Integer::valueOf;  
  
        IntFunction<Double> if7 = Math::sqrt;  
        IntFunction<String> if8 = PrimitiveFunctionHelper::convertFromDouble;  
        IntFunction<String> if9 = PrimitiveFunctionHelper::convertFromInt;  
  
        IntFunction<Integer> if10 = new Random()::nextInt;  
  
        System.out.println(if1.apply(10));  
        System.out.println(if2.apply(10));  
        System.out.println(if3.apply(10));  
        System.out.println(if4.apply(10));  
        System.out.println(if5.apply(10));  
        System.out.println(if6.apply(10));  
        System.out.println(if7.apply(10));  
        System.out.println(if8.apply(10));  
        System.out.println(if9.apply(10));  
        System.out.println(if10.apply(10));  
  
    }  
  
  
    private static void longFunctionExample() {  
        System.out.println("### longFunctionExample ### ");  
        LongFunction<String> lf1 = Double::toHexString;  
        LongFunction<String> lf2 = Long::toHexString;  
  
        LongFunction<String> lf3 = (d) -> Double.toHexString(d);  
        LongFunction<String> lf4 = (d) -> Long.toHexString(d);  
  
        LongFunction<Double> lf5 = Double::valueOf;  
        LongFunction<Long> lf6 = Long::valueOf;  
  
        LongFunction<Double> lf7 = Math::sqrt;  
        LongFunction<String> lf8 = PrimitiveFunctionHelper::convertFromDouble;  
        LongFunction<String> lf9 = PrimitiveFunctionHelper::convertFromLong;  
  
        LongFunction<Long> lf10 = new Random()::nextLong;  
  
        System.out.println(lf1.apply(10));  
        System.out.println(lf2.apply(10));  
        System.out.println(lf3.apply(10));  
        System.out.println(lf4.apply(10));  
        System.out.println(lf5.apply(10));  
        System.out.println(lf6.apply(10));  
        System.out.println(lf7.apply(10));  
        System.out.println(lf8.apply(10));  
        System.out.println(lf9.apply(10));  
        System.out.println(lf10.apply(10));  
  
    }  
  
}  
  
class PrimitiveFunctionHelper {  
    static String convertFromDouble(double value) {  
        return "converted value : " + value;  
    }  
  
    static String convertFromInt(int value) {  
        return "converted value : " + value;  
    }  
  
    static String convertFromLong(long value) {  
        return "converted value : " + value;  
    }  
}
```

**PrimitiveTypesUnaryOperatorInterfaces**

```java
public class PrimitiveTypesUnaryOperatorInterfaces {  
  
    public static void main(String[] args) {  
  
        doubleUnaryOperatorExample();  
        intUnaryOperatorExample();  
        longUnaryOperatorExample();  
  
    }  
  
    private static void doubleUnaryOperatorExample() {  
  
        System.out.println("### doubleUnaryOperatorExample ###");  
        DoubleUnaryOperator duo1 = Double::valueOf;  
        DoubleUnaryOperator duo2 = Math::sqrt;  
        DoubleUnaryOperator duo3 = Math::sin;  
        DoubleUnaryOperator duo4 = (double d) -> d * 2;  
        // Incompatible parameter types in lambda expression: expected double but found Double  
        // DoubleUnaryOperator duo5 = (Double d) -> d * 2;        DoubleUnaryOperator duo6 = PrimitiveUnaryOperatorHelper::multiply;  
  
  
        System.out.println(duo1.applyAsDouble(5.2));  
        System.out.println(duo2.applyAsDouble(5.2));  
        System.out.println(duo3.applyAsDouble(5.2));  
        System.out.println(duo4.applyAsDouble(5.2));  
        System.out.println(duo6.applyAsDouble(5.2));  
    }  
  
    private static void intUnaryOperatorExample() {  
  
        System.out.println("### intUnaryOperatorExample ###");  
        IntUnaryOperator iuo1 = Integer::valueOf;  
        IntUnaryOperator iuo2 = (i) -> i * 5;  
        IntUnaryOperator iuo3 = Math::toIntExact;  
        IntUnaryOperator iuo4 = PrimitiveUnaryOperatorHelper::sum;  
  
        // Bad return type in method reference: cannot convert double to int  
        // IntUnaryOperator iuo5 = PrimitiveUnaryOperatorHelper::multiply; // DOES NOT COMPILE  
        System.out.println(iuo1.applyAsInt(10));  
        System.out.println(iuo2.applyAsInt(10));  
        System.out.println(iuo3.applyAsInt(10));  
        System.out.println(iuo4.applyAsInt(10));  
  
    }  
  
    private static void longUnaryOperatorExample() {  
  
        System.out.println("### longUnaryOperatorExample ###");  
  
        LongUnaryOperator luo1 = Long::valueOf;  
        LongUnaryOperator luo2 = (i) -> i * 5;  
        LongUnaryOperator luo3 = Math::toIntExact;  
        LongUnaryOperator luo4 = PrimitiveUnaryOperatorHelper::substract;  
  
        System.out.println(luo1.applyAsLong(10));  
        System.out.println(luo2.applyAsLong(10));  
        System.out.println(luo3.applyAsLong(10));  
        System.out.println(luo4.applyAsLong(10));  
    }  
  
}  
  
class PrimitiveUnaryOperatorHelper {  
    static double multiply(double value) {  
        return value * 2;  
    }  
  
    static int sum(int num) {  
        return num + 100;  
    }  
  
    static long substract(long num) {  
        return num - 100;  
    }  
  
}
```

**PrimitiveTypesBinaryOperatorInterfaces**

```java
public class PrimitiveTypesBinaryOperatorInterfaces {  
  
    public static void main(String[] args) {  
  
        doubleBinaryOperatorExample();  
        intBinaryOperatorExample();  
        longBinaryOperatorExample();  
  
    }  
  
    private static void doubleBinaryOperatorExample() {  
        System.out.println("### doubleBinaryOperatorExample ###");  
        DoubleBinaryOperator dbo1 = Math::pow;  
        DoubleBinaryOperator dbo2 = Math::max;  
        DoubleBinaryOperator dbo3 = (double d1, double d2) -> d1 * d2;  
        DoubleBinaryOperator dbo4 = PrimitiveBinaryOperatorHelper::multiply;  
  
        System.out.println(dbo1.applyAsDouble(2.0, 3.0));  
        System.out.println(dbo2.applyAsDouble(2.0, 3.0));  
        System.out.println(dbo3.applyAsDouble(2.0, 3.0));  
        System.out.println(dbo4.applyAsDouble(2.0, 3.0));  
    }  
  
    private static void intBinaryOperatorExample() {  
        System.out.println("### intBinaryOperatorExample ###");  
        IntBinaryOperator ibo1 = Integer::min;  
        IntBinaryOperator ibo2 = Integer::max;  
        IntBinaryOperator ibo3 = (int i, int j) -> i * j;  
        IntBinaryOperator ibo4 = PrimitiveBinaryOperatorHelper::multiply;  
  
        System.out.println(ibo1.applyAsInt(2, 3));  
        System.out.println(ibo2.applyAsInt(2, 3));  
        System.out.println(ibo3.applyAsInt(2, 3));  
        System.out.println(ibo4.applyAsInt(2, 3));  
    }  
  
    private static void longBinaryOperatorExample() {  
        System.out.println("### longBinaryOperatorExample ###");  
        LongBinaryOperator lbo1 = Long::min;  
        LongBinaryOperator lbo2 = Long::max;  
        LongBinaryOperator lbo3 = (long i, long j) -> i * j;  
        LongBinaryOperator lbo4 = PrimitiveBinaryOperatorHelper::multiply;  
  
        System.out.println(lbo1.applyAsLong(2, 3));  
        System.out.println(lbo2.applyAsLong(2, 3));  
        System.out.println(lbo3.applyAsLong(2, 3));  
        System.out.println(lbo4.applyAsLong(2, 3));  
    }  
}  
  
class PrimitiveBinaryOperatorHelper {  
  
    static double multiply(double d1, double d2) {  
        return d1 * d2;  
    }  
  
    static int multiply(int i, int j) {  
        return i * j;  
    }  
  
    static long multiply(long i, long j) {  
        return i * j;  
    }  
}
```

![[Pasted image 20240403152301.png]]

**ToXyzFunctionInterfaces**

```java
public class ToXyzFunctionInterfaces {  
  
    public static void main(String[] args) {  
  
        toDoubleFunctionExample();  
        toIntFunctionExample();  
        toLongFunctionExample();  
  
    }  
  
    private static void toDoubleFunctionExample() {  
  
        System.out.println("### toDoubleFunctionExample ###");  
  
        ToDoubleFunction<Integer> tdf1 = (Integer i) -> i * 2.5;  
        ToDoubleFunction<String> tdf2 = (String s) -> Double.parseDouble(s);  
        ToDoubleFunction<String> tdf3 = Double::parseDouble;  
  
        System.out.println(tdf1.applyAsDouble(10));  
        System.out.println(tdf2.applyAsDouble("10.25"));  
        System.out.println(tdf3.applyAsDouble("10.35"));  
    }  
  
    private static void toIntFunctionExample() {  
  
        System.out.println("### toIntFunctionExample ###");  
  
        ToIntFunction<Double> tif1 = (Double d) -> d.intValue();  
        ToIntFunction<String> tif2 = (String s) -> Integer.parseInt(s);  
        ToIntFunction<String> tif3 = Integer::parseInt;  
  
        System.out.println(tif1.applyAsInt(10.0));  
        System.out.println(tif2.applyAsInt("10"));  
        System.out.println(tif3.applyAsInt("10"));  
  
        var d = 1.0;  
        ToIntFunction f1 = x -> 1;  
        f1.applyAsInt(d);  
    }  
  
    private static void toLongFunctionExample() {  
  
        System.out.println("### toLongFunctionExample ###");  
  
        ToLongFunction<Long> tlf1 = (Long i) -> i * 5;  
        ToLongFunction<String> tlf2 = (String s) -> Long.parseLong(s);  
        ToLongFunction<String> tlf3 = Long::parseLong;  
  
  
        System.out.println(tlf1.applyAsLong(10L));  
        System.out.println(tlf2.applyAsLong("10"));  
        System.out.println(tlf3.applyAsLong("10"));  
    }  
  
}
```

**ToXyzBiFunctionInterfaces**

```java
public class ToXyzBiFunctionInterfaces {  
  
    public static void main(String[] args) {  
  
        toDoubleBiFunctionExample();  
        toIntBiFunctionExample();  
        toLongBiFunctionExample();  
  
    }  
  
    private static void toDoubleBiFunctionExample() {  
  
        System.out.println("### toDoubleBiFunctionExample ###");  
  
        ToDoubleBiFunction<Integer, Integer> tdbf1 = (i, j) -> i + j;  
        ToDoubleBiFunction<Integer, Integer> tdbf2 = (Integer i, Integer j) -> (i + j) * 5.2;  
        ToDoubleBiFunction<Double, Double> tdbf3 = (var d1, var d2) -> Double.max(d1, d2);  
        ToDoubleBiFunction<Double, Double> tdbf4 = Double::min;  
  
        System.out.println(tdbf1.applyAsDouble(15, 20));  
        System.out.println(tdbf2.applyAsDouble(15, 20));  
        System.out.println(tdbf3.applyAsDouble(15.0, 20.0));  
        System.out.println(tdbf4.applyAsDouble(15.0, 20.0));  
    }  
  
    private static void toIntBiFunctionExample() {  
  
        System.out.println("### toIntBiFunctionExample ###");  
  
        ToIntBiFunction<Integer, Integer> tibf1 = (i, j) -> i + j;  
        ToIntBiFunction<Integer, Integer> tibf2 = Integer::max;  
        ToIntBiFunction<Integer, Integer> tibf3 = Integer::compareTo;  
        ToIntBiFunction<String, String> tibf4 = (str1, str2) -> str1.length() + str2.length();  
  
        System.out.println(tibf1.applyAsInt(10, 20));  
        System.out.println(tibf2.applyAsInt(10, 20));  
        System.out.println(tibf3.applyAsInt(10, 20));  
        System.out.println(tibf4.applyAsInt("content1", "content2"));  
    }  
  
  
    private static void toLongBiFunctionExample() {  
  
        System.out.println("### toLongBiFunctionExample ###");  
        ToLongBiFunction<String, String> tlbf1 = (var str1, var str2) -> str1.length() + str2.length();  
        ToLongBiFunction<Long, Long> tlbf2 = Math::max;  
        ToLongBiFunction<Integer, Integer> tlbf3 = Math::max;  
        ToLongBiFunction<Long, Long> tlbf4 = Long::max;  
  
        System.out.println(tlbf1.applyAsLong("key", "value"));  
        System.out.println(tlbf2.applyAsLong(100L, 2000L));  
        System.out.println(tlbf3.applyAsLong(100, 2000));  
        System.out.println(tlbf4.applyAsLong(100L, 2000L));  
    }  
}
```

**XToYFunction**

```java
public class XToYFunction {  
  
    public static void main(String[] args) {  
  
        doubleToIntFunctionExample();  
        doubleToLongFunctionExample();  
        intToDoubleFunctionExample();  
        intToLongFunctionExample();  
        longToDoubleFunctionExample();  
        longToIntFunctionExample();  
    }  
      
    private static void doubleToIntFunctionExample() {  
  
        System.out.println("### doubleToIntFunctionExample ###");  
        DoubleToIntFunction dtif1 = (double d1) -> (int) d1;  
        DoubleToIntFunction dtif2 = Helper::ceil;  
  
        System.out.println(dtif1.applyAsInt(10.5));  
        System.out.println(dtif2.applyAsInt(10.5));  
  
        var d = 1.0;  
        DoubleToIntFunction f1 = x -> 1;  
        f1.applyAsInt(d);  
    }  
  
    private static void doubleToLongFunctionExample() {  
  
        System.out.println("### doubleToLongFunctionExample ###");  
        DoubleToLongFunction dtlf1 = (double d1) -> (long) d1;  
        DoubleToLongFunction dtlf2 = Helper::ceil;  
  
        System.out.println(dtlf1.applyAsLong(10.5));  
        System.out.println(dtlf2.applyAsLong(10.5));  
    }  
  
    private static void intToDoubleFunctionExample() {  
  
        System.out.println("### doubleToLongFunctionExample ###");  
        IntToDoubleFunction itdf1 = (int i) -> i;  
        IntToDoubleFunction itdf2 = (int i) -> Math.sqrt(i);  
        IntToDoubleFunction itdf3 = Math::sqrt;  
  
        System.out.println(itdf1.applyAsDouble(15));  
        System.out.println(itdf2.applyAsDouble(15));  
        System.out.println(itdf3.applyAsDouble(15));  
    }  
  
  
    private static void intToLongFunctionExample() {  
  
        System.out.println("### intToLongFunctionExample ###");  
        IntToLongFunction itlf1 = (int i) -> i;  
        IntToLongFunction itlf2 = (int i) -> i * 10L;  
        IntToLongFunction itlf3 = (int i) -> Long.valueOf(i);  
        IntToLongFunction itlf4 = Long::valueOf;  
  
        System.out.println(itlf1.applyAsLong(15));  
        System.out.println(itlf2.applyAsLong(15));  
        System.out.println(itlf3.applyAsLong(15));  
        System.out.println(itlf4.applyAsLong(15));  
    }  
  
  
    private static void longToDoubleFunctionExample() {  
  
        System.out.println("### longToDoubleFunctionExample ###");  
        LongToDoubleFunction ltdf1 = (long x) -> x;  
        LongToDoubleFunction ltdf2 = (var x) -> x * 2.0;  
        LongToDoubleFunction ltdf3 = Double::valueOf;  
        LongToDoubleFunction ltdf4 = Math::sqrt;  
  
  
        System.out.println(ltdf1.applyAsDouble(10));  
        System.out.println(ltdf2.applyAsDouble(15));  
        System.out.println(ltdf3.applyAsDouble(20));  
        System.out.println(ltdf4.applyAsDouble(25));  
    }  
  
    private static void longToIntFunctionExample() {  
  
        System.out.println("### longToIntFunctionExample ###");  
  
        LongToIntFunction ltif1 = (var x) -> (int) x;  
        LongToIntFunction ltif2 = (long i) -> Math.toIntExact(i);  
        LongToIntFunction ltif3 = Math::toIntExact;  
  
        System.out.println(ltif1.applyAsInt(100L));  
        System.out.println(ltif2.applyAsInt(100L));  
        System.out.println(ltif3.applyAsInt(100L));  
    }  
  
}  
  
class Helper {  
  
    static int ceil(double d) {  
        return (int) Math.ceil(d);  
    }  
}
```

**ObjXyzConsumerInterfaces**

```java
public class ObjXyzConsumerInterfaces {  
  
    public static void main(String[] args) {  
  
        objDoubleConsumerExample();  
        objIntConsumerExample();  
        objLongConsumerExample();  
    }  
  
    private static void objDoubleConsumerExample() {  
        System.out.println("### objDoubleConsumerExample ###");  
        ObjDoubleConsumer<String> odc1 = (String str, double d) -> System.out.println(Double.parseDouble(str) + d);  
        odc1.accept("100.5", 20);  
    }  
  
    private static void objIntConsumerExample() {  
        System.out.println("### objIntConsumerExample ###");  
        ObjIntConsumer<String> odc1 = (String str, int d) -> System.out.println(Double.parseDouble(str) + d);  
        odc1.accept("100.5", 20);  
    }  
  
    private static void objLongConsumerExample() {  
        System.out.println("### objLongConsumerExample ###");  
        ObjLongConsumer<String> odc1 = (String str, long d) -> System.out.println(Double.parseDouble(str) + d);  
        odc1.accept("100.5", 20);  
    }  
}
```

## Working with Variables in Lambdas

They can appear in three places with respect to lambdas: 
- ==**the parameter list,**== 
- ==**local variables declared inside the lambda body,**==  
- ==**variables referenced from the lambda body.==** 
 
All three of these are opportunities for the exam to trick you

### Listing Parameters

specifying the type of parameters is optional. Additionally, ``var`` can be used in place of the specific type. That means that all three of these statements are interchangeable:

```java
Predicate<String> p = x -> true;
Predicate<String> p = (var x) -> true;
Predicate<String> p = (String x) -> true;
```

The exam might ask you to identify the type of the lambda parameter. A lambda infers the types from the surrounding context. That means you get to do the same.  Another place to look for the type is in a method signature.

```java
public void whatAmI() {
	consume((var x) -> System.out.print(x), 123);
}

public void consume(Consumer<Integer> c, int num) {
	c.accept(num);
}
```

The ``whatAmI()`` method creates a lambda to be passed to the ``consume()`` method. Since the ``consume()`` method expects an ``Integer`` as the generic, we know that is what the inferred type of ``x`` will be. In some cases, you can determine the type without even seeing the method signature

```java
public void counts(List<Integer> list) {
	list.sort((var x, var y) -> x.compareTo(y));
}
```

Since we are sorting a list, we can use the type of the list to determine the type of the lambda parameter.
**==Since lambda parameters are just like method parameters, you can add modifiers to them. Specifically, you can add the ``final`` modifier or an ``annotation``==**

```java
public void counts(List<Integer> list) {
	list.sort((final var x, @Deprecated var y) -> x.compareTo(y));
}
```

---
**Parameter List Formats**

**You have three formats for specifying parameter types within a lambda: without types, with types, and with ``var``. ==The compiler requires all parameters in the lambda to use the same format==.**

```java
5: (var x, y) -> "Hello" // DOES NOT COMPILE
6: (var x, Integer y) -> true // DOES NOT COMPILE
7: (String x, var y, Integer z) -> true // DOES NOT COMPILE
8: (Integer x, y) -> "goodbye" // DOES NOT COMPILE
```

- Lines 5 needs to remove var from x or add it to y
- lines 6 and 7 need to use the type or var consistently.
- line 8 needs to remove Integer from x or add a type to y.
---
### Using Local Variables Inside a Lambda Body

While it is most common for a lambda body to be a single expression, it is legal to define a block. That block can have anything that is valid in a normal Java block, including local variable declarations.

```java
(a, b) -> { int c = 0; return 5; }
(a, b) -> { int a = 0; return 5; } // DOES NOT COMPILE
```

We tried to redeclare ``a``, which is not allowed. **==Java doesn’t let you create a local variable with the same name as one already declared in that scope==**. While this kind of error is less likely to come up in real life, it has been known to appear on the exam!

```java
11: public void variables(int a) {
		12: int b = 1;
		13: Predicate<Integer> p1 = a ->{
		14: int b = 0;
		15: int c = 0;
	16: return b == c; }
17: }
```

- The first is on line 13. The variable ``a`` was already used in this scope as a method parameter, so it cannot be reused.
- line 14, where the code attempts to redeclare local variable ``b``.
- The variable ``p1`` is missing a semicolon at the end. There is a semicolon before the }, but that is inside the block.
### Referencing Variables from the Lambda Body

Lambda bodies are allowed to reference some variables from the surrounding code.

```java
import java.util.function.Consumer;

public class Crow {
    private String color;
    
    public void caw(String name) {
        String volume = "loudly";
        Consumer<String> consumer = s ->
            System.out.println(name + " says " + volume + " that she is " + color);
    }
}
```

a lambda can access an instance variable, method parameter, or local variable under certain conditions. **==Instance variables (and class variables) are always allowed. The only thing lambdas cannot access are variables that are not final or effectively final.==** 

```java
2: public class Crow {
	3: private String color;
	4: public void caw(String name) {
		5: String volume = "loudly";
		6: name = "Caty";
		7: color = "black";
	8:
	9: Consumer<String> consumer = s ->
		10: System.out.println(name + " says " // DOES NOT COMPILE
		11: + volume + " that she is " + color); // DOES NOT COMPILE
		12: volume = "softly";
	13: }
14: }
```

- The method parameter name is not effectively final because it is set on line 6.
- However, the compiler error occurs on line 10.
- It’s not a problem to assign a value to a non-final variable.
- However, once the lambda tries to use it, we do have a problem.
- The variable is no longer effectively final, so the lambda is not allowed to use the variable.
- The variable volume is not effectively final either since it is updated on line 12.
- In this case, the compiler error is on line 11. That’s before the reassignment.

![[Pasted image 20240403154441.png]]

## Summary #OCP_Summary 

**==Lambda expressions, or lambdas, allow passing around blocks of code. The full syntax looks like this==:**
```java
(String a, String b) -> { return a.equals(b); }
```

**==The parameter types can be omitted. When only one parameter is specified without a type, the parentheses can also be omitted. The braces and ``return`` statement can be omitted for a single statement, making the short form as follows:==**

```java
a -> a.equals(b)
```

**==Lambdas can be passed to a method expecting an instance of a functional interface. A lambda can define parameters or variables in the body as long as their names are different from existing local variables. The body of a lambda is allowed to use any instance or class variables. Additionally, it can use any local variables or method parameters that are ``final`` or effectively final.**==

==**A method reference is a compact syntax for writing lambdas that refer to methods. There are four types: ``static`` methods, instance methods on a particular object, instance methods on a parameter, and constructor references.**==

==**A functional interface has a single abstract method. Any functional interface can be implemented with a lambda expression. You must know the built-in functional interfaces.==**

## Exam Essentials #Essential 

**Write simple lambda expressions**. Look for the presence or absence of optional elements in lambda code. **==Parameter types are optional. Braces and the return keyword are optional when the body is a single statement. Parentheses are optional when only one parameter is specified and the type is implicit.==**

**Determine whether a variable can be used in a lambda body**. **==Local variables and method parameters must be final or effectively final to be referenced. This means the code must compile if you were to add the final keyword to these variables. Instance and class variables are always allowed.==**

**Translate method references to the “long form” lambda.** Be able to convert method references into regular lambda expressions and vice versa. For example, ``System.out::print`` and ``x -> System.out.print(x)`` are equivalent. Remember that the order of method parameters is inferred when using a method reference.

**Determine whether an interface is a functional interface**. Use the single abstract method
(SAM) rule to determine whether an interface is a functional interface. **==Other interface method types (``default``, ``private``, ``static``, and ``private static``) do not count toward the single abstract method count, nor do any ``public`` methods with signatures found in ``Object``.==**

**Identify the correct functional interface given the number of parameters, return type, and method name—and vice versa.** The most common functional interfaces are Supplier, Consumer, Function, and Predicate. There are also binary versions and primitive versions of many of these methods. You can use the number of parameters and return type to tell them apart.
## Review Questions

1. What is the result of the following class?
```java
1: import java.util.function.*;
2:
3: public class Panda {
4: int age;
5: public static void main(String[] args) {
6: Panda p1 = new Panda();
7: p1.age = 1;
8: check(p1, p -> p.age < 5);
9: }
10: private static void check(Panda panda,
11: Predicate<Panda> pred) {
12: String result =
13: pred.test(panda) ? "match" : "not match";
14: System.out.print(result);
15: } }
```

A. match
B. not match
C. Compiler error on line 8
D. Compiler error on lines 10 and 11
E. Compiler error on lines 12 and 13
F. A runtime exception is thrown.

**My Answer: A**
**Correct Answer: A**

**Line 8 creates a lambda expression that checks whether the age is less than 5, making option A correct. Since there is only one parameter and it does not specify a type, the parentheses around the parameter are optional. Lines 11 and 13 use the Predicate interface, which declares a test() method.**

---

2. What is the result of the following code?

```JAVA
1: interface Climb {
2: boolean isTooHigh(int height, int limit);
3: }
4:
5: public class Climber {
6: public static void main(String[] args) {
7: check((h, m) -> h.append(m).isEmpty(), 5);
8: }
9: private static void check(Climb climb, int height) {
10: if (climb.isTooHigh(height, 10))
11: System.out.println("too high");
12: else
13: System.out.println("ok");
14: }
15: }
```

A. ok
B. too high
C. Compiler error on line 7
D. Compiler error on line 10
E. Compiler error on a different line
F. A runtime exception is thrown.

**My Answer: C**
**Correct Answer: C**

**The interface takes two int parameters. The code on line 7 attempts to use them as if h is a String making option C correct. It is tricky to use types in a lambda when they are implicitly specified. Remember to check the interface for the real type.**

----

3. Which statements about functional interfaces are true? (Choose all that apply.)

A. A functional interface can contain default and private methods.
B. A functional interface can be defined as a class or an interface.
C. Abstract methods with signatures that are contained in public methods of java.lang.Object do not count toward the abstract method count for a functional interface.
D. A functional interface cannot contain static or private static methods.
E. A functional interface must be marked with the @FunctionalInterface annotation.

**My Answer: A,C**
**Correct Answer: A,C**


---

4. Which lambda can replace the MySecret class to return the same value? (Choose all that apply.)

```java
interface Secret {
String magic(double d);
}
class MySecret implements Secret {
public String magic(double d) {
return "Poof";
} }
```

A. (e) -> "Poof"
B. (e) -> {"Poof"}
C. (e) -> { String e = ""; "Poof" }
D. (e) -> { String e = ""; return "Poof"; }
E. (e) -> { String e = ""; return "Poof" }
F. (e) -> { String f = ""; return "Poof"; }

**My Answer: A,F**
**Correct Answer: A,F**

**Option B is incorrect because it does not use the return keyword. Options C, D, and E are incorrect because the variable e is already in use from the lambda and cannot be redefined. Additionally, option C is missing the return keyword, and option E is missing the semicolon. Therefore, options A and F are correct.**

---

5. Which of the following functional interfaces contain an abstract method that returns a primitive value? (Choose all that apply.)

A. BooleanSupplier
B. CharSupplier
C. DoubleSupplier
D. FloatSupplier
E. IntSupplier
F. StringSupplier

**My Answer: A**
**Correct Answer: A,C,E**
 
 **Java includes support for three primitive streams, along with numerous functional interfaces to go with them: int, double, and long. For this reason, options C and E are correct. Additionally, there is a BooleanSupplier functional interface, making option A correct**

---

6. Which of the following lambda expressions can be passed to a function of ``Predicate<String>`` type? (Choose all that apply.)
A. s -> s.isEmpty()
B. s -- > s.isEmpty()
C. (String s) -> s.isEmpty()
D. (String s) -- > s.isEmpty()
E. (StringBuilder s) -> s.isEmpty()
F. (StringBuilder s) --> s.isEmpty()

**My Answer: A,C**
**Correct Answer: A,C**

**``Predicate<String>`` takes a parameter list of one parameter using the specified type. Options E and F are incorrect because they specify the wrong type. Options B and D are incorrect because they use the wrong syntax for the arrow operator. This leaves us with options A and C as the answers.**

---

7. Which of these statements is true about the following code?
```JAVA
public void method() {
	x((var x) -> {}, (var x, var y) -> false);
}
public void x(Consumer<String> x, BinaryOperator<Boolean> y) {}
```

A. The code does not compile because of one of the variables named x.
B. The code does not compile because of one of the variables named y.
C. The code does not compile for another reason.
D. The code compiles, and the x in each lambda refers to the same type.
E. The code compiles, and the x in each lambda refers to a different type.

**My Answer: E**
**Correct Answer: E**

**While there appears to have been a variable name shortage when this code was written, it does compile. Lambda variables and method names are allowed to be the same. The x lambda parameter is scoped to within each lambda, so it is allowed to be reused. The type is inferred by the method it calls. The first lambda maps x to a String and the second to a Boolean. Therefore, option E is correct.**

---

8. Which of the following is equivalent to this code? (Choose all that apply.) ``UnaryOperator<Integer> u = x -> x * x;``

`A. BiFunction<Integer> f = x -> x*x;`
`B. BiFunction<Integer, Integer> f = x -> x*x;`
`C. BinaryOperator<Integer, Integer> f = x -> x*x;`
`D. Function<Integer> f = x -> x*x;`
`E. Function<Integer, Integer> f = x -> x*x;`
F. None of the above

**My Answer: B,C,D**
**Correct Answer: E**

**The question starts with a ``UnaryOperator<Integer>``, which takes one parameter and returns a value of the same type. Therefore, option E is correct, as UnaryOperator extends Function. Notice that other options don’t even compile because they have the wrong number of generic types for the functional interface provided.**

---

9. Which statements are true? (Choose all that apply.)

A. The Consumer interface is good for printing out an existing value.
B. The Supplier interface is good for printing out an existing value.
C. The IntegerSupplier interface returns an int.
D. The Predicate interface returns an int.
E. The Function interface has a method named test().
F. The Predicate interface has a method named test()

**My Answer: A,E**
**Correct Answer: A,E**

**Option C is tricky. IntSupplier does return an int. However, the option asks about IntegerSupplier, which doesn’t exist.**

---

10.  Which of the following can be inserted without causing a compilation error? (Choose all that apply.)

```java
public void remove(List<Character> chars) {
char end = 'z';
Predicate<Character> predicate = c ->
{
	char start = 'a'; return start <= c && c <= end; };
	// INSERT LINE HERE
}
```

A. char start = 'a';
B. char c = 'x';
C. chars = null;
D. end = '1';
E. None of the above

**My Answer: E**
**Correct Answer: A,B,C**

**Since the scope of start and c is within the lambda, the variables can be declared or updated after it without issue, making options A, B, and C correct. Option D is incorrect because setting end prevents it from being effectively final.**

---

11. How many times is true printed out by this code?

```java
import java.util.function.Predicate;
public class Fantasy {
public static void scary(String animal) {
var dino = s -> "dino".equals(animal);
var dragon = s -> "dragon".equals(animal);
var combined = dino.or(dragon);
System.out.println(combined.test(animal));
}
public static void main(String[] args) {
scary("dino");
scary("dragon");
scary("unicorn");
}
}
```

A. One
B. Two
C. Three
D. The code does not compile.
E. A runtime exception is thrown.

**My Answer: B**
**Correct Answer: E**

**The code does not compile because the lambdas are assigned to var. The compiler does not have enough information to determine they are of type ``Predicate<String>``. Therefore, option D is correct.**

---

12. What does the following code output?

```JAVA
Function<Integer, Integer> s = a -> a + 4;
Function<Integer, Integer> t = a -> a * 3;
Function<Integer, Integer> c = s.compose(t);
System.out.print(c.apply(1));
```

A. 7
B. 15
C. The code does not compile because of the data types in the lambda expressions.
D. The code does not compile because of the compose() call.
E. The code does not compile for another reason.

**My Answer: A**
**Correct Answer: A**


---

13. Which is true of the following code?

```JAVA
int length = 3;
for (int i = 0; i<3; i++) {
if (i%2 == 0) {
Supplier<Integer> supplier = () -> length; // A
System.out.println(supplier.get()); // B
} else {
int j = i;
Supplier<Integer> supplier = () -> j; // C
System.out.println(supplier.get()); // D
}
}
```

A. The first compiler error is on line A.
B. The first compiler error is on line B.
C. The first compiler error is on line C.
D. The first compiler error is on line D.
E. The code compiles successfully.

**My Answer: C**
**Correct Answer: E**

**Lambdas are only allowed to reference final or effectively final variables. You can tell the variable j is effectively final because adding a final keyword before it wouldn’t introduce a compiler error. ==Each time the else statement is executed, the variable is redeclared and goes out of scope. Therefore, it is not reassigned==. Similarly, length is effectively final. There are no compiler errors, and option E is correct.**

----

14. Which of the following are valid lambda expressions? (Choose all that apply.)

`A. (Wolf w, var c) -> 39`
`B. (final Camel c) -> {}`
`C. (a,b,c) -> {int b = 3; return 2;}`
`D. (x,y) -> new RuntimeException()`
`E. (var y) -> return 0;`
`F. () -> {float r}`
`G. (Cat a, b) -> {}`

**My Answer: B,D**
**Correct Answer: B,D**

**Option B is a valid functional interface, one that could be assigned to a ``Consumer<Camel>`` reference. Notice that the final modifier is permitted on variables in the parameter list. Option D is correct, as the exception is being returned as an object and not thrown. This would be compatible with a BiFunction that included RuntimeException as its return type. Options A and G are incorrect because they mix format types for the parameters. Option C is invalid because the variable b is used twice. Option E is incorrect, as a return statement is permitted only inside braces ({}). Option F is incorrect because the variable declaration requires a semicolon (;) after it.**

---

15. Which lambda expression, when entered into the blank line in the following code, causes the program to print hahaha? (Choose all that apply.)

```JAVA
import java.util.function.Predicate;
public class Hyena {
private int age = 1;
public static void main(String[] args) {
var p = new Hyena();
double height = 10;
int age = 1;
testLaugh(p, );
age = 2;
}
static void testLaugh(Hyena panda, Predicate<Hyena> joke) {
var r = joke.test(panda) ? "hahaha" : "silence";
System.out.print(r);
}
}
```

A. var -> p.age <= 10
B. shenzi -> age == 1
C. p -> true
D. age ``==`` 1
E. shenzi -> age ``==`` 2
F. h -> h.age < 5
G. None of the above, as the code does not compile

**My Answer: G**
**Correct Answer: A,F**

**Option A is a valid lambda expression. While main() is a static method, it can access age since it is using a reference to an instance of Hyena, which is effectively final in this method. Since var is not a reserved word, it may be used for variable names. Option F is also correct, with the lambda variable being a reference to a Hyena object. The variable is processed using deferred execution in the testLaugh() method. Options B and E are incorrect; since the local variable age is not effectively final, this would lead to a compilation error. Option C would also cause a compilation error, since the expression uses the variable name p, which is already declared within the method. Finally, option D is incorrect, as this is not even a lambda expression.**

---

16. Which of the following can be inserted without causing a compilation error? (Choose all that apply.)

```java
public void remove(List<Character> chars) {
	char end = 'z';
	// INSERT LINE HERE
Predicate<Character> predicate = c ->
{
char start = 'a'; return start <= c && c <= end; };
}
```

A. char start = 'a';
B. char c = 'x';
C. chars = null;
D. end = '1';
E. None of the above

**My Answer: E**
**Correct Answer: C**

**Lambdas are not allowed to redeclare local variables, making options A and B incorrect. Option D is incorrect because setting end prevents it from being effectively final. Lambdas are only allowed to reference final or effectively final variables. Option C compiles since chars is not used.**

---

17. What is the result of running the following class?

```java
2:
3: public class Panda {
4: int age;
5: public static void main(String[] args) {
6: Panda p1 = new Panda();
7: p1.age = 1;
8: check(p1, p -> {p.age < 5});
9: }
10: private static void check(Panda panda,
11: Predicate<Panda> pred) {
12: String result = pred.test(panda)
13: ? "match" : "not match";
14: System.out.print(result);
15: } }
```

A. match
B. not match
C. Compiler error on line 8
D. Compiler error on line 10
E. Compiler error on line 12
F. A runtime exception is thrown.

**My Answer: C**
**Correct Answer: C**

**Line 8 uses braces around the body. This means the return keyword and semicolon are required. Since the code doesn’t compile, option C is the answer.**

---

18. Which functional interfaces complete the following code? For line 7, assume m and n are instances of functional interfaces that exist and have the same type as y. (Choose three.)

```JAVA
6: ?? x = String::new;
7: ?? y = m.andThen(n);
8: ?? z = a -> a + a;
```

`A. BinaryConsumer<String, String>`
`B. BiConsumer<String, String>`
`C. BinaryFunction<String, String>`
`D. BiFunction<String, String>`
`E. Predicate<String>`
`F. Supplier<String>`
`G. UnaryOperator<String>`
`H. UnaryOperator<String, String>`

**My Answer: B,F,G**
**Correct Answer: B,F,G**


---

19. Which of the following compiles and prints out the entire set? (Choose all that apply.)

```JAVA
Set<?> set = Set.of("lion", "tiger", "bear");
var s = Set.copyOf(set);
Consumer<Object> consumer = ?? ;
s.forEach(consumer);
```

A. () -> System.out.println(s)
B. s -> System.out.println(s)
C. (s) -> System.out.println(s)
D. System.out.println(s)
E. System::out::println
F. System.out::println

**My Answer: B,E**
**Correct Answer: F**

**While there is a lot in this question trying to confuse you, note that there are no options about the code not compiling. This allows you to focus on the lambdas and method references. Option A is incorrect because a Consumer requires one parameter. Options B and C are close. The syntax for a lambda is correct. However, s is already defined as a local variable, and therefore the lambda can’t redefine it. Options D and E use incorrect syntax for a method reference. Option F is correct.**

---

20. Which lambdas can replace the new Sloth() call in the main() method and produce the same output at runtime? (Choose all that apply.)

```JAVA
import java.util.List;
interface Yawn {
String yawn(double d, List<Integer> time);
}
class Sloth implements Yawn {
public String yawn(double zzz, List<Integer> time) {
return "Sleep: " + zzz;
} }
public class Vet {
public static String takeNap(Yawn y) {
return y.yawn(10, null);
}
public static void main(String... unused) {
System.out.print(takeNap(new Sloth()));
} }
```


```java
A. (z,f) -> { String x = ""; return "Sleep: " + x }
B. (t,s) -> { String t = ""; return "Sleep: " + t; }
C. (w,q) -> {"Sleep: " + w}
D. (e,u) -> { String g = ""; "Sleep: " + e }
E. (a,b) -> "Sleep: " + (double)(b==null ? a : a)
F. (r,k) -> { String g = ""; return "Sleep:"; }
G. None of the above, as the program does not compile
```

**My Answer: E**
**Correct Answer: E**

**Option A does not compile because the second statement within the block is missing a semicolon (;) at the end. Option B is an invalid lambda expression because t is defined twice: in the parameter list and within the lambda expression. Options C and D are both missing a return statement and semicolon. Options E and F are both valid lambda expressions, although only option E matches the behavior of the Sloth class. In particular, option F only prints Sleep:, not Sleep: 10.0.**

---

21.  Which of the following are valid functional interfaces? (Choose all that apply.)

```JAVA
public interface Transport {
public int go();
public boolean equals(Object o);
}
public abstract class Car {
public abstract Object swim(double speed, int duration);
}
public interface Locomotive extends Train {
public int getSpeed();
}
public interface Train extends Transport {}
abstract interface Spaceship extends Transport {
default int blastOff();
}
public interface Boat {
int hashCode();
int hashCode(String input);
}
```

A. Boat
B. Car
C. Locomotive
D. Spaceship
E. Transport
F. Train
G. None of these is a valid functional interface.

**My Answer: A,E,F**
**Correct Answer: A,E,F**

**A valid functional interface is one that contains a single abstract method, excluding any public methods that are already defined in the java.lang.Object class. Transport and Boat are valid functional interfaces, as they each contain a single abstract method: go() and hashCode(String), respectively. This gives us options A and E. Since the other methods are part of Object, they do not count as abstract methods. Train is also a functional interface since it extends Transport and does not define any additional abstract methods. This adds option F as the final correct answer.**

**Car is not a functional interface because it is an abstract class. Locomotive is not a functional interface because it includes two abstract methods, one of which is inherited. Finally, Spaceship is not a valid interface, let alone a functional interface, because a default method must provide a body. A quick way to test whether an interface is a functional interface is to apply the @FunctionalInterface annotation and check if the code still compiles.**

---

# Chapter 9 Collections and Generics  #Chapter

## Using Common Collection APIs

A *collection* is a group of objects contained in a single object. The *Java Collections Framework* is a set of classes in ``java.util`` for storing collections. There are four main interfaces in the Java Collections Framework.

- **List**: A list is an ordered collection of elements that allows duplicate entries. Elements in a list can be accessed by an int index.
- **Set**: A set is a collection that does not allow duplicate entries.
- **Queue**: A queue is a collection that orders its elements in a specific order for processing. A Deque is a subinterface of Queue that allows access at both ends.
- **Map**: A map is a collection that maps keys to values, with no duplicate keys allowed. The elements in a map are key/value pairs.

![[Pasted image 20240405233314.png]]

Notice that ``Map`` doesn’t implement the ``Collection`` interface. It is considered part of the Java Collections Framework even though it isn’t technically a ``Collection``. It is a collection (note the lowercase), though, in that it contains a group of objects. **==The reason maps are treated differently is that they need different methods due to being key/value pairs.==**

### Using the Diamond Operator

When constructing a Java Collections Framework, you need to specify the type that will go inside.

```java
List<Integer> list = new ArrayList<Integer>();
Map<Long,List<Integer>> mapLists = new HashMap<Long,List<Integer>>();
```

That’s a lot of duplicate code to write! Luckily, the diamond operator ``(<>)`` is a shorthand notation that allows you to omit the generic type from the right side of a statement when the type can be inferred. It is called the diamond operator because ``<>`` looks like a diamond.

```java
List<Integer> list = new ArrayList<>();
Map<Long,List<Integer>> mapOfLists = new HashMap<>();
```

To the compiler, both these declarations and our previous ones are equivalent. **==The diamond operator cannot be used as the type in a variable declaration. It can be used only on the right side of an assignment operation==**

```java
List<> list = new ArrayList<Integer>(); // DOES NOT COMPILE

class InvalidUse {
	void use(List<> data) {} // DOES NOT COMPILE
}
```

### Adding Data

The ``add()`` method inserts a new element into the ``Collection`` and returns whether it was successful.

```java
	public boolean add(E element)
```

For some ``Collection`` types, ``add()`` always returns true. For other types, there is logic as to whether the ``add()`` call was successful.

```java
3: Collection<String> list = new ArrayList<>();
4: System.out.println(list.add("Sparrow")); // true
5: System.out.println(list.add("Sparrow")); // true
6:
7: Collection<String> set = new HashSet<>();
8: System.out.println(set.add("Sparrow")); // true
9: System.out.println(set.add("Sparrow")); // false
```

### Removing Data

The ``remove()`` method removes a single matching value in the ``Collection`` and returns whether it was successful.

```java
public boolean remove(Object object
```

```java
3: Collection<String> birds = new ArrayList<>();
4: birds.add("hawk"); // [hawk]
5: birds.add("hawk"); // [hawk, hawk]
6: System.out.println(birds.remove("cardinal")); // false
7: System.out.println(birds.remove("hawk")); // true
8: System.out.println(birds); // [hawk]
```

### Counting Elements

The ``isEmpty()`` and ``size()`` methods look at how many elements are in the ``Collection``

```java
public boolean isEmpty()
public int size()
```

```java
Collection<String> birds = new ArrayList<>();
System.out.println(birds.isEmpty()); // true
System.out.println(birds.size()); // 0
birds.add("hawk"); // [hawk]
birds.add("hawk"); // [hawk, hawk]
System.out.println(birds.isEmpty()); // false
System.out.println(birds.size()); // 2
```

### Clearing the Collection

The ``clear()`` method provides an easy way to discard all elements of the ``Collection``.

```java
public void clear()
```

```java
Collection<String> birds = new ArrayList<>();
birds.add("hawk"); // [hawk]
birds.add("hawk"); // [hawk, hawk]
System.out.println(birds.isEmpty()); // false
System.out.println(birds.size()); // 2
birds.clear(); // []
System.out.println(birds.isEmpty()); // true
System.out.println(birds.size()); // 0
```

### Check Contents

The ``contains()`` method checks whether a certain value is in the ``Collection``.

```java
public boolean contains(Object object)
```

```java
Collection<String> birds = new ArrayList<>();
birds.add("hawk"); // [hawk]
System.out.println(birds.contains("hawk")); // true
System.out.println(birds.contains("robin")); // false
```

The ``contains()`` method calls ``equals()`` on elements of the ``ArrayList`` to see whether there are any matches.

### Removing with Conditions

The ``removeIf()`` method removes all elements that match a condition.

```JAVA
public boolean removeIf(Predicate<? super E> filter)
```

```java
4: Collection<String> list = new ArrayList<>();
5: list.add("Magician");
6: list.add("Assistant");
7: System.out.println(list); // [Magician, Assistant]
8: list.removeIf(s -> s.startsWith("A"));
9: System.out.println(list); // [Magician]
10:
11: Collection<String> set = new HashSet<>();
12: set.add("Wand");
13: set.add("");
14: set.removeIf(String::isEmpty); // s -> s.isEmpty()
15: System.out.println(set); // [Wand]
```

### Iterating

There’s a ``forEach()`` method that you can call on a ``Collection`` instead of writing a loop. It uses a ``Consumer`` that takes a single parameter and doesn’t return anything.

```java
public void forEach(Consumer<? super T> action)
```

```java
Collection<String> cats = List.of("Annie", "Ripley");
cats.forEach(System.out::println);
cats.forEach(c -> System.out.println(c));
```

### Determining Equality

**==There is a custom implementation of ``equals()`` so you can compare two Collections to compare the type and contents==**. The implementation will vary. For example, ``ArrayList`` checks order, while ``HashSet`` does not.

```java
boolean equals(Object object)
```

```java
var list1 = List.of(1, 2);  
var list2 = List.of(2, 1);  
var list3 = List.of(1, 2);  
  
var set1 = Set.of(1, 2);  
var set2 = Set.of(2, 1);  
  
System.out.println(list1.equals(list2)); // false , because the elements are in a different order, and a List cares about order.  
System.out.println(set1.equals(set2)); // true , because a Set is not sensitive to order  
System.out.println(list1.equals(set1)); // false , because the types are different.  
System.out.println(list1.equals(list3)); //true
```

---
**Unboxing nulls**

**Java protects us from many problems with ``Collections``. However, it is still possible to write a ``NullPointerException``:**

```java
3: var heights = new ArrayList<Integer>();
4: heights.add(null);
5: int h = heights.get(0); // NullPointerException
```

**On line 4, we add a ``null`` to the list. This is legal because a ``null`` reference can be assigned to any reference variable. On line 5, we try to unbox that ``null`` to an ``int`` primitive. This is a problem. Java tries to get the ``int`` value of ``null``. Since calling any method on ``null`` gives a ``NullPointerException``, that is just what we get**

---
## Using the ``List`` Interface

use a list when you want an ordered collection that **==can contain duplicate entries. Each element of the ``List`` has an index, and the indexes begin with zero.==** The main thing all ``List`` implementations have in common is that they are ordered and allow duplicates. Beyond that, they each offer different functionality

---

**Pay special attention to which names are classes and which are interfaces. The exam may ask you which is the best class or which is the best interface for a scenario.**

---

### Comparing List Implementations

An ``ArrayList`` is like a resizable array. When elements are added, the ``ArrayList`` automatically grows. When you aren’t sure which collection to use, use an ``ArrayList``. 

**==The main benefit of an ``ArrayList`` is that you can look up any element in constant time. Adding or removing an element is slower than accessing an element. This makes an ``ArrayList`` a good choice when you are reading more often than (or the same amount as) writing to the ``ArrayList``.==**

A ``LinkedList`` is special because it implements both ``List`` and ``Deque``. It has all the methods of a ``List``. It also has additional methods to facilitate adding or removing from the beginning and/or end of the list.

**==The main benefits of a ``LinkedList`` are that you can access, add to, and remove from the beginning and end of the list in constant time. The trade-off is that dealing with an arbitrary index takes linear time. This makes a ``LinkedList`` a good choice when you’ll be using it as ``Deque``.==**

### Creating a ``List`` with a Factory

When you create a ``List`` of type ``ArrayList`` or ``LinkedList``, you know the type. There are a few special methods where you get a ``List`` back but don’t know the type. These methods let you create a ``List`` including data in one line using a factory method. Some of these methods return an immutable object

![[Pasted image 20240406000221.png]]

```java
16: String[] array = new String[] {"a", "b", "c"};
17: List<String> asList = Arrays.asList(array); // [a, b, c]
18: List<String> of = List.of(array); // [a, b, c]
19: List<String> copy = List.copyOf(asList); // [a, b, c]
20:
21: array[0] = "z";
22:
23: System.out.println(asList); // [z, b, c]
24: System.out.println(of); // [a, b, c]
25: System.out.println(copy); // [a, b, c]
26:
27: asList.set(0, "x");
28: System.out.println(Arrays.toString(array)); // [x, b, c]
29:
30: copy.add("y"); // UnsupportedOperationException
```

- Lines 18 and 19 create an immutable ``List``. 
- Line 30 shows it is immutable by throwing an exception when trying to add a value. 
 
All three lists would throw an exception when adding or removing a value. The of and copy lists would also throw one on trying to update an element.

### Creating a ``List`` with a Constructor

Most Collections have two constructors that you need to know for the exam.

```java
var linked1 = new LinkedList<String>();
var linked2 = new LinkedList<String>(linked1);
```

- The first says to create an empty ``LinkedList`` containing all the defaults. 
- The second tells Java that we want to make a copy of another ``LinkedList``.

``ArrayList`` has an extra constructor you need to know.

```java
var list3 = new ArrayList<String>(10);
```

create an ``ArrayList`` containing a specific number of slots, but again not to assign any. You can think of this as the size of the underlying array.

---
**Using ``var`` with ``ArrayList``**

```java
var strings = new ArrayList<String>();
strings.add("a");
for (String s: strings) { }
```

**The type of ``var`` is ``ArrayList<String>``.**

```java
var list = new ArrayList<>();
```

**this does compile. ==The type of the ``var`` is ``ArrayList<Object>``. Since there isn’t a type specified for the generic, Java has to assume the ultimate superclass.**==

```java
var list = new ArrayList<>();
list.add("a");
for (String s: list) { } // DOES NOT COMPILE
```

**The type of ``var`` is ``ArrayList<Object>``. Since there isn’t a type in the diamond operator, Java has to assume the most generic option it can. Therefore, it picks ``Object``, the ultimate superclass. Adding a ``String`` to the list is fine. You can add any subclass of ``Object``. However, in the loop, we need to use the ``Object`` type rather than ``String``.**

---

### Working with ``List`` Methods

The methods in the List interface are for working with indexes.

![[List-methods.png]]

```java
3: List<String> list = new ArrayList<>();
4: list.add("SD"); // [SD]
5: list.add(0, "NY"); // [NY,SD]
6: list.set(1, "FL"); // [NY,FL]
7: System.out.println(list.get(0)); // NY
8: list.remove("NY"); // [FL]
9: list.remove(0); // []
10: list.set(0, "?"); // IndexOutOfBoundsException
```

- Line 5 adds an element at index 0 that bumps the original index 0 to index 1. Notice how the ``ArrayList`` is now automatically one larger.
- Line 10 throws an ``IndexOutOfBoundsException`` because there are no elements in the List. Since there are no elements to replace, even index 0 isn’t allowed.

the ``replaceAll()`` method. It uses a ``UnaryOperator`` that takes one parameter and returns a value of the same type:

```java
var numbers = Arrays.asList(1, 2, 3);
numbers.replaceAll(x -> x*2);
System.out.println(numbers); // [2, 4, 6]
```

The ``replaceAll()`` method calls the lambda on each element of the list and replaces the value at that index.

---

**Overloaded ``remove()`` Methods**

==**two overloaded ``remove()`` methods. The one from ``Collection`` removes an object that matches the parameter. By contrast, the one from ``List`` removes an element at a specified index.**==

**This gets tricky when you have an ``Integer`` type.**

```java
31: var list = new LinkedList<Integer>();
32: list.add(3);
33: list.add(2);
34: list.add(1);
35: list.remove(2);
36: list.remove(Integer.valueOf(2));
37: System.out.println(list); // 3
```

**At the end of line 34, we have [3, 2, 1]. Line 35 passes a primitive, which means we are requesting deletion of the element at index 2. This leaves us with [3, 2]. Then line 36 passes an ``Integer`` object, which means we are deleting the value 2. That brings us to [3].**

---

### Converting from ``List`` to an Array

```java
13: List<String> list = new ArrayList<>();
14: list.add("hawk");
15: list.add("robin");
16: Object[] objectArray = list.toArray();
17: String[] stringArray = list.toArray(new String[0]);
18: list.clear();
19: System.out.println(objectArray.length); // 2
20: System.out.println(stringArray.length); // 2
```

- Line 16 shows that a ``List`` knows how to convert itself to an array. The only problem is that it defaults to an array of class ``Object``
- Line 17 specifies the type of the array and does what we want. The advantage of specifying a size of 0 for the parameter is that Java will create a new array of the proper size for the return value.

## Using the ``Set`` Interface

**==The main thing that all ``Set`` implementations have in common is that they do not allow duplicates.==**

### Comparing ``Set`` Implementations

A ``HashSet`` stores its elements in a hash table, which means the keys are a hash and the values are an Object. This means that **==the ``HashSet`` uses the ``hashCode()`` method of the objects to retrieve them more efficiently. Remember that a valid ``hashCode()`` doesn’t mean every object will get a unique value, but the method is often written so that hash values are spread out over a large range to reduce collisions.==**

The main benefit is that adding elements and checking whether an element is in the set both have constant time. The trade-off is that you lose the order in which you inserted the elements. Most of the time, you aren’t concerned with this in a Set anyway, making ``HashSet`` the most common set.

A ``TreeSet`` stores its elements in a sorted tree structure. The main benefit is that the set is always in sorted order. The trade-off is that adding and checking whether an element exists takes longer than with a ``HashSet``, especially as the tree grows larger.

### Working with ``Set`` Methods

Like a ``List``, you can create an immutable ``Set`` in one line or make a copy of an existing one.

```java
Set<Character> letters = Set.of('z', 'o', 'o');
Set<Character> copy = Set.copyOf(letters);
```

```java
3: Set<Integer> set = new HashSet<>();
4: boolean b1 = set.add(66); // true
5: boolean b2 = set.add(10); // true
6: boolean b3 = set.add(66); // false
7: boolean b4 = set.add(8); // true
8: set.forEach(System.out::println); // 66 - 8 - 10
```

**==the ``equals()`` method is used to determine equality. The ``hashCode()`` method is used to know which bucket to look in so that Java doesn’t have to look through the whole set to find out whether an object is there. The best case is that hash codes are unique and Java has to call ``equals()`` on only one object. The worst case is that all implementations return the same ``hashCode()`` and Java has to call ``equals()`` on every element of the set anyway.==**

```JAVA
3: Set<Integer> set = new TreeSet<>();
4: boolean b1 = set.add(66); // true
5: boolean b2 = set.add(10); // true
6: boolean b3 = set.add(66); // false
7: boolean b4 = set.add(8); // true
8: set.forEach(System.out::println); // 3 - 10 - 66
```

The elements are printed out in their natural sorted order. Numbers implement the ``Comparable`` interface in Java, which is used for sorting.

## Using the ``Queue`` and ``Deque`` Interfaces

use a ``Queue`` when elements are added and removed in a specific order. You can think of a queue as a line. *FIFO*
A ``Deque`` (double-ended queue), often pronounced *deck* is different from a regular queue in that you can insert and remove elements from both the front (head) and back (tail).

All queues have specific requirements for adding and removing the next element. Beyond that, they each offer different functionality

### Comparing ``Deque`` Implementations

``LinkedList`` in addition to being a list, it is a ``Deque``. The main benefit of a ``LinkedList`` is that it implements both the ``List`` and ``Deque`` interfaces. The trade-off is that it isn’t as efficient as a “pure” queue.

### Working with ``Queue`` and ``Deque`` Methods

![[Pasted image 20240406004150.png]]

```java
public class LinkedListQueueExample {  
  
    public static void main(String[] args) {  
  
        linkedListQueueExample();  
        linkedListQueueExample2();  
    }  
  
    private static void linkedListQueueExample() {  
  
        System.out.println("### linkedListQueueExample ###");  
  
        Queue<Integer> queue = new LinkedList<>();  
        queue.add(10);  
        queue.add(4);  
  
        System.out.println(queue.remove()); // 10  
        System.out.println(queue.peek()); //4  
        System.out.println(queue.peek()); //4  
    }  
  
    private static void linkedListQueueExample2() {  
  
        System.out.println("### linkedListQueueExample ###");  
  
        Queue<Integer> queue = new LinkedList<>();  
  
        queue.add(35);  
        queue.offer(10);  
        queue.offer(30);  
        queue.add(25);  
        queue.add(15);  
        queue.add(5);  
  
        System.out.println(queue);  
  
        System.out.println(queue.peek());  
        System.out.println(queue.peek());  
        System.out.println(queue.peek());  
  
        System.out.println(queue);  
        System.out.println(queue.poll());  
        System.out.println(queue.poll());  
        System.out.println(queue);  
        System.out.println(queue.remove());  
        System.out.println(queue.remove());  
        System.out.println(queue);  
        System.out.println(queue.remove());  
        System.out.println(queue.remove());  
        System.out.println(queue);  
  
        System.out.println(queue.poll()); // No Exception!  
        System.out.println(queue.poll()); // No Exception!  
        System.out.println(queue.poll()); // No Exception!  
        System.out.println(queue.poll()); // No Exception!  
  
        System.out.println(queue.remove()); // NoSuchElementException  
  
    }  
}
```

```java
public class PriorityQueueExample {  
  
    public static void main(String[] args) {  
  
        priorityQueueExample();  
        priorityQueueExample2();  
    }  
  
    private static void priorityQueueExample() {  
  
        System.out.println("### priorityQueueExample ###");  
  
        Queue<Integer> queue = new PriorityQueue<>();  
        queue.add(10);  
        queue.add(4);  
  
        System.out.println(queue.remove()); // 10  
        System.out.println(queue.peek()); //4  
        System.out.println(queue.peek()); //4  
    }  
  
    private static void priorityQueueExample2() {  
  
        System.out.println("### priorityQueueExample2 ###");  
  
        Queue<Integer> queue = new PriorityQueue<>();  
  
        queue.add(35);  
        queue.offer(10);  
        queue.offer(30);  
        queue.add(25);  
        queue.add(15);  
        queue.add(5);  
  
        System.out.println(queue);  
  
        System.out.println(queue.peek());  
        System.out.println(queue.peek());  
        System.out.println(queue.peek());  
  
        System.out.println(queue);  
        System.out.println(queue.poll());  
        System.out.println(queue.poll());  
        System.out.println(queue);  
        System.out.println(queue.remove());  
        System.out.println(queue.remove());  
        System.out.println(queue);  
        System.out.println(queue.remove());  
        System.out.println(queue.remove());  
        System.out.println(queue);  
  
        System.out.println(queue.poll()); // No Exception!  
        System.out.println(queue.poll()); // No Exception!  
        System.out.println(queue.poll()); // No Exception!  
        System.out.println(queue.poll()); // No Exception!  
  
        System.out.println(queue.remove()); // NoSuchElementException  
  
    }  
}
```

Since the ``Deque`` interface supports double-ended queues, it inherits all ``Queue`` methods and adds more so that it is clear if we are working with the front or back of the queue.

![[Pasted image 20240406004240.png]]

```java
public static void main(String[] args) {  
  
    Deque<Integer> deque = new LinkedList<>();  
  
    System.out.println(deque.offerFirst(10)); //true  
    System.out.println(deque.offerLast(4));  // true  
    System.out.println(deque);                  // [10, 4]  
    System.out.println(deque.peekFirst());      // 10  
    System.out.println(deque.pollFirst());      // 10  
    System.out.println(deque.pollLast());       // 4  
    System.out.println(deque.pollFirst());      // null  
    System.out.println(deque.pollFirst());      // null  
    System.out.println(deque.removeLast());      // NoSuchElementException  
}
```


```java
public static void main(String[] args) {  
  
    Deque<Integer> arrayDeque = new ArrayDeque<>();  
  
    arrayDeque.addFirst(2);  
    arrayDeque.add(3);  
    arrayDeque.add(4);  
    arrayDeque.addFirst(1);  
    arrayDeque.addFirst(0);  
    arrayDeque.addLast(5);  
    arrayDeque.add(6);  
  
    System.out.println(arrayDeque); // [0, 1, 2, 3, 4, 5, 6]  
  
    System.out.println("peekFirst");  
    System.out.println(arrayDeque.peekFirst());  // 0  
    System.out.println(arrayDeque.peekFirst());  // 0  
    System.out.println(arrayDeque.peekFirst());  // 0  
  
    System.out.println("peekLast");  
    System.out.println(arrayDeque.peekLast());  // 6  
    System.out.println(arrayDeque.peekLast());  // 6  
    System.out.println(arrayDeque.peekLast());  // 6  
  
    System.out.println("peek");  
    System.out.println(arrayDeque.peek());      // 0  
    System.out.println(arrayDeque.peek());      // 0  
    System.out.println(arrayDeque.peek());      // 0  
  
    System.out.println("getFirst");  
    System.out.println(arrayDeque.getFirst());      // 0  
    System.out.println(arrayDeque.getFirst());      // 0  
    System.out.println(arrayDeque.getFirst());      // 0  
  
    System.out.println("getLast");  
    System.out.println(arrayDeque.getLast());      // 6  
    System.out.println(arrayDeque.getLast());      // 6  
    System.out.println(arrayDeque.getLast());      // 6  
  
    System.out.println("removeFirst");  
    System.out.println(arrayDeque.removeFirst());      // 0  
    System.out.println(arrayDeque.removeFirst());      // 1  
    System.out.println(arrayDeque); // [2, 3, 4, 5, 6]  
  
    System.out.println("removeLast");  
    System.out.println(arrayDeque.removeLast());      // 6  
    System.out.println(arrayDeque.removeLast());      // 5  
    System.out.println(arrayDeque); // [2, 3, 4]  
  
    System.out.println("pollFirst");  
    System.out.println(arrayDeque.pollFirst());      // 2  
    System.out.println(arrayDeque); // [3, 4]  
  
    System.out.println("pollLast");  
    System.out.println(arrayDeque.pollLast());      // 4  
    System.out.println(arrayDeque); // [3]  
  
    System.out.println("poll");  
    System.out.println(arrayDeque.poll()); // 3  
    System.out.println(arrayDeque); // []  
    System.out.println(arrayDeque.poll()); // null  
    System.out.println(arrayDeque.poll()); // null  
  
    System.out.println(arrayDeque.pollFirst()); // null  
    System.out.println(arrayDeque.pollLast()); // null  
  
    // System.out.println(arrayDeque.remove()); // NoSuchElementException    // System.out.println(arrayDeque.removeFirst()); // NoSuchElementException    // System.out.println(arrayDeque.removeLast()); // NoSuchElementException}
```

In addition to FIFO queues, there are LIFO (last-in, first-out) queues, which are commonly referred to as *stacks*.

```java
public class StackExample {  
  
    public static void main(String[] args) {  
  
        Stack<Integer> stack = new Stack<>();  
  
        stack.push(50);  
        stack.push(40);  
        stack.push(30);  
        stack.push(20);  
        stack.push(10);  
        System.out.println(stack); // [50, 40, 30, 20, 10]  
  
        System.out.println(stack.peek()); // 10  
        System.out.println(stack.peek()); // 10  
        System.out.println(stack.pop());  // 10  
        System.out.println(stack.pop());  // 20  
        System.out.println(stack.pop());  // 30  
        System.out.println(stack.pop());  // 40  
        System.out.println(stack.pop());  // 50  
    }  
}
```


When using a ``Deque``, it is really important to determine if it is being used as a FIFO queue, a LIFO stack, or a double-ended queue. To review, a FIFO queue is like a line of people. You get on in the back and off in the front. A LIFO stack is like a stack of plates. You put the plate on the top and take it off the top. A double-ended queue uses both ends.

## Using the ``Map`` Interface

use a ``Map`` when you want to identify values by a key. The main thing that all ``Map`` classes have in common is that they have keys and values. 

---

**``Map.of()`` and ``Map.copyOf()``**

**Just like ``List`` and ``Set``, there is a factory method to create a ``Map``.**

```java
Map.of("key1", "value1", "key2", "value2");
```

**Unlike ``List`` and ``Set``, this is less than ideal. Passing keys and values is harder to read because you have to keep track of which parameter is which. Luckily, there is a better way. ``Map`` also provides a method that lets you supply key/value pairs.**

```java
Map.ofEntries(
	Map.entry("key1", "value1"),
	Map.entry("key2", "value2"));
```

---

### Comparing ``Map`` Implementations

A ``HashMap`` stores the keys in a hash table. This means that it uses the ``hashCode()`` method of
the keys to retrieve their values more efficiently. The main benefit is that adding elements and retrieving the element by key both have constant time. The trade-off is that you lose the order in which you inserted the elements. 

A ``TreeMap`` stores the keys in a sorted tree structure. The main benefit is that the keys are always in sorted order. Like a ``TreeSet``, the trade-off is that adding and checking whether a key is present takes longer as the tree grows larger

### Working with ``Map`` Methods

Given that ``Map`` doesn’t extend ``Collection``, more methods are specified on the ``Map`` interface. Since there are both keys and values, we need generic type parameters for both. The class uses K for key and V for value.


![[Pasted image 20240406095011.png]]
![[Pasted image 20240406095019.png]]

### Calling Basic Methods

```java
Map<String, String> map = new HashMap<>();
map.put("koala", "bamboo");
map.put("lion", "meat");
map.put("giraffe", "leaf");
String food = map.get("koala"); // bamboo
for (String key: map.keySet())
	System.out.print(key + ","); // koala,giraffe,lion,
```

Java uses the ``hashCode()`` of the key to determine the order. The order here happens not to be sorted order or the order in which we typed the values.

```java
Map<String, String> map = new TreeMap<>();
map.put("koala", "bamboo");
map.put("lion", "meat");
map.put("giraffe", "leaf");
String food = map.get("koala"); // bamboo
for (String key: map.keySet())
	System.out.print(key + ","); // giraffe,koala,lion,
```

``TreeMap`` sorts the keys as we would expect. If we called ``values()`` instead of ``keys()`` the order of the values would correspond to the order of the keys.

```java
System.out.println(map.contains("lion")); // DOES NOT COMPILE
System.out.println(map.containsKey("lion")); // true
System.out.println(map.containsValue("lion")); // false
System.out.println(map.size()); // 3
map.clear();
System.out.println(map.size()); // 0
System.out.println(map.isEmpty()); // true
```

The first line is a little tricky. The ``contains()`` method is on the ``Collection`` interface but not the ``Map`` interface.
### Iterating through a ``Map``

the lambda used by the ``forEach()`` method has two parameters: the key and the value. 

```java
Map<Integer, Character> map = new HashMap<>();
map.put(1, 'a');
map.put(2, 'b');
map.put(3, 'c');
map.forEach((k, v) -> System.out.println(v));
```

The lambda has both the key and value as the parameters. It happens to print out the value but could do anything with the key and/or value. Interestingly, since we don’t care about the key, this particular code could have been written with the ``values()`` method and a method reference instead.

```java
map.values().forEach(System.out::println);
```

Another way of going through all the data in a map is to get the key/value pairs in a ``Set``. Java has a static interface inside ``Map`` called ``Entry``. It provides methods to get the key and value of each pair.

```java
map.entrySet().forEach(e -> System.out.println(e.getKey() + " " + e.getValue()));
```

### Getting Values Safely

The ``get()`` method returns null if the requested key is not in the map. Sometimes you prefer to have a different value returned. Luckily, the ``getOrDefault()`` method makes this easy.

```java
3: Map<Character, String> map = new HashMap<>();
4: map.put('x', "spot");
5: System.out.println("X marks the " + map.get('x')); // X marks the spot
6: System.out.println("X marks the " + map.getOrDefault('x', "")); // X marks the spot
7: System.out.println("Y marks the " + map.get('y')); // Y marks the null
8: System.out.println("Y marks the " + map.getOrDefault('y', "")); // Y marks the
```

``get()`` and ``getOrDefault()`` behave the same way when the key is present. They return the value mapped by that key.

### Replacing Values

These methods are similar to the ``List`` version, except a key is involved:

```java
21: Map<Integer, Integer> map = new HashMap<>();
22: map.put(1, 2);
23: map.put(2, 4);
24: Integer original = map.replace(2, 10); // 4
25: System.out.println(map); // {1=2, 2=10}
26: map.replaceAll((k, v) -> k + v);
27: System.out.println(map); // {1=3, 2=12}
```

### Putting if Absent

The ``putIfAbsent()`` method sets a value in the map but skips it if the value is already set to a non-null value.

```java
Map<String, String> favorites = new HashMap<>();
favorites.put("Jenny", "Bus Tour");
favorites.put("Tom", null);
favorites.putIfAbsent("Jenny", "Tram");
favorites.putIfAbsent("Sam", "Tram");
favorites.putIfAbsent("Tom", "Tram");
System.out.println(favorites); // {Tom=Tram, Jenny=Bus Tour, Sam=Tram}
```

### Merging Data

The ``merge()`` method adds logic of what to choose.

```java
11: BiFunction<String, String, String> mapper = (v1, v2)
12: -> v1.length()> v2.length() ? v1: v2;
13:
14: Map<String, String> favorites = new HashMap<>();
15: favorites.put("Jenny", "Bus Tour");
16: favorites.put("Tom", "Tram");
17:
18: String jenny = favorites.merge("Jenny", "Skyride", mapper);
19: String tom = favorites.merge("Tom", "Skyride", mapper);
20:
21: System.out.println(favorites); // {Tom=Skyride, Jenny=Bus Tour}
22: System.out.println(jenny); // Bus Tour
23: System.out.println(tom); // Skyride
```

The ``merge()`` method also has logic for what happens if ``null`` values or missing keys are involved. In this case, it doesn’t call the ``BiFunction`` at all, and it simply uses the new value.

```java
BiFunction<String, String, String> mapper =
(v1, v2) -> v1.length()> v2.length() ? v1 : v2;
Map<String, String> favorites = new HashMap<>();
favorites.put("Sam", null);
favorites.merge("Tom", "Skyride", mapper);
favorites.merge("Sam", "Skyride", mapper);
System.out.println(favorites); // {Tom=Skyride, Sam=Skyride}
```

the mapping function isn’t called. If it were, we’d have a ``NullPointerException``. **==The mapping function is used only when there are two actual values to decide between.==** **==The final thing to know about ``merge()`` is what happens when the mapping function is called and returns ``null``. The key is removed from the map when this happens:==**

```java
BiFunction<String, String, String> mapper = (v1, v2) -> null;
Map<String, String> favorites = new HashMap<>();
favorites.put("Jenny", "Bus Tour");
favorites.put("Tom", "Bus Tour");
favorites.merge("Jenny", "Skyride", mapper);
favorites.merge("Sam", "Skyride", mapper);
System.out.println(favorites); // {Tom=Bus Tour, Sam=Skyride}
```

![[Pasted image 20240406100933.png]]

## Comparing Collection Types

![[Pasted image 20240406160311.png]]

![[Pasted image 20240406160415.png]]

**==The data structures that involve sorting do not allow ``null`` values.==**

## Sorting Data

For numbers, order is obvious— it is numerical order. For ``String`` objects, order is defined according to the Unicode character mapping.

---

**==When working with a ``String``, remember that numbers sort before letters, and uppercase letters sort before lowercase letters.==**

---

can also sort objects that you create yourself. Java provides an interface called ``Comparable``. If your class implements ``Comparable``, it can be used in data structures that require comparison. There is also a class called ``Comparator``, which is used to specify that you want to use a different order than the object itself provides.

``Comparable`` and ``Comparator`` are similar enough to be tricky. The exam likes to see if it can trick you into mixing up the two.

### Creating a ``Comparable`` Class

The ``Comparable`` interface has only one method

```java
public interface Comparable<T> {
	int compareTo(T o);
}
```

The generic ``T`` lets you implement this method and specify the type of your object. This lets you avoid a cast when implementing ``compareTo()``. Any object can be ``Comparable``.

```java
import java.util.*;
public class Duck implements Comparable<Duck> {
	private String name;
	public Duck(String name) {
		this.name = name;
	}
	public String toString() { // use readable output
		return name;
	}
	public int compareTo(Duck d) {
		return name.compareTo(d.name); // sorts ascendingly by name
	}
	public static void main(String[] args) {
		var ducks = new ArrayList<Duck>();
		ducks.add(new Duck("Quack"));
		ducks.add(new Duck("Puddles"));
		Collections.sort(ducks); // sort by name
		System.out.println(ducks); // [Puddles, Quack]
	}
}
```

the ``Duck`` class implements ``compareTo()``. Since ``Duck`` is comparing objects of type ``String`` and the ``String`` class already has a ``compareTo()`` method, it can just delegate.

There are three rules to know:
-  ==**The number 0 is returned when the current object is equivalent to the argument to ``compareTo()``.**==
-  ==**A negative number (less than 0) is returned when the current object is smaller than the argument to ``compareTo()``.**==
-  ==**A positive number (greater than 0) is returned when the current object is larger than the argument to ``compareTo()``.==**


```java
1: public class Animal implements Comparable<Animal> {
	2: private int id;
	3: public int compareTo(Animal a) {
		4: return id -a.id; // sorts ascending by id
	5: }
	6: public static void main(String[] args) {
		7: var a1 = new Animal();
		8: var a2 = new Animal();
		9: a1.id = 5;
		10: a2.id = 7;
		11: System.out.println(a1.compareTo(a2)); // -2
		12: System.out.println(a1.compareTo(a1)); // 0
		13: System.out.println(a2.compareTo(a1)); // 2
	14: } 
}
```

Lines 3–5 show one way to compare two int values. We could have used ``Integer.compare(id, a.id)`` instead.

---

**==``id -a. id`` sorts in ascending order, and ``a.id -id`` sorts in descending order.==**

---

#### Casting the ``compareTo()`` Argument

When dealing with legacy code or code that does not use generics, the ``compareTo()`` method requires a cast since it is passed an ``Object``.

```java
public class LegacyDuck implements Comparable {
	private String name;
	public int compareTo(Object obj) {
		LegacyDuck d = (LegacyDuck) obj; // cast because no generics
		return name.compareTo(d.name);
	}
}
```

Since we don’t specify a generic type for ``Comparable``, Java assumes that we want an ``Object``, which means that we have to cast to ``LegacyDuck`` before accessing instance variables on it.

#### Checking for ``null``

```java
public class MissingDuck implements Comparable<MissingDuck> {
	private String name;
	public int compareTo(MissingDuck quack) {
		if (quack == null)
			throw new IllegalArgumentException("Poorly formed duck!");
		if (this.name == null && quack.name == null)
			return 0;
		else if (this.name == null) return -1;
		else if (quack.name == null) return 1;
		else return name.compareTo(quack.name);
	}
}
```

This method throws an exception if it is passed a ``null`` ``MissingDuck`` object.

#### Keeping ``compareTo()`` and ``equals()`` Consistent

If you write a class that implements ``Comparable``, you introduce new business logic for determining equality. The ``compareTo()`` method returns 0 if two objects are equal, while your ``equals()`` method returns true if two objects are equal. **==A natural ordering that uses ``compareTo()`` is said to be consistent with equals if, and only if, ``x.equals(y)`` is true whenever ``x.compareTo(y)`` equals 0. Similarly, ``x.equals(y)`` must be false whenever ``x.compareTo(y)`` is not 0.==** You are strongly encouraged to make your ``Comparable`` classes consistent with equals because not all collection classes behave predictably if the ``compareTo()`` and ``equals()`` methods are not consistent.

```java
public class Product implements Comparable<Product> {
	private int id;
	private String name;
	public int hashCode() { return id; }
		public boolean equals(Object obj) {
		if(!(obj instanceof Product)) return false;
			var other = (Product) obj;
		return this.id == other.id;
	}
	public int compareTo(Product obj) {
		return this.name.compareTo(obj.name);
	}
}
```

You might be sorting ``Product`` objects by name, but names are not unique. The ``compareTo()`` method does not have to be consistent with equals. One way to fix that is to use a ``Comparator`` to define the sort elsewhere.

### Comparing Data with a ``Comparator``

Sometimes you want to sort an object that did not implement ``Comparable``, or you want to sort objects in different ways at different times.

```java
1: import java.util.ArrayList;
2: import java.util.Collections;
3: import java.util.Comparator;
4:
5: public class Duck implements Comparable<Duck> {
	6: private String name;
	7: private int weight;
8:
9: // Assume getters/setters/constructors provided
10:
11: public String toString() { return name; }
12:
13: public int compareTo(Duck d) {
	14: return name.compareTo(d.name);
15: }
16:
17: public static void main(String[] args) {
18: Comparator<Duck> byWeight = new Comparator<Duck>() {
	19: public int compare(Duck d1, Duck d2) {
		20: return d1.getWeight()-d2. getWeight();
	21: }
22: };
23: var ducks = new ArrayList<Duck>();
24: ducks.add(new Duck("Quack", 7));
25: ducks.add(new Duck("Puddles", 10));
26: Collections.sort(ducks);
27: System.out.println(ducks); // [Puddles, Quack]
28: Collections.sort(ducks, byWeight);
29: System.out.println(ducks); // [Quack, Puddles]
30:
```

- this program imports ``java.util.Comparator`` on line 3.
- attention to the fact that **==``Comparable`` and ``Comparator`` are in different packages: ``java.lang`` and ``java.util``, respectively. That means ``Comparable`` can be used without an import statement, while ``Comparator`` cannot==**.
- The ``Duck`` class itself can define only one ``compareTo()`` method. In this case, name was chosen. If we want to sort by something else, we have to define that sort order outside the ``compareTo()`` method using a separate class or lambda expression.
- Lines 18–22 of the ``main()`` method show how to define a ``Comparator`` using an inner class.

``Comparator`` is a functional interface since there is only one ``abstract`` method to implement. This means that we can rewrite the ``Comparator`` on lines 18–22 using a lambda expression or method reference

```java
Comparator<Duck> byWeight = (d1, d2) -> d1.getWeight()-d2. getWeight();
Comparator<Duck> byWeight = Comparator.comparing(Duck::getWeight);
```

---
**Is ``Comparable`` a Functional Interface?**

**``Comparable`` is also a functional interface since it also has a single abstract method. However, using a lambda for ``Comparable`` would be silly. The point of ``Comparable`` is to implement it inside the object being compared.**

---

### Comparing ``Comparable`` and ``Comparator``

![[Pasted image 20240406163439.png]]

```java
var byWeight = new Comparator<Duck>() { // DOES NOT COMPILE
	public int compareTo(Duck d1, Duck d2) {
		return d1.getWeight()-d2. getWeight();
	}
};
```

The method name is wrong. A ``Comparator`` must implement a method named ``compare()``. Pay special attention to method names and the number of parameters when you see ``Comparator`` and ``Comparable`` in questions.

### Comparing Multiple Fields

```java
public class Squirrel {
	private int weight;
	private String species;
	// Assume getters/setters/constructors provided
}
```

```java
public class MultiFieldComparator implements Comparator<Squirrel> {
	public int compare(Squirrel s1, Squirrel s2) {
		int result = s1.getSpecies().compareTo(s2.getSpecies());
	if (result != 0) return result;
		return s1.getWeight()-s2. getWeight();
	}
}
```

```java
Comparator<Squirrel> c = Comparator.comparing(Squirrel::getSpecies) .thenComparingInt(Squirrel::getWeight);
```

We chain the methods. First, we create a ``Comparator`` on species ascending. Then, if there is a tie, we sort by weight. We can also sort in descending order. Some methods on ``Comparator``, like ``thenComparingInt()``, are ``default`` methods.

```java
var c = Comparator.comparing(Squirrel::getSpecies).reversed();
```

![[Pasted image 20240406163854.png]]

![[Pasted image 20240406163904.png]]

### Sorting and Searching

The ``Collections.sort()`` method uses the ``compareTo()`` method to sort. It expects the objects to be sorted to be ``Comparable``.

```java
2: public class SortRabbits {
	3: static record Rabbit(int id) {}
	4: public static void main(String[] args) {
		5: List<Rabbit> rabbits = new ArrayList<>();
		6: rabbits.add(new Rabbit(3));
		7: rabbits.add(new Rabbit(1));
		8: Collections.sort(rabbits); // DOES NOT COMPILE
9: }
}
```

Java knows that the ``Rabbit`` record is not ``Comparable``. It knows sorting will fail, so it doesn’t even let the code compile. You can fix this by passing a ``Comparator`` to ``sort()``. **==Remember that a ``Comparator`` is useful when you want to specify sort order without using a ``compareTo()`` method.==**

```java
8: Comparator<Rabbit> c = (r1, r2) -> r1.id -r2. id;
9: Collections.sort(rabbits, c);
10: System.out.println(rabbits); // [Rabbit[id=1], Rabbit[id=3]]
```

```java
8: Comparator<Rabbit> c = (r1, r2) -> r1.id -r2. id;
9: Collections.sort(rabbits, c);
10: Collections.reverse(rabbits);
11: System.out.println(rabbits); // [Rabbit[id=3], Rabbit[id=1]]
```

The ``sort()`` and ``binarySearch()`` methods allow you to pass in a ``Comparator`` object when you don’t want to use the natural order. There is a trick in working with ``binarySearch()``.

```java
3: var names = Arrays.asList("Fluffy", "Hoppy");
4: Comparator<String> c = Comparator.reverseOrder();
5: var index = Collections.binarySearch(names, "Hoppy", c);
6: System.out.println(index); // -1
```

- Line 3 creates a list, ``[Fluffy, Hoppy]``.
- Line 4 creates a ``Comparator`` that reverses the natural order.
- Line 5 requests a binary search in descending order.

Since the list is not in that order, we don’t meet the precondition for doing a search. **==While the result of calling ``binarySearch()`` on an improperly sorted list is undefine==** sometimes you can get lucky.

```java
2: public class UseTreeSet {
	3: static class Rabbit{ int id; }
	4: public static void main(String[] args) {
		5: Set<Duck> ducks = new TreeSet<>();
		6: ducks.add(new Duck("Puddles"));
		7:
		8: Set<Rabbit> rabbits = new TreeSet<>();
		9: rabbits.add(new Rabbit()); // ClassCastException
10: }
}
```

When ``TreeSet`` tries to sort it, Java discovers the fact that ``Rabbit`` does not implement Comparable. Java throws an exception

```java
Exception in thread "main" java.lang.ClassCastException:
class Rabbit cannot be cast to class java.lang.Comparable
```

It may seem weird for this exception to be thrown when the first object is added to the set. After all, there is nothing to compare yet. Java works this way for consistency. Just like searching and sorting, you can tell collections that require sorting that you want to use a specific ``Comparator``

```java
8: Set<Rabbit> rabbits = new TreeSet<>((r1, r2) -> r1.id -r2. id); 
9: rabbits.add(new Rabbit());
```

A ``Comparator`` is a helpful object. It lets you separate sort order from the object to be sorted. Notice that line 9 in both of the previous examples is the same. It’s the declaration of the ``TreeSet`` that has changed

### Sorting a ``List``

While you can call ``Collections.sort(list)``, you can also sort directly on the list object.

```java
3: List<String> bunnies = new ArrayList<>();
4: bunnies.add("long ear");
5: bunnies.add("floppy");
6: bunnies.add("hoppy");
7: System.out.println(bunnies); // [long ear, floppy, hoppy]
8: bunnies.sort((b1, b2) -> b1.compareTo(b2));
9: System.out.println(bunnies); // [floppy, hoppy, long ear]
```

The ``sort()`` method takes a ``Comparator`` that provides the sort order. Remember that ``Comparator`` takes two parameters and returns an ``int``. **==There is not a sort method on ``Set`` or ``Map``. Both of those types are unordered, so it wouldn’t make sense to sort them.==**

## Working with Generics

```java
14: static void printNames(List list) {
	15: for (int i = 0; i < list.size(); i++) {
		16: String name = (String) list.get(i); // ClassCastException
		17: System.out.println(name);
	18: }
19: }
20: public static void main(String[] args) {
	21: List names = new ArrayList();
	22: names.add(new StringBuilder("Webby"));
	23: printNames(names);
24: }
```

This code throws a ``ClassCastException``. Line 22 adds a ``StringBuilder`` to list. This is legal because a non-generic list can contain anything. However, line 16 is written to expect a specific class to be in there. It casts to a ``String``, reflecting this assumption.

Generics fix this by allowing you to write and use parameterized types. Since we specify that we want an ``ArrayList`` of ``String`` objects, the compiler has enough information to prevent this problem in the first place.

```java
List<String> names = new ArrayList<String>();
names.add(new StringBuilder("Webby")); // DOES NOT COMPILE
```

### Creating Generic Classes

You can introduce generics into your own classes. The syntax for introducing a generic is to declare a formal type parameter in angle brackets.

```java
public class Crate<T> {
	private T contents;
	public T lookInCrate() {
		return contents;
	}
	public void packCrate(T contents) {
		this.contents = contents;
	}
}
```

The generic type ``T`` is available anywhere within the ``Crate`` class. When you instantiate the class, you tell the compiler what ``T`` should be for that particular instance.

```java
Elephant elephant = new Elephant();
Crate<Elephant> crateForElephant = new Crate<>();
crateForElephant.packCrate(elephant);
Elephant inNewHome = crateForElephant.lookInCrate();
```

To be fair, we didn’t pack the crate so much as the elephant walked into it. However, you can see that the ``Crate`` class is able to deal with an ``Elephant`` without knowing anything about it. This probably doesn’t seem particularly impressive. We could have just typed in ``Elephant`` instead of ``T`` when coding ``Crate``. What if we wanted to create a ``Crate`` for another animal?

```java
Crate<Zebra> crateForZebra = new Crate<>();
```

**==Generic classes become useful when the classes used as the type parameter can have absolutely nothing to do with each other.==**

```java
Robot joeBot = new Robot();
Crate<Robot> robotCrate = new Crate<>();
robotCrate.packCrate(joeBot);
// ship to Houston
Robot atDestination = robotCrate.lookInCrate();
```

The ``Crate`` class works with any type of class. Before generics, we would have needed ``Crate`` to use the ``Object`` class for its instance variable, which would have put the burden on the caller to cast the object it receives on emptying the crate.
 
 In addition to ``Crate`` not needing to know about the objects that go into it, those objects don’t need to know about ``Crate``. We aren’t requiring the objects to implement an interface named ``Crateable`` or the like. A class can be put in the ``Crate`` without any changes at all.

Generic classes aren’t limited to having a single type parameter.

```java
public class SizeLimitedCrate<T, U> {
	private T contents;
	private U sizeLimit;
	public SizeLimitedCrate(T contents, U sizeLimit) {
		this.contents = contents;
		this.sizeLimit = sizeLimit;
	} 
}
```

```java
Elephant elephant = new Elephant();
Integer numPounds = 15_000;
SizeLimitedCrate<Elephant, Integer> c1 = new SizeLimitedCrate<>(elephant, numPounds);
```

### Understanding Type Erasure

Specifying a generic type allows the compiler to enforce proper use of the generic type. **==Behind the scenes, the compiler replaces all references to ``T`` in ``Crate`` with ``Object``. In other words, after the code compiles, your generics are just ``Object`` types.==**

```java
public class Crate {
	private Object contents;
	public Object lookInCrate() {
		return contents;
	}
	public void packCrate(Object contents) {
		this.contents = contents;
	}
}
```

This means there is only one class file. There aren’t different copies for different parameterized types. **==This process of removing the generics syntax from your code is referred to as type erasure. Type erasure allows your code to be compatible with older versions of Java that do not contain generics.==** The compiler adds the relevant casts for your code to work with this type of erased class.

```java
Robot r = crate.lookInCrate(); // FROM THIS 
Robot r = (Robot) crate.lookInCrate(); // TO THIS
```

#### Overloading a Generic Method

Only one of these two methods is allowed in a class because **==type erasure will reduce both sets of arguments to ``(List input)``:==**

```java
public class LongTailAnimal {
	protected void chew(List<Object> input) {}
	protected void chew(List<Double> input) {} // DOES NOT COMPILE
}
```

For the same reason, you also can’t overload a generic method from a parent class.

```java
public class LongTailAnimal {
	protected void chew(List<Object> input) {}
}
public class Anteater extends LongTailAnimal {
	protected void chew(List<Double> input) {} // DOES NOT COMPILE
}
```

In the compiled form, the generic type is dropped, and it appears as an invalid overloaded method.

```java
public class Anteater extends LongTailAnimal {
	protected void chew(List<Object> input) {}
	protected void chew(ArrayList<Double> input) {}
}
```

- The first ``chew()`` method compiles because it uses the same generic type in the overridden method as the one defined in the parent class.
- The second ``chew()`` method compiles as well.

However, it is an overloaded method because one of the method arguments is a ``List`` and the other is an ``ArrayList``. When working with generic methods, it’s important to consider the underlying type.

#### Returning Generic Types

==**When you’re working with overridden methods that return generics, the return values must be covariant. In terms of generics, this means that the return type of the class or interface declared in the overriding method must be a subtype of the class defined in the parent class.**== The generic parameter type must match its parent’s type exactly.

```java
public class Mammal {
	public List<CharSequence> play() { ... }
	public CharSequence sleep() { ... }
}
public class Monkey extends Mammal {
	public ArrayList<CharSequence> play() { ... }
}
public class Goat extends Mammal {
	public List<String> play() { ... } // DOES NOT COMPILE
	public String sleep() { ... }
}
```

- The ``Monkey`` class compiles because ``ArrayList`` is a subtype of ``List``.
- The ``play()`` method in the ``Goat`` class does not compile, though. For the return types to be covariant, the generic type parameter must match. Even though ``String`` is a subtype of ``CharSequence``, it does not exactly match the generic type defined in the ``Mammal`` class. Therefore, this is considered an invalid override.

Notice that the ``sleep()`` method in the ``Goat`` class does compile since ``String`` is a subtype of ``CharSequence``. **==This example shows that covariance applies to the ``return`` type, just not the generic parameter type.==**

For the exam, it might be helpful for you to apply type erasure to questions involving generics to ensure that they compile properly. Once you’ve determined which methods are overridden and which are being overloaded, work backward, making sure the generic types match for overridden methods. And ==**remember, generic methods cannot be overloaded by changing the generic parameter type only.**==

### Implementing Generic Interfaces

Just like a class, an interface can declare a formal type parameter.

```java
public interface Shippable<T> {
	void ship(T t);
}
```

There are three ways a class can approach implementing this interface.

1. The first is to specify the generic type in the class.

```java
class ShippableRobotCrate implements Shippable<Robot> {
	public void ship(Robot t) { }
}
```

2. The next way is to create a generic class.

```java
class ShippableAbstractCrate<U> implements Shippable<U> {
	public void ship(U t) { }
}
```

The type parameter could have been named anything, including ``T``. We used ``U`` in the example to avoid confusion about what ``T`` refers to. The exam won’t mind trying to confuse you by using the same type parameter name.

3. The final way is to not use generics at all. This is the old way of writing code. It generates a compiler warning about ``Shippable`` being a raw type, but it does compile.

```java
class ShippableCrate implements Shippable {
	public void ship(Object t) { }
}
```

### Writing Generic Methods

This is often useful for ``static`` methods since they aren’t part of an instance that can declare the type. However, it is also allowed on non-``static`` methods.

```java
public class Handler {
	public static <T> void prepare(T t) {
		System.out.println("Preparing " + t);
	}
	public static <T> Crate<T> ship(T t) {
		System.out.println("Shipping " + t);
		return new Crate<T>();
	}
}
```

The method parameter is the generic type ``T``. Before the return type, we declare the formal type parameter of ``<T>``. In the ``ship()`` method, we show how you can use the generic parameter in the return type, ``Crate<T>``, for the method.

**==Unless a method is obtaining the generic formal type parameter from the class/interface, it is specified immediately before the return type of the method.==**

```java
2: public class More {
	3: public static <T> void sink(T t) { }
	4: public static <T> T identity(T t) { return t; }
	5: public static T noGood(T t) { return t; } // DOES NOT COMPILE
6: }
```

- Line 3 shows the formal parameter type immediately before the return type of ``void``.
- Line 4 shows the return type being the formal parameter type. It looks weird, but it is correct.
- Line 5 omits the formal parameter type and therefore does not compile.

**==When you have a method declare a generic parameter type, it is independent of the class generics.==**

```java
1: public class TrickyCrate<T> {
	2: public <T> T tricky(T t) {
		3: return t;
	4: }
5: }
```

```java
10: public static String crateName() {
	11: TrickyCrate<Robot> crate = new TrickyCrate<>();
	12: return crate.tricky("bot");
13: }
```

- On line 1, ``T`` is ``Robot`` because that is what gets referenced when constructing a ``Crate``. 
- On line 2, ``T`` is ``String`` because that is what is passed to the method.

### Creating a Generic Record

```java
public record CrateRecord<T>(T contents) {
	@Override
	public T contents() {
		if (contents == null)
			throw new IllegalStateException("missing contents");
		return contents;
	}
}
```

### Bounding Generic Types

A bounded parameter type is a generic type that specifies a bound for the generic. A wildcard generic type is an unknown generic type represented with a question mark ``(?)``.

![[Pasted image 20240406180309.png]]

#### Creating Unbounded Wildcards

An unbounded wildcard represents any data type. You use ? when you want to specify that any type is okay with you

```java
public static void printList(List<Object> list) {
	for (Object x: list)
		System.out.println(x);
}
public static void main(String[] args) {
	List<String> keywords = new ArrayList<>();
	keywords.add("java");
	printList(keywords); // DOES NOT COMPILE
}
```

A ``String`` is a subclass of an ``Object``. This is true. However, ``List<String>`` cannot be assigned to ``List<Object>``

```java
4: List<Integer> numbers = new ArrayList<>();
5: numbers.add(Integer.valueOf(42));
6: List<Object> objects = numbers; // DOES NOT COMPILE
7: objects.add("forty two");
8: System.out.println(numbers.get(1));
```

On line 4, the compiler promises us that only ``Integer`` objects will appear in numbers. If line 6 compiled, line 7 would break that promise by putting a ``String`` in there since numbers and objects are references to the same object. Good thing the compiler prevents this. we cannot assign a ``List<String>`` to a ``List<Object>``.

```java
public static void printList(List<?> list) {
	for (Object x: list)
		System.out.println(x);
}
public static void main(String[] args) {
	List<String> keywords = new ArrayList<>();
	keywords.add("java");
	printList(keywords);
}
```

```java
List<?> x1 = new ArrayList<>();
var x2 = new ArrayList<>();
```

There are two key differences. 
- First, ``x1`` is of type ``List``, while ``x2`` is of type ``ArrayList``. 
- Additionally, we can only assign ``x2`` to a ``List<Object>``. 
 
These two variables do have one thing in common. Both return type ``Object`` when calling the ``get()`` method.

#### Creating Upper-Bounded Wildcards

```java
ArrayList<Number> list = new ArrayList<Integer>(); // DOES NOT COMPILE
// INSTEAD
List<? extends Number> list = new ArrayList<Integer>();
```

**==The upper-bounded wildcard says that any class that extends ``Number`` or ``Number`` itself can be used as the formal parameter type:==**

```JAVA
public static long total(List<? extends Number> list) {
	long count = 0;
	for (Number number: list)
		count += number.longValue();
	return count;
}
```

Java converts the previous code to something equivalent to the following:

```JAVA
public static long total(List list) {
	long count = 0;
	for (Object obj: list) {
		Number number = (Number) obj;
		count += number.longValue();
	}
	return count;
}
```

Something interesting happens **==when we work with upper bounds or unbounded wildcards. The list becomes logically immutable and therefore cannot be modified.==**

```java
2: static class Sparrow extends Bird { }
3: static class Bird { }
4:
5: public static void main(String[] args) {
	6: List<? extends Bird> birds = new ArrayList<Bird>();
	7: birds.add(new Sparrow()); // DOES NOT COMPILE
	8: birds.add(new Bird()); // DOES NOT COMPILE
9: }
```

The problem stems from the fact that Java doesn’t know what type ``List<? extends Bird>`` really is. It could be ``List<Bird>`` or ``List<Sparrow>`` or some other generic type that hasn’t even been written yet.

```java
interface Flyer { void fly(); }
class HangGlider implements Flyer { public void fly() {} }
class Goose implements Flyer { public void fly() {} }
```

```java
private void anyFlyer(List<Flyer> flyer) {}
private void groupOfFlyers(List<? extends Flyer> flyer) {}
```

Note that we used the keyword ``extends`` rather than ``implements``. **==Upper bounds are like anonymous classes in that they use ``extends`` regardless of whether we are working with a class or an interface==**.


```java
List<? extends Number> foo3 = new ArrayList<Number>();  // Number "extends" Number (in this context)
List<? extends Number> foo3 = new ArrayList<Integer>(); // Integer extends Number
List<? extends Number> foo3 = new ArrayList<Double>();  // Double extends Number
```

1. **Reading** - Given the above possible assignments, what type of object are you guaranteed to read from `List foo3`:
    
    - You can read a **`Number`** because any of the lists that could be assigned to `foo3` contain a `Number` or a subclass of `Number`.
    - You can't read an `Integer` because `foo3` could be pointing at a `List<Double>`.
    - You can't read a `Double` because `foo3` could be pointing at a `List<Integer>`.
2. **Writing** - Given the above possible assignments, what type of object could you add to `List foo3` that would be legal for **all** the above possible `ArrayList` assignments:
    
    - You can't add an `Integer` because `foo3` could be pointing at a `List<Double>`.
    - You can't add a `Double` because `foo3` could be pointing at a `List<Integer>`.
    - You can't add a `Number` because `foo3` could be pointing at a `List<Integer>`.

**==_You can't add any object to `List<? extends T>` because you can't guarantee what kind of `List` it is really pointing to, so you can't guarantee that the object is allowed in that `List`. The only "guarantee" is that you can only read from it and you'll get a `T` or subclass of `T`._==**

#### Creating Lower-Bounded Wildcards

```java
List<String> strings = new ArrayList<String>();
strings.add("tweet");
List<Object> objects = new ArrayList<Object>(strings);
addSound(strings);
addSound(objects);
```

The problem is that we want to pass a ``List<String>`` and a`` List<Object>`` to the same method.

![[Pasted image 20240406181615.png]]

To solve this problem, we need to use a lower bound.

```java
public static void addSound(List<? super String> list) {
	list.add("quack");
}
```

**==With a lower bound, we are telling Java that the list will be a list of ``String`` objects or a list of some objects that are a superclass of ``String``==**. Either way, it is safe to add a ``String`` to that list.

---
**Understanding Generic Supertypes**

**When you have subclasses and superclasses, lower bounds can get tricky.**

```java
3: List<? super IOException> exceptions = new ArrayList<Exception>();
4: exceptions.add(new Exception()); // DOES NOT COMPILE
5: exceptions.add(new IOException());
6: exceptions.add(new FileNotFoundException());
```

- ==**Line 3 references a List that could be ``List<IOException>`` or ``List<Exception>`` or ``List<Object>``**==
- ==**Line 4 does not compile because we could have a ``List<IOException>``, and an ``Exception`` object wouldn’t fit in there.**==

- ==**Line 5 is fine. ``IOException`` can be added to any of those types**.== 
- ==**Line 6 is also fine. ``FileNotFoundException`` can also be added to any of those three types. This is tricky because ``FileNotFoundException`` is a subclass of ``IOException``, and the keyword says super. Java says, “Well, ``FileNotFoundException`` also happens to be an ``IOException``, so everything is fine.”**==

---

The wildcard declaration of `List<? super Integer> foo3` means that any of these are legal assignments:

```java
List<? super Integer> foo3 = new ArrayList<Integer>();  // Integer is a "superclass" of Integer (in this context)
List<? super Integer> foo3 = new ArrayList<Number>();   // Number is a superclass of Integer
List<? super Integer> foo3 = new ArrayList<Object>();   // Object is a superclass of Integer
```

1. **Reading** - Given the above possible assignments, what type of object are you guaranteed to receive when you read from `List foo3`:
    
    - You aren't guaranteed an `Integer` because `foo3` could be pointing at a `List<Number>` or `List<Object>`.
    - You aren't guaranteed a `Number` because `foo3` could be pointing at a `List<Object>`.
    - The **only** guarantee is that you will get an instance of an **`Object`** or subclass of `Object` (but you don't know what subclass).
2. **Writing** - Given the above possible assignments, what type of object could you add to `List foo3` that would be legal for **all** the above possible `ArrayList` assignments:
    
    - You can add an `Integer` because an `Integer` is allowed in any of above lists.
    - **==You can add an instance of a subclass of `Integer` because an instance of a subclass of `Integer` is allowed in any of the above lists.==**
    - You can't add a `Double` because `foo3` could be pointing at an `ArrayList<Integer>`.
    - You can't add a `Number` because `foo3` could be pointing at an `ArrayList<Integer>`.
    - You can't add an `Object` because `foo3` could be pointing at an `ArrayList<Integer>`.

---

 **PECS**

==Remember _PECS_: **"Producer Extends, Consumer Super"**.==

- ==**"Producer Extends"** - If you need a `List` to produce `T` values (you want to read `T`s from the list), you need to declare it with `? extends T`, e.g. `List<? extends Integer>`. But you cannot add to this list.==
    
- ==**"Consumer Super"** - If you need a `List` to consume `T` values (you want to write `T`s into the list), you need to declare it with `? super T`, e.g. `List<? super Integer>`. But there are no guarantees what type of object you may read from this list.==
    
- ==If you need to both read from and write to a list, you need to declare it exactly with no wildcards, e.g. `List<Integer>`.==

```java
public class Collections { 
  public static <T> void copy(List<? super T> dest, List<? extends T> src) {
      for (int i = 0; i < src.size(); i++) 
        dest.set(i, src.get(i)); 
  } 
}
```

==the source list `src` (the producing list) uses `extends`, and the destination list `dest` (the consuming list) uses `super`:==

---
### Putting It All Together

#### Combining Generic Declarations

```java
class A {}
class B extends A {}
class C extends B {}
```

```java
6: List<?> list1 = new ArrayList<A>();
7: List<? extends A> list2 = new ArrayList<A>();
8: List<? super A> list3 = new ArrayList<A>();
```

- Line 6 creates an ``ArrayList`` that can hold instances of class ``A``. It is stored in a variable with an unbounded wildcard. Any generic type can be referenced from an unbounded wildcard, making this okay.
- Line 7 tries to store a list in a variable declaration with an upper-bounded wildcard. This is okay. You can have ``ArrayList<A>``, ``ArrayList<B>``, or ``ArrayList<C>`` stored in that reference.
- Line 8 is also okay. This time, you have a lower-bounded wildcard. The lowest type you can reference is ``A``. Since that is what you have, it compiles.

```java
9: List<? extends B> list4 = new ArrayList<A>(); // DOES NOT COMPILE
10: List<? super B> list5 = new ArrayList<A>();
11: List<?> list6 = new ArrayList<? extends A>(); // DOES NOT COMPILE
```

- Line 9 has an upper-bounded wildcard that allows ``ArrayList<B>`` or ``ArrayList<C>`` to be referenced. Since you have ``ArrayList<A>`` that is trying to be referenced, the code does not compile.
- Line 10 has a lower-bounded wildcard, which allows a reference to ``ArrayList<A>``,`` ArrayList<B>``, or A``rrayList<Object>``.
- line 11 allows a reference to any generic type since it is an unbounded wildcard. **==The problem is that you need to know what that type will be when instantiating the ``ArrayList``. It wouldn’t be useful anyway, because you can’t add any elements to that ``ArrayList``.==**

#### Passing Generic Arguments

```java
<T> T first(List<? extends T> list) {
	return list.get(0);
}
```

The first method, ``first()``, is a perfectly normal use of generics. It uses a method-specific type parameter, ``T``. It takes a parameter of ``List<T>``, or some subclass of ``T``, and it returns a single object of that ``T`` type.

```java
<T> <? extends T> second(List<? extends T> list) { // DOES NOT COMPILE
	return list.get(0);
}
```

The next method, ``second()``, does not compile because the return type isn’t actually a type.

```java
<B extends A> B third(List<B> list) {
	return new B(); // DOES NOT COMPILE
}
```

This method, ``third()``, does not compile. ``<B extends A>`` says that you want to use ``B`` as a type parameter just for this method and that it needs to extend the ``A`` class. Coincidentally, ``B`` is also the name of a class. Well, it isn’t a coincidence. It’s an evil trick. **==Within the scope of the method, ``B`` can represent class ``A``, ``B``, or ``C``, because all extend the ``A`` class. Since ``B`` no longer refers to the ``B`` class in the method, you can’t instantiate it.==**

```java
void fourth(List<? super B> list) {}
```

You can pass the type ``List<B>``, ``List<A>``, or ``List<Object>``.

```java
<X> void fifth(List<X super B> list) { // DOES NOT COMPILE
}
```

``fifth()``, does not compile because it tries to mix a method-specific type parameter with a wildcard. A wildcard must have a ``?`` in it.

## Summary #OCP_Summary 

**==The Java Collections Framework includes four main types of data structures: lists, sets, queues, and maps. The Collection interface is the parent interface of ``List``, ``Set``, and ``Queue``. Additionally, ``Deque`` extends ``Queue``. The ``Map`` interface does not extend Collection.**==

- ==**``List``: An ordered collection of elements that allows duplicate entries**==
    - ==**``ArrayList``: Standard resizable list**==
    - ==**``LinkedList``: Can easily add/remove from beginning or end**==
- ==**``Set``: Does not allow duplicates**==
    - ==**``HashSet``: Uses ``hashCode()`` to find unordered elements**==
    - ==**``TreeSet``: Sorted. Does not allow null values.**==
- ==**``Queue/Deque``: Orders elements for processing**==
    - ==**``ArrayDeque``: Double-ended queue**==
    - ==**``LinkedList``: Double-ended queue and list**==
- ==**Map: Maps unique keys to values**==
    - ==**``HashMap``: Uses ``hashCode()`` to find keys.**==
    - ==**``TreeMap``: Sorted map. Does not allow null keys.**==

==**The ``Comparable`` interface declares the ``compareTo()`` method. This method returns a negative number if the object is smaller than its argument, 0 if the two objects are equal, and a positive number otherwise. The ``compareTo()`` method is declared on the object that is being compared, and it takes one parameter. The ``Comparator`` interface defines the ``compare()`` method. A negative number is returned if the first argument is smaller, zero if they are equal, and a positive number otherwise. The ``compare()`` method can be declared in any code, and it takes two parameters. A ``Comparator`` is often implemented using a lambda.**==

==**Generics are type parameters for code. To create a class with a generic parameter, add after the class name. You can use any name you want for the type parameter. Single uppercase letters are common choices. Generics allow you to specify wildcards. ``<?>`` is an unbounded wildcard that means any type. ``<? extends Object>`` is an upper bound that means any type that is ``Object`` or extends it. ``<? extends MyInterface>`` means any type that implements ``MyInterface``. ``<? super Number>`` is a lower bound that means any type that is ``Number`` or a superclass. A compiler error results from code that attempts to add an item in a list with an unbounded or upper-bounded wildcard.==**

## Exam Essentials #Essential 

**Pick the correct type collection from a description.** A ``List`` allows duplicates and orders the elements. A ``Set`` does not allow duplicates. A ``Deque`` orders its elements to facilitate retrievals from the front or back. A ``Map`` maps keys to values. Be familiar with the differences  n implementations of these interfaces.

**Work with convenience methods.** The Collections Framework contains many methods such as ``contains()``,`` forEach()``, and ``removeIf()`` that you need to know for the exam. There are too many to list in this paragraph for review, so please do review the tables in this chapter.

**Differentiate between Comparable and Comparator.** Classes that implement ``Comparable`` are said to have a natural ordering and implement the ``compareTo()`` method. **==A class is allowed to have only one natural ordering==**. A ``Comparator`` takes two objects in the ``compare()`` method. Different ones can have different sort orders. A ``Comparator`` is often implemented using a lambda such as ``(a, b) -> a.num - b.num``.

**Identify valid and invalid uses of generics and wildcards.** ``<T>`` represents a type parameter.
Any name can be used, but a single uppercase letter is the convention. `` <?>`` is an unbounded
wildcard. ``<? extends X>`` is an upper-bounded wildcard. ``<? super X>`` is a lower-bounded
wildcard.

## Review Questions

1. Suppose you need to display a collection of products for sale, which may contain duplicates. Additionally, you have a collection of sales that you need to track, sorted by the natural order of the sale ID, and you need to retrieve the text of each. Which two of the following from the java.util package best suit your needs for this scenario? (Choose two.)

A. ArrayList
B. HashMap
C. HashSet
D. LinkedList
E. TreeMap
F. TreeSet

**My Answer: A, E
Correct Answer: A,E**

**For the first scenario, the answer needs to implement List because the scenario allows duplicates, narrowing it down to options A and D. Option A is a better answer than option D because LinkedList is both a List and a Queue, and you just need a regular List.**

**For the second scenario, the answer needs to implement Map because you are dealing with key/value pairs per the unique id field. This narrows it down to options B and E. Since the question talks about ordering, you need the TreeMap. Therefore, the answer is option E.**

---

2. Which of the following are true? (Choose all that apply.)
```JAVA
12: List<?> q = List.of("mouse", "parrot");
13: var v = List.of("mouse", "parrot");
14:
15: q.removeIf(String::isEmpty);
16: q.removeIf(s -> s.length() == 4);
17: v.removeIf(String::isEmpty);
18: v.removeIf(s -> s.length() == 4);
```

A. This code compiles and runs without error.
B. Exactly one of these lines contains a compiler error.
C. Exactly two of these lines contain a compiler error.
D. Exactly three of these lines contain a compiler error.
E. Exactly four of these lines contain a compiler error.
F. If any lines with compiler errors are removed, this code runs without throwing an exception.
G. If any lines with compiler errors are removed, this code throws an exception.

**My Answer: C, F
Correct Answer: C,F**

**==Line 12 creates a List< ? >, which means it is treated as if all the elements are of type Object rather than String. Lines 15 and 16 do not compile since they call the String methods isEmpty() and length(), which are not defined on Object==. Line 13 creates a List< String > because var uses the type that it deduces from the context. Lines 17 and 18 do compile. However, List.of() creates an immutable list, so both of those lines would throw an UnsupportedOperationException if run. Therefore, options C and G are correct**

--- 

3. What is the result of the following statements?

```JAVA
3: var greetings = new ArrayDeque<String>();
4: greetings.offerLast("hello");
5: greetings.offerLast("hi");
6: greetings.offerFirst("ola");
7: greetings.pop();
8: greetings.peek();
9: while (greetings.peek() != null)
10: System.out.print(greetings.pop());
```

A. hello
B. hellohi
C. hellohiola
D. hiola
E. The code does not compile.
F. An exception is thrown.

**My Answer: D
Correct Answer: B**

**This is a double-ended queue. On lines 4 and 5, we add to the back, giving us [hello, hi]. On line 6, we add to the front and have [ola, hello, hi]. On line 7, we remove the first element, which is "ola". On line 8, we look at the new first element ("hello") but don’t remove it. On lines 9 and 10, we remove each element in turn until no elements are left, printing hello and hi together**

---

4. Which of these statements compile? (Choose all that apply.)

`A. HashSet< Number > hs = new HashSet< Integer >();`
`B. HashSet< ? super ClassCastException > set = new`
`HashSet<Exception>();`
`C. List< > list = new ArrayList < String >();`
`D. List<Object> values = new HashSet<Object>();`
`E. List< Object > objects = new ArrayList< ? extends Object>();`
`F. Map<String, ? extends Number> hm = new HashMap<String, Integer>();`

**My Answer: B,F
Correct Answer: B,F**

**==Option A does not compile because the generic types are not compatible. We could say==**
**==HashSet< ? extends Number> hs2 = new HashSet< Integer>()==;. Option B uses a lower bound, so it allows superclass generic types. Option C does not compile because the diamond operator is allowed only on the right side. Option D does not compile because a Set is not a List. ==Option E does not compile because upper bounds are not allowed when instantiating the type==. Finally, option F does compile because the upper bound is on the correct side of the =.**

---

5. What is the result of the following code?

```java
1: public record Hello<T>(T t) {
2: public Hello(T t) { this.t = t; }
3: private <T> void println(T message) {
4: System.out.print(t + "-" + message);
5: }
6: public static void main(String[] args) {
7: new Hello<String>("hi").println(1);
8: new Hello("hola").println(true);
9: } }
```

A. hi followed by a runtime exception
B. hi-1hola- true
C. The first compiler error is on line 1.
D. The first compiler error is on line 3.
E. The first compiler error is on line 8.
F. The first compiler error is on another line.

**My Answer: B**
**Correct Answer: B**

**The record compiles and runs without issue. Line 8 gives a compiler warning for not using generics but not a compiler error. Line 7 creates the Hello class with the generic type String. It also passes an int to the println() method, which gets autoboxed into an Integer. While the println() method takes a generic parameter of type T, it is not the same < T> defined for the class on line 1. Instead, it is a different T defined as part of the method declaration on line 3. Therefore, the String argument on line 7 applies only to the class. The method can take any object as a parameter, including autoboxed primitives. Line 8 creates the Hello class with the generic type Object since no type is specified for that instance. It passes a boolean to println(), which gets autoboxed into a Boolean. The result is that hi-1hola- true is printed, making option B correct.**

---

6. Which of the following can fill in the blank to print [7, 5, 3]? (Choose all that apply.)

```JAVA
8: public record Platypus(String name, int beakLength) {
9: @Override public String toString() {return "" + beakLength;}
10:
11: public static void main(String[] args) {
12: Platypus p1 = new Platypus("Paula", 3);
13: Platypus p2 = new Platypus("Peter", 5);
14: Platypus p3 = new Platypus("Peter", 7);
15:
16: List<Platypus> list = Arrays.asList(p1, p2, p3);
17:
18: Collections.sort(list, Comparator.comparing );
19:
20: System.out.println(list);
21: }
22: }
```

A.
(Platypus::beakLength)
B.
(Platypus::beakLength).reversed()
C.
(Platypus::name)
.thenComparing(Platypus::beakLength)
D.
(Platypus::name)
.thenComparing(
Comparator.comparing(Platypus::beakLength)
.reversed())
E.
(Platypus::name)
.thenComparingNumber(Platypus::beakLength)
.reversed()
F.
(Platypus::name)
.thenComparingInt(Platypus::beakLength)
.reversed()
G. None of the above

**My Answer: B,C,F**
**Correct Answer: B,F**

**Option A is incorrect because it sorts in ascending order by beakLength. Similarly, option C is incorrect because it sorts by beakLength in ascending order within those matches that have the same name. Option E is incorrect because there is no thenComparingNumber() method.**

**Option B is a correct answer, as it sorts by beakLength in descending order. Options D and F are trickier. First, notice that we can call either thenComparing() or thenComparingInt() because the former will simply autobox the int into an Integer. Then observe what reversed() applies to. Option D is incorrect because it sorts by name in ascending order and only reverses the beak length of those with the same name. Option F creates a comparator that sorts by name in ascending order and then by beak size in ascending order. Finally, it reverses the result. This is just what we want, so option F is correct.**

---

7. Which of the following method signatures are valid overrides of the hairy() method in the Alpaca class? (Choose all that apply.)

```JAVA
import java.util.*;
public class Alpaca {
public List<String> hairy(List<String> list) { return null; }
}
```

`A. public List<String> hairy(List<CharSequence> list) { return null; }`
`B. public List<String> hairy(ArrayList<String> list) { return null; }`
`C. public List<String> hairy(List<Integer> list) { return null; }`
`D. public List<CharSequence> hairy(List<String> list) { return null; }`
`E. public Object hairy(List<String> list) { return null; }`
`F. public ArrayList<String> hairy(List<String> list) { return null; }`

**My Answer: F**
**Correct Answer: B,F**

**==A valid override of a method with generic arguments must have a return type that is covariant, with matching generic type parameters.== Options D and E are incorrect because the return type is too broad. ==Additionally, the generic arguments must have the same signature with the same generic types==. This eliminates options A and C. The remaining options are correct, making the answer options B and F.**

---

8. What is the result of the following program?

```JAVA
3: public class MyComparator implements Comparator<String> {
4: public int compare(String a, String b) {
5: return b.toLowerCase().compareTo(a.toLowerCase());
6: }
7: public static void main(String[] args) {
8: String[] values = { "123", "Abb", "aab" };
9: Arrays.sort(values, new MyComparator());
10: for (var s: values)
11: System.out.print(s + " ");
12: }
13: }
```

A. Abb aab 123
B. aab Abb 123
C. 123 Abb aab
D. 123 aab Abb
E. The code does not compile.
F. A runtime exception is thrown.

**My Answer: D**
**Correct Answer: A**

**The array is sorted using MyComparator, which sorts the elements in reverse alphabetical order in a case-insensitive fashion. Normally, numbers sort before letters. This code reverses that by calling the compareTo() method on b instead of a. Therefore, option A is correct.**

---

9.  Which of these statements can fill in the blank so that the Helper class compiles successfully? (Choose all that apply.)

```JAVA
2: public class Helper {
3: public static <U extends Exception>
4: void printException(U u) {
5:
6: System.out.println(u.getMessage());
7: }
8: public static void main(String[] args) {
9: Helper. ?? ;
10: } }
```

`A. printException(new FileNotFoundException("A"))`
`B. printException(new Exception("B"))`
`C. <Throwable>printException(new Exception("C"))`
`D. <NullPointerException>printException(new NullPointerException ("D"))`
`E. printException(new Throwable("E"))`

**My Answer: A,B,D**
**Correct Answer: A,B,D**

**The generic type must be Exception or a subclass of Exception since this is an upper bound, making options A and B correct. Options C and E are wrong because Throwable is a superclass of Exception. Additionally, option D is correct despite the odd syntax by explicitly listing the type. You should still be able to recognize it as acceptable.**

---

10. Which of the following will compile when filling in the blank? (Choose all that apply.)

```JAVA
var list = List.of(1, 2, 3);
var set = Set.of(1, 2, 3);
var map = Map.of(1, 2, 3, 4);

??.forEach(System.out::println);
```

A. list
B. set
C. map
D. map.keys()
E. map.keySet()
F. map.values()
G. map.valueSet()

**My Answer: A,B,E,F**
**Correct Answer: A,B,E,F**

**The forEach() method works with a List or a Set. Therefore, options A and B are correct. Additionally, options E and F return a Set and can be used as well. Options D and G refer to methods that do not exist. Option C is tricky because a Map does have a forEach() method. However, it uses two lambda parameters rather than one. Since there is no matching System.out.println method, it does not compile.**

---

11.  Which of these statements can fill in the blank so that the Wildcard class compiles successfully? (Choose all that apply.)

```java
3: public class Wildcard {
4: public void showSize(List<?> list) {
5: System.out.println(list.size());
6: }
7: public static void main(String[] args) {
8: Wildcard card = new Wildcard();
9: ;
10: card.showSize(list);
11: } }
```

`A. List<?> list = new HashSet <String>()`
`B. ArrayList<? super Date> list = new ArrayList<Date>()`
`C. List<?> list = new ArrayList<?>()`
`D. List<Exception> list = new LinkedList<java.io.IOException>()`
`E. ArrayList <? extends Number> list = new ArrayList <Integer>()`
`F. None of the above`

**My Answer: B,E**
**Correct Answer: B,E**

**The showSize() method can take any type of List since it uses an unbounded wildcard. Option A is incorrect because it is a Set and not a List. ==Option C is incorrect because the wildcard is not allowed to be on the right side of an assignment==. Option D is incorrect because the generic types are not compatible.**

**Option B is correct because a lower-bounded wildcard allows that same type to be the generic. Option E is correct because Integer is a subclass of Number.**

---

12. What is the result of the following program?
```java
3: public record Sorted(int num, String text)
4: implements Comparable<Sorted>, Comparator<Sorted> {
5:
6: public String toString() { return "" + num; }
7: public int compareTo(Sorted s) {
8: return text.compareTo(s.text);
9: }
10: public int compare(Sorted s1, Sorted s2) {
11: return s1.num -s2. num;
12: }
13: public static void main(String[] args) {
14: var s1 = new Sorted(88, "a");
15: var s2 = new Sorted(55, "b");
16: var t1 = new TreeSet<Sorted>();
17: t1.add(s1); t1.add(s2);
18: var t2 = new TreeSet<Sorted>(s1);
19: t2.add(s1); t2.add(s2);
20: System.out.println(t1 + " " + t2);
21: } }
```

**My Answer: A**
**Correct Answer: C**

**This question is difficult because it defines both Comparable and Comparator on the same object. ==The t1 object doesn’t specify a Comparator, so it uses the Comparable object’s compareTo() method. This sorts by the text instance variable. The t2 object does specify a Comparator when calling the constructor, so it uses the compare() method, which sorts by the in==t. This gives us option C as the answer.**

---

13. What is the result of the following code? (Choose all that apply.)

```JAVA
Comparator<Integer> c1 = (o1, o2) -> o2 -o1;
Comparator<Integer> c2 = Comparator.naturalOrder();
Comparator<Integer> c3 = Comparator.reverseOrder();
var list = Arrays.asList(5, 4, 7, 2);
Collections.sort(list, );
Collections.reverse(list);
Collections.reverse(list);
System.out.println(Collections.binarySearch(list, 2));
```

A. One or more of the comparators can fill in the blank so that the code prints 0.
B. One or more of the comparators can fill in the blank so that the code prints 1.
C. One or more of the comparators can fill in the blank so that the code prints 2.
D. The result is undefined regardless of which comparator is used.
E. A runtime exception is thrown regardless of which comparator is used.
F. The code does not compile.

**My Answer: A**
**Correct Answer: A**

**When using binarySearch(), the List must be sorted in the same order that the Comparator uses. Since the binarySearch() method does not specify a Comparator explicitly, the default sort order is used. Only c2 uses that sort order and correctly identifies that the value 2 is at index 0. Therefore, option A is correct**

---

14. Which of the following lines can be inserted to make the code compile? (Choose all that apply.)

```JAVA
class W {}
class X extends W {}
class Y extends X {}
class Z<Y> {
// INSERT CODE HERE
}
```

A. W w1 = new W();
B. W w2 = new X();
C. W w3 = new Y();
D. Y y1 = new W();
E. Y y2 = new X();
F. Y y1 = new Y();

**My Answer: E,F**
**Correct Answer: A,B**

**Y is both a class and a type parameter. This means that within the class Z, when we refer to Y, it uses the type parameter. All of the choices that mention class Y are incorrect because it no longer means the class Y. Only options A and B are correct.**

---

15. Which options are true of the following code? (Choose all that apply.)
```java
3: ?? q = new LinkedList<>();
4: q.add(10);
5: q.add(12);
6: q.remove(1);
7: System.out.print(q);
```

A. If we fill in the blank with List< Integer >, the output is [10].
B. If we fill in the blank with Queue< Integer >, the output is [10].
C. If we fill in the blank with var, the output is [10].
D. One or more of the scenarios does not compile.
E. One or more of the scenarios throws a runtime exception.

**My Answer: A,C**
**Correct Answer: A,C**

**A LinkedList implements both List and Queue. The List interface has a method to remove by index. Since this method exists, Java does not autobox to call the other method, making the output [10] and option A correct. Similarly, option C is correct because the method to remove an element by index is available on a LinkedList< Object> (which is what var represents here). By contrast, Queue has only the remove by object method, so Java does autobox there. Since the number 1 is not in the list, Java does not remove anything for the Queue, and the output is [10, 12].**

---

16. What is the result of the following code?

```JAVA
4: Map m = new HashMap();
5: m.put(123, "456");
6: m.put("abc", "def");
7: System.out.println(m.contains("123"));
```

**My Answer: E**
**Correct Answer: E**

**This question looks like it is about generics, but it’s not. It is trying to see whether you noticed that Map does not have a contains() method. It has containsKey() and containsValue() instead, making option E the answer. If containsKey() were called, the answer would be false because 123 is an Integer key in the Map, rather than a String.**

---

17. What is the result of the following code? (Choose all that apply.)

```JAVA
48: var map = Map.of(1,2, 3, 6);
49: var list = List.copyOf(map.entrySet());
50:
51: List<Integer> one = List.of(8, 16, 2);
52: var copy = List.copyOf(one);
53: var copyOfCopy = List.copyOf(copy);
54: var thirdCopy = new ArrayList<>(copyOfCopy);
55:
56: list.replaceAll(x -> x * 2);
57: one.replaceAll(x -> x * 2);
58: thirdCopy.replaceAll(x -> x * 2);
59:
60: System.out.println(thirdCopy);
```

A. One line fails to compile.
B. Two lines fail to compile.
C. Three lines fail to compile.
D. The code compiles but throws an exception at runtime.
E. If any lines with compiler errors are removed, the code throws an exception at runtime.
F. If any lines with compiler errors are removed, the code prints [16, 32, 4].
G. The code compiles and prints [16, 32, 4] without any changes.

**My Answer: B**
**Correct Answer: A,E**

**The key to this question is keeping track of the types. Line 48 is a Map<Integer, Integer>. Line 49 builds a List out of a Set of Entry objects, giving us List<Entry<Integer, Integer>>. This causes a compiler error on line 56 since we can’t multiply an Entry object by two.**
**Lines 51–54 are all of type List< Integer>. The first three are immutable, and the one on line 54 is mutable. This means line 57 throws an UnsupportedOperationException since we attempt to modify the list. Line 58 would work if we could get to it. Since there is one compiler error and one runtime error, options A and E are correct.**

---

18. What code change is needed to make the method compile, assuming there is no class named T?

`A. Add <T> after the public keyword.`
`B. Add <T> after the static keyword.`
`C. Add <T> after T.`
`D. Add <?> after the public keyword.`
`E. Add <?> after the static keyword.`
`F. No change is required. The code already compiles.`

**My Answer: B**
**Correct Answer: B**

When using generic types in a method, the generic specification goes before the return type and option B is correct.

---

19. What is the result of the following?

```java
var map = new HashMap<Integer, Integer>();
map.put(1, 10);
map.put(2, 20);
map.put(3, null);
map.merge(1, 3, (a,b) -> a + b);
map.merge(3, 3, (a,b) -> a + b);
System.out.println(map);
```

```java
A. {1=10, 2=20}
B. {1=10, 2=20, 3=null}
C. {1=10, 2=20, 3=3}
D. {1=13, 2=20}
E. {1=13, 2=20, 3=null}
F. {1=13, 2=20, 3=3}
G. The code does not compile.
H. An exception is thrown.
```

**My Answer: E**
**Correct Answer: F**

**The first call to merge() calls the mapping function and adds the numbers to get 13. It then updates the map. The second call to merge() sees that the map currently has a null value for that key. It does not call the mapping function but instead replaces it with the new value of 3. Therefore, option F is correct.**

---

20. Which of the following statements are true? (Choose all that apply.)

A. Comparable is in the java.util package.
B. Comparator is in the java.util package.
C. compare() is in the Comparable interface.
D. compare() is in the Comparator interface.
E. compare() takes one method parameter.
F. compare() takes two method parameters.

**My Answer: B,D,F**
**Correct Answer: B,D,F**

**The java.lang.Comparable interface is implemented on the object to compare. It specifies the compareTo() method, which takes one parameter. The java.util.Comparator interface specifies the compare() method, which takes two parameters. This gives us options B, D, and F as the answers.**

---

# Chapter 10 - Streams #Chapter

## Returning an Optional

How do we express this *we don’t know* or *not applicable* answer in Java? We use the ``Optional`` type. An ``Optional`` is created using a factory. You can either request an empty ``Optional`` or pass a value for the ``Optional`` to wrap. Think of an Optional as a box that might have something in it or might instead be empty.

![[Pasted image 20240420223753.png]]

### Creating an Optional

```java
10: public static Optional<Double> average(int... scores) {
	11: if (scores.length == 0) return Optional.empty();
	12: int sum = 0;
	13: for (int score: scores) sum += score;
	14: return Optional.of((double) sum / scores.length);
15: }
```

Calling the method shows what is in our two boxes:

```java
System.out.println(average(90, 100)); // Optional[95.0]
System.out.println(average()); // Optional.empty
```

Normally, we want to check whether a value is there and/or get it out of the box.

```java
Optional<Double> opt = average(90, 100);
if (opt.isPresent())
	System.out.println(opt.get()); // 95.0
```

What if we didn’t do the check, and the ``Optional`` was empty?

```java
Optional<Double> opt = average();
System.out.println(opt.get()); // NoSuchElementException 
```

When creating an ``Optional``, it is common to want to use ``empty()`` when the value is ``null``. You can do this with an ``if`` statement or ternary operator. We use the ternary operator ``(? :)`` to simplify the code

```java
Optional o = (value == null) ? Optional.empty() : Optional.of(value);
```

Since this is such a common pattern, Java provides a factory method to do the same thing.

```java
Optional o = Optional.ofNullable(value);
```

![[Pasted image 20240420224239.png]]

The other methods allow you to write code that uses an ``Optional`` in one line without having to use the ternary operator. This makes the code easier to read. **==Instead of using an ``if`` statement , we can specify a ``Consumer`` to be run when there is a value inside the ``Optional``. When there isn’t, the method simply skips running the ``Consumer``.==**

```java
Optional<Double> opt = average(90, 100);
opt.ifPresent(System.out::println);
```

### Dealing with an Empty Optional

The remaining methods allow you to specify what to do if a value isn’t present.

```java
30: Optional<Double> opt = average();
31: System.out.println(opt.orElse(Double.NaN)); // NaN
32: System.out.println(opt.orElseGet(() -> Math.random())); // 0.49775932295380165
```

```java
30: Optional<Double> opt = average();
31: System.out.println(opt.orElseThrow());
```

```text
Exception in thread "main" java.util.NoSuchElementException:
No value present
at java.base/java.util.Optional.orElseThrow(Optional.java:382)
```

Without specifying a ``Supplier`` for the exception, Java will throw a ``NoSuchElementException``. Alternatively, we can have the code throw a custom exception if the ``Optional`` is empty.

```java
30: Optional<Double> opt = average();
31: System.out.println(opt.orElseThrow(
	32: () -> new IllegalStateException()));
```

```text
Exception in thread "main" java.lang.IllegalStateException
at optionals.Methods.lambda$orElse$1(Methods.java:31)
at java.base/java.util.Optional.orElseThrow(Optional.java:408)
```

Notice that we do not write ``throw new IllegalStateException()``. The ``orElseThrow()`` method takes care of actually throwing the exception when we run it.

```java
Optional<Double> opt = average(90, 100);
System.out.println(opt.orElse(Double.NaN));
System.out.println(opt.orElseGet(() -> Math.random()));
System.out.println(opt.orElseThrow());
```

It prints out 95.0 three times. Since the value does exist, there is no need to use the *or else* logic.

---
**Is ``Optional`` the Same as ``null``?**

**An alternative to ``Optional`` is to return ``null``. There are a few shortcomings with this approach.**

- **One is that there isn’t a clear way to express that ``null`` might be a special value. By contrast, returning an ``Optional`` is a clear statement in the API that there might not be a value.**
- **Another advantage of ``Optional`` is that you can use a functional programming style with ``ifPresent()`` and the other methods rather than needing an if statement.**
---

## Using Streams

### Understanding the Pipeline Flow

Think of a stream pipeline as an assembly line in a factory. Another important feature of an assembly line is that each person touches each element to do their operation, and then that piece of data is gone. It doesn’t come back. **==With streams, the data isn’t generated up front—it is created when needed. This is an example of *lazy evaluation*, which delays execution until necessary.==**

There are three parts to a stream pipeline

-  ==**Source**: Where the stream comes from.==
-  ==**Intermediate operations**: Transforms the stream into another one. There can be as few or as many intermediate operations as you’d like. Since streams use lazy evaluation, the intermediate operations do not run until the terminal operation runs.==
-  ==**Terminal operation**: Produces a result. Since streams can be used only once, the stream is no longer valid after a terminal operation completes.==

![[Pasted image 20240420230300.png]]

Notice that the operations are unknown to us. When viewing the assembly line from the outside, you care only about what comes in and goes out. What happens in between is an implementation detail.

![[Pasted image 20240420230330.png]]

### Creating Stream Sources

In Java, the streams are represented by the ``Stream<T>`` interface, defined in the ``java.util.stream`` package.
#### Creating Finite Streams

```java
11: Stream<String> empty = Stream.empty(); // count = 0
12: Stream<Integer> singleElement = Stream.of(1); // count = 1
13: Stream<Integer> fromArray = Stream.of(1, 2, 3); // count = 3
```

Java also provides a convenient way of converting a ``Collection`` to a stream.

```java
14: var list = List.of("a", "b", "c");
15: Stream<String> fromList = list.stream();
```

---

**Creating a Parallel Stream**

```java
24: var list = List.of("a", "b", "c");
25: Stream<String> fromListParallel = list.parallelStream();
```

**Using parallel streams is like setting up multiple tables of workers who can do the same task. Painting would be a lot faster if we could have five painters painting signs instead of just one. Just keep in mind some tasks cannot be done in parallel, such as putting the signs away in the order that they were created in the stream. Also be aware that there is a cost in coordinating the work, so for smaller streams, it might be faster to do it sequentially.**

---

#### Creating Infinite Streams

```java
17: Stream<Double> randoms = Stream.generate(Math::random);
18: Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2);
```

What if you wanted just odd numbers less than 100? There’s an overloaded version of ``iterate()`` that helps:

```java
19: Stream<Integer> oddNumberUnder100 = Stream.iterate(
20: 1, // seed
21: n -> n < 100, // Predicate to specify when done
22: n -> n + 2); // UnaryOperator to get next value
```

Notice how they are separated by commas ``(,)`` just like in all other methods. The exam may try to trick you by using semicolons since it is similar  to a ``for`` loop.

#### Reviewing Stream Creation Methods

![[Pasted image 20240420231908.png]]

### Using Common Terminal Operations

**==You can perform a terminal operation without any intermediate operations but not the other way around.==**
Reductions are a special type of terminal operation where all of the contents of the stream are combined into a single primitive or ``Object``.

![[Pasted image 20240420232228.png]]

#### Counting

The ``count()`` method determines the number of elements in a finite stream. For an infinite stream, it never terminates. The ``count()`` method is a reduction because it looks at each element in the stream and returns a single value.

```java
public long count()

Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
System.out.println(s.count()); // 3
```

#### Finding the Minimum and Maximum

The ``min()`` and ``max()`` methods allow you to pass a custom comparator and find the smallest or largest value in a finite stream according to that sort order. Like the ``count()`` method, ``min()`` and ``max()`` hang on an infinite stream because they cannot be sure that a smaller or larger value isn’t coming later in the stream. Both methods are reductions because they return a single value after looking at the entire stream.

```java
public Optional<T> min(Comparator<? super T> comparator)
public Optional<T> max(Comparator<? super T> comparator)

Stream<String> s = Stream.of("monkey", "ape", "bonobo");
Optional<String> min = s.min((s1, s2) -> s1.length()-s2. length());
min.ifPresent(System.out::println); // ape
```

Notice that the code returns an ``Optional`` rather than the value. This allows the method to specify that no minimum or maximum was found

```java
Optional<?> minEmpty = Stream.empty().min((s1, s2) -> 0);
System.out.println(minEmpty.isPresent()); // false
```

Since the stream is empty, the comparator is never called, and no value is present in the ``Optional``.

#### Finding a Value

The ``findAny()`` and ``findFirst()`` methods return an element of the stream unless the stream is empty. If the stream is empty, they return an empty ``Optional``. Since Java generates only the amount of stream you need, the infinite stream needs to generate only one element. As its name implies, the ``findAny()`` method can return any element of the stream. the ``findAny()`` method is more likely to return a random element when working with parallel streams.

These methods are terminal operations but not reductions. The reason is that they sometimes return without processing all of the elements. This means that they return a value based on the stream but do not reduce the entire stream into one value.

```java
public Optional<T> findAny()
public Optional<T> findFirst()

Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
Stream<String> infinite = Stream.generate(() -> "chimp");
s.findAny().ifPresent(System.out::println); // monkey (usually)
infinite.findAny().ifPresent(System.out::println); // chimp
```
#### Matching

The ``allMatch()``, ``anyMatch()``, and ``noneMatch()`` methods search a stream and return information about how the stream pertains to the predicate. These may or may not terminate for infinite streams. It depends on the data. Like the find methods, they are not reductions because they do not necessarily look at all of the elements

```java
public boolean anyMatch(Predicate <? super T> predicate)
public boolean allMatch(Predicate <? super T> predicate)
public boolean noneMatch(Predicate <? super T> predicate)

var list = List.of("monkey", "2", "chimp");
Stream<String> infinite = Stream.generate(() -> "chimp");
Predicate<String> pred = x -> Character.isLetter(x.charAt(0));
System.out.println(list.stream().anyMatch(pred)); // true
System.out.println(list.stream().allMatch(pred)); // false
System.out.println(list.stream().noneMatch(pred)); // false
System.out.println(infinite.anyMatch(pred)); // true
```

we can reuse the same predicate, but we need a different stream each time.

---

**Remember that ``allMatch()``, ``anyMatch()``, and ``noneMatch()`` return a ``boolean``. By contrast, the find methods return an ``Optional`` because they return an element of the stream.** #TIP 

---
#### Iterating

calling ``forEach()`` on an infinite stream does not terminate. Since there is no return value, it is not a reduction.

```java
public void forEach(Consumer<? super T> action)

Stream<String> s = Stream.of("Monkey", "Gorilla", "Bonobo");
s.forEach(System.out::print); // MonkeyGorillaBonobo
```

```java
Stream<Integer> s = Stream.of(1);
for (Integer i : s) {} // DOES NOT COMPILE
```

While ``forEach()`` sounds like a loop, it is really a terminal operator for streams. Streams cannot be used as the source in a for-each loop because they don’t implement the ``Iterable`` interface.
### Reducing

The ``reduce()`` method combines a stream into a single object. It is a reduction, which means it processes all elements.

```java
public T reduce(T identity, BinaryOperator<T> accumulator)
public Optional<T> reduce(BinaryOperator<T> accumulator)
public <U> U reduce(U identity, BiFunction<U,? super T,U> accumulator, BinaryOperator<U> combiner)
```

The most common way of doing a reduction is to start with an initial value and keep merging it with the next value.

```java
var array = new String[] { "w", "o", "l", "f" };
var result = "";
for (var s: array) result = result + s;
System.out.println(result); // wolf
```

The *identity* is the initial value of the reduction, in this case an empty String. The *accumulator* combines the current result with the current value in the stream

```java
Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", (s, c) -> s + c); System.out.println(word); // wolf
```

```java
Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", String::concat);
System.out.println(word); // wolf
```

```java
Stream<Integer> stream = Stream.of(3, 5, 6);
System.out.println(stream.reduce(1, (a, b) -> a * b)); // 90
```

In many cases, the identity isn’t really necessary, so Java lets us omit it. When you don’t specify an identity, an ``Optional`` is returned because there might not be any data. There are three choices for what is in the ``Optional``:

-  ==**If the stream is empty, an empty ``Optional`` is returned.**==
-  ==**If the stream has one element, it is returned.**==
-  ==**If the stream has multiple elements, the accumulator is applied to combine them.==**

```java
BinaryOperator<Integer> op = (a, b) -> a * b;
Stream<Integer> empty = Stream.empty();
Stream<Integer> oneElement = Stream.of(3);
Stream<Integer> threeElements = Stream.of(3, 5, 6);

empty.reduce(op).ifPresent(System.out::println); // no output
oneElement.reduce(op).ifPresent(System.out::println); // 3
threeElements.reduce(op).ifPresent(System.out::println); // 90
```

The third method signature is used when we are dealing with different types. It allows Java to create intermediate reductions and then combine them at the end.

```java
Stream<String> stream = Stream.of("w", "o", "l", "f!");
int length = stream.reduce(0, (i, s) -> i+s.length(), (a, b) -> a+b);
System.out.println(length); // 5
```

- The first parameter (0) is the value for the initializer. If we had an empty stream, this would be the answer.
- The second parameter is the accumulator. handles mixed data types. In this example, the first argument, ``i`` , is an ``Integer``, while the second argument, ``s``, is a ``String``. It adds the length of the current ``String`` to our running total.
- The third parameter is called the combiner, which combines any intermediate totals. In this case, ``a`` and ``b`` are both Integer values.

The three-argument ``reduce()`` operation is useful when working with parallel streams because it allows the stream to be decomposed and reassembled by separate threads
#### Collecting

The ``collect()`` method is a special type of reduction called a mutable reduction. It is more efficient than a regular reduction because we use the same mutable object while accumulating. Common mutable objects include ``StringBuilder`` and ``ArrayList``.

```java
public <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner)

public <R,A> R collect(Collector<? super T, A,R> collector)
```

```java
Stream<String> stream = Stream.of("w", "o", "l", "f");
StringBuilder word = stream.collect(
	StringBuilder::new,
	StringBuilder::append,
	StringBuilder::append);
System.out.println(word); // wolf
```

- The first parameter is the ``supplier``, which creates the object that will store the results as we collect data.
- The second parameter is the accumulator, which is a ``BiConsumer`` that takes two parameters and doesn’t return anything.
- The final parameter is the combiner, which is another ``BiConsumer``. It is responsible for taking two data collections and merging them. This is useful when we are processing in parallel. Two smaller collections are formed and then merged into one.

```java
Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set = stream.collect(
	TreeSet::new,
	TreeSet::add,
	TreeSet::addAll);
System.out.println(set); // [f, l, o, w]
```

The supplier creates an empty ``TreeSet``. The accumulator adds a single ``String`` from the Stream to the ``TreeSet``. The combiner adds all of the elements of one ``TreeSet`` to another in case the operations were done in parallel and need to be merged.

Java provides a class with common collectors cleverly named ``Collectors``. This approach also makes the code easier to read because it is more expressive.

```java
Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set = stream.collect(Collectors.toCollection(TreeSet::new));
System.out.println(set); // [f, l, o, w]

//---

Stream<String> stream = Stream.of("w", "o", "l", "f");
Set<String> set = stream.collect(Collectors.toSet());
System.out.println(set); // [f, w, l, o]
```

```java
public class StreamCollectingExample {  
  
    public static void main(String[] args) {  
  
        collectingMethod1();  
  
        collectingMethod2();  
  
        collectingMethod3();  
  
        collectingMethod4();  
  
        collectingMethod5();  
  
        collectingMethod6();  
  
    }  
  
    private static void collectingMethod1() {  
        System.out.println("### collectingMethod1 ###");  
  
        Stream<String> stream = Stream.of("w", "o", "l", "f");  
        StringBuilder word = stream.collect(StringBuilder::new,  
                StringBuilder::append,  
                StringBuilder::append);  
  
        System.out.println(word); // wolf  
    }  
  
    private static void collectingMethod2() {  
        System.out.println("### collectingMethod2 ###");  
  
        Supplier<StringBuilder> supplier = () -> new StringBuilder();  
        BiConsumer<StringBuilder, String> accumulator = (StringBuilder sb, String str) -> sb.append(str);  
        BiConsumer<StringBuilder, StringBuilder> combiner = (StringBuilder sb, StringBuilder sb2) -> sb.append(sb2);  
  
        Stream<String> stream = Stream.of("w", "o", "l", "f");  
        StringBuilder word = stream.collect(supplier,  
                accumulator,  
                combiner);  
  
        System.out.println(word); // wolf  
    }  
  
    private static void collectingMethod3() {  
        System.out.println("### collectingMethod3 ###");  
  
        Supplier<StringBuilder> supplier = () -> new StringBuilder();  
        BiConsumer<StringBuilder, String> accumulator = (StringBuilder sb, String str) -> sb.append(str);  
        BiConsumer<StringBuilder, StringBuilder> combiner = (StringBuilder sb, StringBuilder sb2) -> System.out.println("not triggered!");  
  
        // sequential stream - nothing to combine  
  
        Stream<String> stream = List.of("w", "o", "l", "f").stream();  
        StringBuilder word = stream.collect(supplier,  
                accumulator,  
                combiner);  
  
        System.out.println(word); // wolf  
    }  
  
    private static void collectingMethod4() {  
        System.out.println("### collectingMethod4 ###");  
  
        Supplier<StringBuilder> supplier = () -> new StringBuilder();  
        BiConsumer<StringBuilder, String> accumulator = (StringBuilder sb, String str) -> sb.append(str);  
        BiConsumer<StringBuilder, StringBuilder> combiner = (StringBuilder sb, StringBuilder sb2) ->  
        {  
            System.out.println("triggered!");  
            sb.append(sb2);  
        };  
  
        // parallel stream - combiner is combining partial results  
  
        Stream<String> stream = List.of("w", "o", "l", "f").parallelStream();  
        StringBuilder word = stream.collect(supplier,  
                accumulator,  
                combiner);  
  
        System.out.println(word); // wolf  
    }  
  
  
    private static void collectingMethod5() {  
        System.out.println("### collectingMethod5 ###");  
  
        Stream<String> stream = Stream.of("w", "o", "l", "f");  
        String word = stream.collect(String::new,  
                String::concat,  
                String::concat);  
  
        System.out.println(word); // empty  
    }  
  
    private static void collectingMethod6() {  
        System.out.println("### collectingMethod6 ###");  
  
        Supplier<String> supplier = () -> new String();  
        BiConsumer<String, String> accumulator = (String str1, String str2) -> str1 = str1 + str2;  
        BiConsumer<String, String> combiner = (String str1, String str2) -> str1 = str1 + str2;  
  
        Stream<String> stream = Stream.of("w", "o", "l", "f");  
        String word = stream.collect(supplier, accumulator, combiner);  
  
        System.out.println(word); // empty  
    }  
  
}
```
### Using Common Intermediate Operations

Unlike a terminal operation, an intermediate operation produces a stream as its result. An intermediate operation can also deal with an infinite stream simply by returning another infinite stream. Since elements are produced only as needed, this works fine.

#### Filtering

The ``filter()`` method returns a ``Stream`` with elements that match a given expression.

```java
public Stream<T> filter(Predicate<? super T> predicate)

Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
s.filter(x -> x.startsWith("m"))
.forEach(System.out::print); // monkey
```

#### Removing Duplicates

The ``distinct()`` method returns a stream with duplicate values removed. The duplicates do not need to be adjacent to be removed. Java calls ``equals()`` to determine whether the objects are equivalent.

```java
public Stream<T> distinct()

Stream<String> s = Stream.of("duck", "duck", "duck", "goose");
s.distinct()
.forEach(System.out::print); // duckgoose
```

#### Restricting by Position

The ``limit()`` and ``skip()`` methods can make a ``Stream`` smaller, or ``limit()`` could make a finite stream out of an infinite stream.

```java
public Stream<T> limit(long maxSize)
public Stream<T> skip(long n)

Stream<Integer> s = Stream.iterate(1, n -> n + 1);
s.skip(5)
.limit(2)
.forEach(System.out::print); // 67
```

#### Mapping

The ``map()`` method creates a one-to- one mapping from the elements in the stream to the elements of the next step in the stream.

```java
public <R> Stream<R> map(Function<? super T, ? extends R> mapper)

Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
s.map(String::length)
.forEach(System.out::print); // 676
```

#### Using ``flatMap``

The ``flatMap()`` method takes each element in the stream and makes any elements it contains top-level elements in a single stream. ==**Java 8 _``Stream.flatMap()``_ method is used to flatten a _``Stream``_ of collections to a _``Stream``_ of objects.** **flattening is referred to as merging multiple collections/arrays into one**.==

```java
public <R> Stream<R> flatMap( Function<? super T, ? extends Stream<? extends R>> mapper)
```

This gibberish basically says that it returns a Stream of the type that the function contains at a lower level.

```java
List<String> zero = List.of();
var one = List.of("Bonobo");
var two = List.of("Mama Gorilla", "Baby Gorilla");
Stream<List<String>> animals = Stream.of(zero, one, two);
animals.flatMap(m -> m.stream())
.forEach(System.out::println); // Bonobo Mama Gorilla Baby Gorilla
```

```java
Merging Lists into a Single ListList<Integer> list1 = Arrays.asList(1,2,3);
List<Integer> list2 = Arrays.asList(4,5,6);
List<Integer> list3 = Arrays.asList(7,8,9);
List<List<Integer>> listOfLists = Arrays.asList(list1, list2, list3);
List<Integer> listOfAllIntegers = listOfLists.stream()
          .flatMap(x -> x.stream())
          .collect(Collectors.toList());
System.out.println(listOfAllIntegers); // Output[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

---
**Concatenating Streams**

**While ``flatMap()`` is good for the general case, there is a more convenient way to concatenate two streams:**

```java
var one = Stream.of("Bonobo");
var two = Stream.of("Mama Gorilla", "Baby Gorilla");
Stream.concat(one, two)
.forEach(System.out::println);
```

**The two streams are concatenated, and the terminal operation, ``forEach()``, is called.**

---

#### Sorting

The ``sorted()`` method returns a stream with the elements sorted. Just like sorting arrays, Java uses natural ordering unless we specify a comparator

```java
public Stream<T> sorted()
public Stream<T> sorted(Comparator<? super T> comparator)

Stream<String> s = Stream.of("brown-", "bear-");
s.sorted()
.forEach(System.out::print); // bear-brown-


Stream<String> s = Stream.of("brown bear-", "grizzly-");
s.sorted(Comparator.reverseOrder())
.forEach(System.out::print); // grizzly-brown bear-
```

```java
Stream<String> s = Stream.of("brown bear-", "grizzly-");
s.sorted(Comparator::reverseOrder); // DOES NOT COMPILE
```

the second ``sorted()`` method signature It takes a ``Comparator``, which is a functional interface that takes two parameters and returns an int. However, ``Comparator::reverseOrder`` doesn’t do that. Because ``reverseOrder()`` takes no arguments and returns a value, the method reference is equivalent to ``() -> Comparator.reverseOrder()``, which is really a ``Supplier<Comparator>``. This is not compatible with ``sorted()``.

#### Taking a Peek

The ``peek()`` method is useful for debugging because **==it allows us to perform a stream operation without changing the stream.==**

```java
public Stream<T> peek(Consumer<? super T> action)
```

Think of ``peek()`` as an intermediate version of ``forEach()`` that returns the original stream to you.

The most common use for ``peek()`` is to output the contents of the stream as it goes by. Suppose that we made a typo and counted bears beginning with the letter g instead of b. We are puzzled why the count is 1 instead of 2. We can add a peek() method to find out why.

```java
var stream = Stream.of("black bear", "brown bear", "grizzly");
long count = stream.filter(s -> s.startsWith("g"))
.peek(System.out::println).count(); // grizzly
System.out.println(count); // 1
```

### Putting Together the Pipeline

Streams allow you to use chaining and express what you want to accomplish rather than how to do so.

```java
var list = List.of("Toby", "Anna", "Leroy", "Alex");
List<String> filtered = new ArrayList<>();
for (String name: list)
if (name.length() == 4) filtered.add(name);
	Collections.sort(filtered);
var iter = filtered.iterator();
if (iter.hasNext()) System.out.println(iter.next());
if (iter.hasNext()) System.out.println(iter.next());
```

With streams, the equivalent code is as follows:

```java
var list = List.of("Toby", "Anna", "Leroy", "Alex");
list.stream()
	.filter(n -> n.length() == 4)
	.sorted()
	.limit(2)
	.forEach(System.out::println);
```

![[Pasted image 20240421103816.png]]

```java
Stream.generate(() -> "Elsa")
.filter(n -> n.length() == 4)
.sorted()
.limit(2)
.forEach(System.out::println);
```

It hangs until you kill the program, or it throws an exception after running out of memory. The foreperson has instructed ``sorted()`` to wait until everything to sort is present. That never happens because there is an infinite stream.

```java
Stream.generate(() -> "Elsa")
.filter(n -> n.length() == 4)
.limit(2)
.sorted()
.forEach(System.out::println);
```

This one prints Elsa twice. The filter lets elements through, and ``limit()`` stops the earlier operations after two elements. Now ``sorted()`` can sort because we have a finite list.

```java
Stream.generate(() -> "Olaf Lazisson")
.filter(n -> n.length() == 4)
.limit(2)
.sorted()
.forEach(System.out::println);
```

This one hangs as well until we kill the program. The filter doesn’t allow anything through, so ``limit()`` never sees two elements. This means we have to keep waiting and hope that they show up.

You can even chain two pipelines together.

```java
30: long count = Stream.of("goldfish", "finch")
31: .filter(s -> s.length()> 5)
32: .collect(Collectors.toList())
33: .stream()
34: .count();
35: System.out.println(count); // 1
```

- Lines 30–32 are one pipeline, and lines 33 and 34 are another.
- For the first pipeline, line 30 is the source, and line 32 is the terminal operation.
- For the second pipeline, line 33 is the source, and line 34 is the terminal operation.

---

**On the exam, you might see long or complex pipelines as answer choices. If this happens, focus on the differences between the answers. Those will be your clues to the correct answer. This approach will also save you time by not having to study the whole pipeline on each option.** #TIP 

---

When you see chained pipelines, note where the source and terminal operations are. This will help you keep track of what is going on. You can even rewrite the code in your head to have a variable in between so it isn’t as long and complicated.

```java
List<String> helper = Stream.of("goldfish", "finch")
.filter(s -> s.length()> 5)
.collect(Collectors.toList());

long count = helper.stream()
.count();
System.out.println(count);
```

## Working with Primitive Streams

Java actually includes other stream classes besides ``Stream`` that you can use to work with select primitives: ``int``, ``double``, and ``long``. 

```java
Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.reduce(0, (s, n) -> s + n)); // 6
```

There is another way of doing that,

```java
Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.mapToInt(x -> x).sum()); // 6
```

we converted our ``Stream<Integer>`` to an ``IntStream`` and asked the ``IntStream`` to calculate the sum for us. An ``IntStream`` has many of the same intermediate and terminal methods as a ``Stream`` but includes specialized methods for working with numeric data. The primitive streams know how to perform certain common operations automatically.

```java
IntStream intStream = IntStream.of(1, 2, 3);
OptionalDouble avg = intStream.average();
System.out.println(avg.getAsDouble()); // 2.0
```

### Creating Primitive Streams

-  **``IntStream``**: Used for the primitive types ``int``, ``short``, ``byte``, and ``char``
-  **``LongStream``**: Used for the primitive type ``long``
-  **``DoubleStream``**: Used for the primitive types ``double`` and ``float``

---

**When you see the word stream on the exam, pay attention to the case. With a capital ``S`` or in code, ``Stream`` is the name of a class that contains an ``Object`` type. With a lowercase s, a stream is a concept that might be a Stream, ``DoubleStream``, ``IntStream``, or ``LongStream``.** #TIP

---

![[Pasted image 20240421190714.png]]
![[Pasted image 20240421190730.png]]

can create an empty stream with this:

```java
DoubleStream empty = DoubleStream.empty();
```

Another way is to use the ``of()`` factory method from a single value or by using the varargs overload.

```java
DoubleStream oneValue = DoubleStream.of(3.14);
oneValue.forEach(System.out::println); // 3.14

DoubleStream varargs = DoubleStream.of(1.0, 1.1, 1.2);
varargs.forEach(System.out::println); // 1.0, 1.1, 1.2
```

can also use the two methods for creating infinite streams

```java
var random = DoubleStream.generate(Math::random);
var fractions = DoubleStream.iterate(.5, d -> d / 2);
random.limit(3).forEach(System.out::println);
fractions.limit(3).forEach(System.out::println);
```

```java
IntStream count = IntStream.iterate(1, n -> n+1).limit(5);
count.forEach(System.out::print); // 12345
```

This code does print out the numbers 1–5. However, it is a lot of code to do something so simple. Java provides a method that can generate a range of numbers.

```java
IntStream range = IntStream.range(1, 6);
range.forEach(System.out::print); // 12345
```

The first parameter to the ``range()`` method is inclusive, which means it includes the number. **==The second parameter to the ``range()`` method is exclusive, which means it stops right before that number. there’s another method, ``rangeClosed()``, which is inclusive on both parameters.==**

```java
IntStream rangeClosed = IntStream.rangeClosed(1, 5);
rangeClosed.forEach(System.out::print); // 12345
```

### Mapping Streams

![[Pasted image 20240421191230.png]]

Obviously, they have to be compatible types for this to work

```java
Stream<String> objStream = Stream.of("penguin", "fish");
IntStream intStream = objStream.mapToInt(s -> s.length());
```

The function mappings are intuitive here. They take the source type and return the target type.

---
**Using ``flatMap()``**

**We can use this approach on primitive streams as well. It works the same way as on a regular ``Stream``, except the method name is different.**

```java
var integerList = new ArrayList<Integer>();
IntStream ints = integerList.stream()
	.flatMapToInt(x -> IntStream.of(x));
DoubleStream doubles = integerList.stream()
	.flatMapToDouble(x -> DoubleStream.of(x));
LongStream longs = integerList.stream()
	.flatMapToLong(x -> LongStream.of(x));
```

---

![[Pasted image 20240421191445.png]]

Additionally, you can create a ``Stream`` from a primitive stream

```java
private static Stream<Integer> mapping(IntStream stream) {
	return stream.mapToObj(x -> x);
}
private static Stream<Integer> boxing(IntStream stream) {
	return stream.boxed();
}
```

- The first one uses the ``mapToObj()``
- The second one is more succinct. It does not require a mapping function because all it does is autobox each primitive to the corresponding wrapper object. The ``boxed()`` method exists on all three types of primitive streams.

### Using Optional with Primitive Streams

```java
var stream = IntStream.rangeClosed(1,10);
OptionalDouble optional = stream.average();
```

The return type is not the ``Optional`` you have become accustomed to using. It is a new type called ``OptionalDouble``. Why not just use ``Optional<Double>``? **==The difference is that ``OptionalDouble`` is for a primitive and ``Optional<Double>`` is for the ``Double`` wrapper class. Working with the primitive optional class looks similar to working with the ``Optional`` class itself.==**

```java
optional.ifPresent(System.out::println); // 5.5
System.out.println(optional.getAsDouble()); // 5.5
System.out.println(optional.orElseGet(() -> Double.NaN)); // 5.5
```

The only noticeable difference is that we called ``getAsDouble()`` rather than ``get()``. This makes it clear that we are working with a primitive.

The primitive stream implementations also add two new methods that you need to know. The ``sum()`` method does not return an optional. If you try to add up an empty stream, you simply get zero. **==The ``average()`` method always returns an ``OptionalDouble`` since an average can potentially have fractional data for any type.==**

![[Pasted image 20240421193218.png]]

```java
5: LongStream longs = LongStream.of(5, 10);
6: long sum = longs.sum();
7: System.out.println(sum); // 15
8: DoubleStream doubles = DoubleStream.generate(() -> Math.PI);
9: OptionalDouble min = doubles.min(); // runs infinitely
```

### Summarizing Statistics


```java
private static int range(IntStream ints) {
	IntSummaryStatistics stats = ints.summaryStatistics();
	if (stats.getCount() == 0) throw new RuntimeException();
	return stats.getMax()-stats.getMin();
}
```

Here we asked Java to perform many calculations about the stream. Summary statistics include the following:

-  ==**``getCount()``**: Returns a long representing the number of values.==
-  ==**``getAverage()``**: Returns a double representing the average. If the stream is empty, returns 0.==
-  ==**``getSum()``**: Returns the sum as a double for ``DoubleSummaryStream`` and long for ``IntSummaryStream`` and ``LongSummaryStream``.==
-  ==**``getMin()``**: Returns the smallest number (minimum) as a double, int, or long, depending on the type of the stream. If the stream is empty, returns the largest numeric value based on the type.==
-  ==**``getMax()``**: Returns the largest number (maximum) as a double, int, or long depending on the type of the stream. If the stream is empty, returns the smallest numeric value based on the type==

```java
public class IntSummaryStatisticsExample2 {  
    public static void main(String[] args) {  
  
        String limerick = "There was a young lady named Bright " +  
                "who traveled much faster than light " +  
                "She set out one day " +  
                "in a relative way " +  
                "and came back the previous night ";  
  
        IntSummaryStatistics wordStatistics =  
                Pattern.compile(" ")  
                        .splitAsStream(limerick)  
                        .mapToInt(String::length)  
                        .summaryStatistics();  
  
        System.out.printf("""  
                        Number of words = %d  
                        Sum of the length of the words = %d  
                        Minimum word size = %d  
                        Maximum word size %d  
                        Average word size = %f  
                        """,  
                wordStatistics.getCount(),  // 28
                wordStatistics.getSum(),  // 115
                wordStatistics.getMin(),  // 1
                wordStatistics.getMax(),  // 8
                wordStatistics.getAverage()); // 4.107143 
    }  
}
```

## Working with Advanced Stream Pipeline Concepts

### Linking Streams to the Underlying Data

```java
25: var cats = new ArrayList<String>();
26: cats.add("Annie");
27: cats.add("Ripley");
28: var stream = cats.stream();
29: cats.add("KC");
30: System.out.println(stream.count()); // 3
```

**==Remember that streams are lazily evaluated. This means that the stream isn’t created on line 28. An object is created that knows where to look for the data when it is needed. On line 30, the stream pipeline runs. First, it looks at the source and seeing three elements.==**

### Chaining Optionals

few of the intermediate operations for streams are available for ``Optional``. 

```java
private static void threeDigit(Optional<Integer> optional) {
		if (optional.isPresent()) { // outer if
		var num = optional.get();
		var string = "" + num;
		if (string.length() == 3) // inner if
			System.out.println(string);
	}
}
```

```java
private static void threeDigit(Optional<Integer> optional) {
optional.map(n -> "" + n) // part 1
	.filter(s -> s.length() == 3) // part 2
	.ifPresent(System.out::println); // part 3
}
```

This is much shorter and more expressive. With lambdas, the exam is fond of carving up a single statement and identifying the pieces with a comment

Now suppose that we wanted to get an ``Optional<Integer>`` representing the length of the ``String`` contained in another ``Optional``.

```java
Optional<Integer> result = optional.map(String::length);
```

What if we had a helper method that did the logic of calculating something for us that returns ``Optional<Integer>``?

```java
Optional<Integer> result = optional.map(ChainingOptionals::calculator); // DOES NOT COMPILE
```

The problem is that calculator returns ``Optional<Integer>``. The map() method adds another ``Optional``, giving us Optional``<Optional<Integer>>``. Well, that’s no good. The solution is to call ``flatMap()``, instead:

```java
Optional<Integer> result = optional.flatMap(ChainingOptionals::calculator);
```

This one works because ``flatMap`` removes the unnecessary layer. In other words, it flattens the result. Chaining calls to ``flatMap()`` is useful when you want to transform one ``Optional`` type to another.

### Using a ``Spliterator``

The characteristics of a ``Spliterator`` depend on the underlying data source. A ``Collection`` data source is a basic ``Spliterator``. By contrast, when using a ``Stream`` data source, the ``Spliterator`` can be parallel or even infinite. The ``Stream`` itself is executed lazily rather than when the ``Spliterator`` is created.

![[Pasted image 20240421195812.png]]

```java
12: var stream = List.of("bird-","bunny-","cat-","dog-","fish-","lamb-","mouse-");
13: Spliterator<String> originalBagOfFood = stream.spliterator();
14: Spliterator<String> emmasBag = originalBagOfFood.trySplit();
15: emmasBag.forEachRemaining(System.out::print); // bird-bunny- cat-

16: Spliterator<String> jillsBag = originalBagOfFood.trySplit(); // size 4
17: jillsBag.tryAdvance(System.out::print); // dog-20:
18:	jillsBag.forEachRemaining(System.out::print); // fish-21:
19: originalBagOfFood.forEachRemaining(System.out::print); // lamb-mouse-
```

```java
var originalBag = Stream.iterate(1, n -> ++n)
.spliterator();
Spliterator<Integer> newBag = originalBag.trySplit();
newBag.tryAdvance(System.out::print); // 1
newBag.tryAdvance(System.out::print); // 2
newBag.tryAdvance(System.out::print); // 3
```

this is an infinite stream. No problem! The ``Spliterator`` recognizes that the stream is infinite and doesn’t attempt to give you half. Instead, ``newBag`` contains a large number of elements. We get the first three since we call ``tryAdvance()`` three times. It would be a bad idea to call ``forEachRemaining()`` on an infinite stream!

```java
public class SpliteratorExample4 {  
  
    public static void main(String[] args) {  
  
        List<String> values = new ArrayList<>();  
  
        values.add("one");  
        values.add("two");  
        values.add("three");  
        values.add("four");  
        values.add("five");  
        values.add("six");  
        values.add("seven");  
        values.add("eight");  
        values.add("nine");  
        values.add("ten");  
        values.add("eleven");  
  
        Spliterator<String> spliterator = values.spliterator();  
  
        Spliterator<String> childSpliterator = spliterator.trySplit();  
  
        System.out.println("### childSpliterator ###");  
        childSpliterator.forEachRemaining(System.out::println);  
  
        System.out.println("### otherChildSpliterator ###");  
        Spliterator<String> otherChildSpliterator = spliterator.trySplit();  
        otherChildSpliterator.forEachRemaining(System.out::println);  
  
  
        System.out.println("### anotherChildSpliterator ###");  
        Spliterator<String> anotherChildSpliterator = spliterator.trySplit();  
        anotherChildSpliterator.forEachRemaining(System.out::println);  
  
  
        System.out.println("### Spliterator ###");  
        spliterator.forEachRemaining(System.out::println);  
    }
```

### Collecting Results

#### Using Basic Collectors

```java
var ohMy = Stream.of("lions", "tigers", "bears");
String result = ohMy.collect(Collectors.joining(", "));
System.out.println(result); // lions, tigers, bears
```

Notice how the predefined collectors are in the ``Collectors`` class rather than the ``Collector`` interface.

![[Pasted image 20240421200158.png]]
![[Pasted image 20240421200210.png]]

**==It is important to pass the ``Collector`` to the collect method. It exists to help collect elements. A ``Collector`` doesn’t do anything on its own.==** 

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Double result = ohMy.collect(Collectors.averagingInt(String::length));
System.out.println(result); // 5.333333333333333
```

The pattern is the same. We pass a collector to ``collect()``, and it performs the average for us. This time, we needed to pass a function to tell the collector what to average.

Often, you’ll find yourself interacting with code that was written without streams. This means that it will expect a ``Collection`` type rather than a ``Stream`` type.

```java
var ohMy = Stream.of("lions", "tigers", "bears");
TreeSet<String> result = ohMy.filter(s -> s.startsWith("t"))
.collect(Collectors.toCollection(TreeSet::new));
System.out.println(result); // [tigers]
```

#### Collecting into Maps

When creating a map, you need to specify two functions
- The first function tells the collector how to create the key.
- The second function tells the collector how to create the value.

---

**Returning the same value passed into a lambda is a common operation, so Java provides a method for it. You can rewrite ``s -> s`` as ``Function.identity()``.**

---

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, String> map = ohMy.collect(Collectors.toMap(
	String::length, k -> k)); // BAD
```

```output
Exception in thread "main"
java.lang.IllegalStateException: Duplicate key 5
```

What’s wrong? Two of the animal names are the same length. We didn’t tell Java what to do. Should the collector choose the first one it encounters? The last one it encounters? Concatenate the two? Since the collector has no idea what to do, it “solves” the problem by throwing an exception and making it our problem.

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, String> map = ohMy.collect(Collectors.toMap(
String::length,
k -> k, (s1, s2) -> s1 + "," + s2));
System.out.println(map); // {5=lions,bears, 6=tigers}
System.out.println(map.getClass()); // class java.util.HashMap
```


```java
var ohMy = Stream.of("lions", "tigers", "bears");
TreeMap<Integer, String> map = ohMy.collect(Collectors.toMap(
String::length,
k -> k, (s1, s2) -> s1 + "," + s2,
TreeMap::new));
System.out.println(map); // // {5=lions,bears, 6=tigers}
System.out.println(map.getClass()); // class java.util.TreeMap
```

#### Grouping, Partitioning, and Mapping

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, List<String>> map = ohMy.collect(
Collectors.groupingBy(String::length));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}
```

The ``groupingBy()`` collector tells ``collect()`` that it should group all of the elements of the stream into a ``Map``. The function determines the keys in the ``Map``. Each value in the ``Map`` is a ``List`` of all entries that match that key.

---

**==Note that the function you call in ``groupingBy()`` cannot return ``null``. It does not allow ``null`` keys.==**

---

There’s another method signature that lets us pass a downstream collector.

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, Set<String>> map = ohMy.collect(
Collectors.groupingBy(
	String::length,
	Collectors.toSet()));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}
```

We can even change the type of ``Map`` returned through yet another parameter

```java
var ohMy = Stream.of("lions", "tigers", "bears");
TreeMap<Integer, Set<String>> map = ohMy.collect(
Collectors.groupingBy(
String::length,
TreeMap::new,
Collectors.toSet()));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}
```

```java
var ohMy = Stream.of("lions", "tigers", "bears");
TreeMap<Integer, List<String>> map = ohMy.collect(
Collectors.groupingBy(
String::length,
TreeMap::new,
Collectors.toList()));
System.out.println(map);
```

**==Partitioning is a special case of grouping. With partitioning, there are only two possible groups: true and false. Partitioning is like splitting a list into two parts.==**

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Map<Boolean, List<String>> map = ohMy.collect(
Collectors.partitioningBy(s -> s.length() <= 5));
System.out.println(map); // {false=[tigers], true=[lions, bears]}
```

we pass a ``Predicate`` with the logic for which group each animal name belongs in.

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Map<Boolean, List<String>> map = ohMy.collect(
Collectors.partitioningBy(s -> s.length() <= 7));
System.out.println(map); // {false=[], true=[lions, tigers, bears]}
```

**==Notice that there are still two keys in the map—one for each boolean value.==** It so happens that one of the values is an empty list, but it is still there. As with ``groupingBy()``, we can change the type of List to something else.

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Map<Boolean, Set<String>> map = ohMy.collect(
Collectors.partitioningBy(
s -> s.length() <= 7,
Collectors.toSet()));
System.out.println(map); // {false=[], true=[lions, tigers, bears]}
```

Unlike ``groupingBy()``, we cannot change the type of ``Map`` that is returned

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, Long> map = ohMy.collect(
Collectors.groupingBy(
String::length,
Collectors.counting()));
System.out.println(map); // {5=2, 6=1}
```

Finally, there is a ``mapping()`` collector that lets us go down a level and add another collector. Suppose that we wanted to get the first letter of the first animal alphabetically of each length.

```java
var ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, Optional<Character>> map = ohMy.collect(
Collectors.groupingBy(
String::length,
Collectors.mapping(
s -> s.charAt(0),
Collectors.minBy((a, b) -> a - b))));
System.out.println(map); // {5=Optional[b], 6=Optional[t]}
```

we replaced ``counting()`` with ``mapping()``. It so happens that ``mapping()`` takes two parameters: the function for the value and how to group it further. You might see collectors used with a static import to make the code shorter. The exam might even use var for the return value and less indentation than we used

```java
var ohMy = Stream.of("lions", "tigers", "bears");
var map = ohMy.collect(groupingBy(String::length,
mapping(s -> s.charAt(0), minBy((a, b) -> a -b))));
System.out.println(map); // {5=Optional[b], 6=Optional[t]}
```

#### Teeing Collectors

Suppose you want to return two things. this is problematic with streams because you only get one pass. Luckily, you can use ``teeing()`` to return multiple values of your own.

```java
var list = List.of("x", "y", "z");
Separations result = list.stream()
.collect(Collectors.teeing(
Collectors.joining(" "),
Collectors.joining(","),
(s, c) -> new Separations(s, c)));
System.out.println(result); // Separations[spaceSeparated=x y z, commaSeparated=x,y,z]
```

There are three ``Collectors`` in this code. Two of them are for ``joining()`` and produce the values we want to return. The third is ``teeing()``, which combines the results into the single object we want to return. This way, Java is happy because only one object is returned

## Summary #OCP_Summary 

**==An ``Optional<T>`` can be empty or store a value. You can check whether it contains a value with ``isPresent()`` and ``get()`` the value inside. You can return a different value with ``orElse(T t)`` or throw an exception with ``orElseThrow()``. There are even three methods that take functional interfaces as parameters: ``ifPresent(Consumer c)``, ``orElseGet(Supplier s)``, and ``orElseThrow(Supplier s)``. There are three optional types for primitives: ``OptionalDouble``, ``OptionalInt``, and ``OptionalLong``. These have the methods ``getAsDouble()``, ``getAsInt()``, and ``getAsLong()``, respectively.**==
 
 ==**A stream pipeline has three parts. The source is required, and it creates the data in the stream. There can be zero or more intermediate operations, which aren’t executed until the terminal operation runs. The first stream class we covered was ``Stream<T>``, which takes a generic argument ``T``. The ``Stream<T>`` class includes many useful intermediate operations including ``filter()``, ``map()``, ``flatMap()``, and ``sorted()``. Examples of terminal operations include ``allMatch()``, ``count()``, and ``forEach()``.**==

==**Besides the ``Stream<T>`` class, there are three primitive streams: ``DoubleStream``, ``IntStream``, and ``LongStream``. In addition to the usual ``Stream<T>`` methods, ``IntStream`` and ``LongStream`` have range() and ``rangeClosed()``. The call range(1, 10) on ``IntStream`` and ``LongStream`` creates a stream of the primitives from 1 to 9. By contrast, ``rangeClosed(1, 10)`` creates a stream of the primitives from 1 to 10. The primitive streams have math operations including ``average()``, ``max()``, and ``sum()``. They also have ``summaryStatistics()`` to get many statistics in one call.**==

==**You can use a ``Collector`` to transform a stream into a traditional collection. You can even group fields to create a complex map in one line. Partitioning works the same way as grouping, except that the keys are always true and false. A partitioned map always has two keys, even if the value is empty for the key. A teeing collector allows you to combine the results of two other collectors.**==

==**remember that streams are lazily evaluated. They take lambdas or method references as parameters, which execute later when the method is run.==**

## Exam Essentials #Essential 

**Write code that uses Optional**. Creating an ``Optional`` uses ``Optional.empty()`` or ``Optional.of()``. Retrieval frequently uses ``isPresent()`` and ``get()``. Alternatively, there are the functional ``ifPresent()`` and ``orElseGet()`` methods.

**Recognize which operations cause a stream pipeline to execute**. Intermediate operations do not run until the terminal operation is encountered. **==If no terminal operation is in the pipeline, a ``Stream`` is returned but not executed==**. Examples of terminal operations include ``collect()``, ``forEach()``, ``min()``, and ``reduce()``.

**Determine which terminal operations are reductions**. Reductions use all elements of the stream in determining the result. The reductions that you need to know are ``collect()``, ``count()``, ``max()``, ``min()``, and ``reduce()``. A mutable reduction collects into the same object as it goes. The ``collect()`` method is a mutable reduction.

**Write code for common intermediate operations**. The ``filter()`` method returns a ``Stream<T>`` filtering on a ``Predicate<T>``. The ``map()`` method returns a ``Stream``, transforming each element of type ``T`` to another type ``R`` through a ``Function <T,R>``. The ``flatMap()`` method flattens nested streams into a single level and removes empty streams.

**Compare primitive streams to ``Stream<T>``**. Primitive streams are useful for performing common operations on numeric types, including statistics like ``average()``, ``sum()``, and so on. There are three primitive stream classes: ``DoubleStream``, ``IntStream``, and ``LongStream``. There are also three primitive ``Optional`` classes: ``OptionalDouble``, ``OptionalInt``, and ``OptionalLong``. Aside from ``BooleanSupplier``, they all involve the double, int, or long primitives.

**Convert primitive stream types to other primitive stream types**. Normally, when mapping, you just call the ``map()`` method. When changing the class used for the stream, a different method is needed. To convert to Stream, you use ``mapToObj()``. To convert to ``DoubleStream``, you use ``mapToDouble()``. To convert to ``IntStream``, you use ``mapToInt()``. To convert to ``LongStream``, you use ``mapToLong()``.

**Use ``peek()`` to inspect the stream**. The ``peek()`` method is an intermediate operation often used for debugging purposes. It executes a lambda or method reference on the input and passes that same input through the pipeline to the next operator. It is useful for printing out what passes through a certain point in a stream.

**Search a stream**. The ``findFirst()`` and ``findAny()`` methods return a single element from a stream in an Optional. **==The ``anyMatch()``, ``allMatch()``, and ``noneMatch()`` methods return a boolean. Be careful, because these three can hang if called on an infinite stream with some data.==** All of these methods are terminal operations.

**Sort a stream**. The ``sorted()`` method is an intermediate operation that sorts a stream. There are two versions: the signature with zero parameters that sorts using the natural sort order, and the signature with one parameter that sorts using that ``Comparator`` as the sort order.

**Compare ``groupingBy()`` and ``partitioningBy()``**. The ``groupingBy()`` method is a terminal operation that creates a Map. The keys and return types are determined by the parameters you pass. The values in the Map are a Collection for all the entries that map to that key. **==The ``partitioningBy()`` method also returns a Map. This time, the keys are true and false. The values are again a Collection of matches. If there are no matches for that boolean, the Collection is empty.==**

## Review Questions

1. What could be the output of the following?

```java
var stream = Stream.iterate("", (s) -> s + "1"); 
System.out.println(stream.limit(2).map(x -> x + "2"));
```

A. 12112
B. 212
C. 212112
D. java.util.stream.ReferencePipeline$3@4517d9a3
E. The code does not compile.
F. An exception is thrown.
G. The code hangs.

**My Answer: D**
**Correct Answer: D**

**No terminal operation is called, so the stream never executes. The first line creates an infinite stream reference. If the stream were executed on the second line, it would get the first two elements from that infinite stream, "" and "1", and add an extra character, resulting in "2" and "12", respectively. Since the stream is not executed, the reference is printed instead, giving us option D.**

---

2. What could be the output of the following?

```JAVA
Predicate<String> predicate = s -> s.startsWith("g");
var stream1 = Stream.generate(() -> "growl!");
var stream2 = Stream.generate(() -> "growl!");
var b1 = stream1.anyMatch(predicate);
var b2 = stream2.allMatch(predicate);
System.out.println(b1 + " " + b2);
```

A. true false
B. true true
C. java.util.stream.ReferencePipeline$3@4517d9a3
D. The code does not compile.
E. An exception is thrown.
F. The code hangs.

**My Answer: F**
**Correct Answer: F**

**Both streams created in this code snippet are infinite streams. The variable b1 is set to true since anyMatch() terminates. Even though the stream is infinite, Java finds a match on the first element and stops looking. However, when allMatch() runs, it needs to keep going until the end of the stream since it keeps finding matches. Since all elements continue to match, the program hangs, making option F the answer.**

---

3.  What could be the output of the following?

```JAVA
Predicate<String> predicate = s -> s.length()> 3;
var stream = Stream.iterate("-", s -> ! s.isEmpty(), (s) -> s + s);
var b1 = stream.noneMatch(predicate);
var b2 = stream.anyMatch(predicate);
System.out.println(b1 + " " + b2);
```

A. false false
B. false true
C. java.util.stream.ReferencePipeline$3@4517d9a3
D. The code does not compile.
E. An exception is thrown.
F. The code hangs.

**My Answer: D**
**Correct Answer: E**

**An infinite stream is generated where each element is twice as long as the previous one.**
**While this code uses the three-parameter iterate() method, the condition is never false. The variable b1 is set to false because Java finds an element that matches when it gets to the element of length 4. However, the next line tries to operate on the same stream. ==Since streams can be used only once, this throws an exception that the “stream has already been operated upon or closed” and making option E the answer==. If two different streams were used, the result would be option B**

---

4. Which are true statements about terminal operations in a stream that runs successfully? (Choose all that apply.)

A. At most one terminal operation can exist in a stream pipeline.
B. Terminal operations are a required part of the stream pipeline in order to get a result.
C. Terminal operations have Stream as the return type.
D. The peek() method is an example of a terminal operation.
E. The referenced Stream may be used after calling a terminal operation.

**My Answer: A,B**
**Correct Answer: A,B**

**Terminal operations are the final step in a stream pipeline. Exactly one is required, because it triggers the execution of the entire stream pipeline. Therefore, options A and B are correct.**

---

5. Which of the following sets result to 8.0? (Choose all that apply.)

A. 
```java
double result = LongStream.of(6L, 8L, 10L)
    .mapToInt(x -> (int) x)
    .collect(Collectors.groupingBy(x -> x))
    .keySet()
    .stream()
    .collect(Collectors.averagingInt(x -> x));

```

B. 
```JAVA
double result = LongStream.of(6L, 8L, 10L)
    .mapToInt(x -> x)
    .boxed()
    .collect(Collectors.groupingBy(x -> x))
    .keySet()
    .stream()
    .collect(Collectors.averagingInt(x -> x));

```

C.
```JAVA
double result = LongStream.of(6L, 8L, 10L)
    .mapToInt(x -> (int) x)
    .boxed()
    .collect(Collectors.groupingBy(x -> x))
    .keySet()
    .stream()
    .collect(Collectors.averagingInt(x -> x));
```

D.

```JAVA
double result = LongStream.of(6L, 8L, 10L)
    .mapToInt(x -> (int) x)
    .collect(Collectors.groupingBy(x -> x, Collectors.toSet()))
    .keySet()
    .stream()
    .collect(Collectors.averagingInt(x -> x));
```

E.
```Java
double result = LongStream.of(6L, 8L, 10L)
    .mapToInt(x -> x)
    .boxed()
    .collect(Collectors.groupingBy(x -> x, Collectors.toSet()))
    .keySet()
    .stream()
    .collect(Collectors.averagingInt(x -> x));
```

F.
```JAVA
double result = LongStream.of(6L, 8L, 10L)
    .mapToInt(x -> (int) x)
    .boxed()
    .collect(Collectors.groupingBy(x -> x, Collectors.toSet()))
    .keySet()
    .stream()
    .collect(Collectors.averagingInt(x -> x));
```

**My Answer: E,F**
**Correct Answer: C,F**

**Remember to look for the differences between options rather than studying each line. These options all have much in common. All of them start out with a LongStream and attempt to convert it to an IntStream. However, options B and E are incorrect because they do not cast the long to an int, resulting in a compiler error on the mapToInt() calls. the second difference. ==Options A and D are incorrect because they are missing boxed() before the collect() call. Since groupingBy() is creating a Collection, we need a nonprimitive Stream.== The final difference is that option F specifies the type of Collection. This is allowed, though, meaning both options C and F are correct.**

---

6. Which of the following can fill in the blank so that the code prints out false? (Choose all that apply.)

```JAVA
var s = Stream.generate(() -> "meow");
var match = s. (String::isEmpty);
System.out.println(match);
```

A. allMatch
B. anyMatch
C. findAny
D. findFirst
E. noneMatch
F. None of the above

**My Answer: F**
**Correct Answer: A**

**Option A is correct because it is safe to return false as soon as one element passes through the stream that doesn’t match.**

---

7. We have a method that returns a sorted list without changing the original. Which of the following can replace the method implementation to do the same with streams?

```java
private static List<String> sort(List<String> list) {
var copy = new ArrayList<String>(list);
Collections.sort(copy, (a, b) -> b.compareTo(a));
return copy;
}
```

A. 
```JAVA
return list.stream()
    .sorted((a, b) -> b.compareTo(a))
    .collect(Collectors.toList());

```

B.
```JAVA
return list.stream()
    .compare((a, b) -> b.compareTo(a))
    .sort();
```

C.
```JAVA
return list.stream()
    .compareTo((a, b) -> b.compareTo(a))
    .collect(Collectors.toList());
```

D.
```JAVA
return list.stream()
    .compareTo((a, b) -> b.compareTo(a))
    .sort();

```

E.
```JAVA
return list.stream()
    .sorted((a, b) -> b.compareTo(a))
    .collect();
```

F. 
```JAVA
return list.stream()
    .sorted((a, b) -> b.compareTo(a))
    .collect(Collectors.toList());
```

**My Answer: F**
**Correct Answer: F**

**There is no Stream< T > method called compare() or compareTo(), so options A through D can be eliminated. The sorted() method is correct to use in a stream pipeline to return a sorted Stream. The collect() method can be used to turn the stream into a List. The collect() method requires a collector be selected, making option E incorrect and option F correct.**

---

8. Which of the following are true given this declaration? (Choose all that apply.)
```JAVA
var is = IntStream.empty();
```

A. is.average() returns the type int.
B. is.average() returns the type OptionalInt.
C. is.findAny() returns the type int.
D. is.findAny() returns the type OptionalInt.
E. is.sum() returns the type int.
F. is.sum() returns the type OptionalInt.

**My Answer: D,E**
**Correct Answer: D,E**

**The average() method returns an OptionalDouble since averages of any type can result in a fraction. Therefore, options A and B are both incorrect. The findAny() method returns an OptionalInt because there might not be any elements to find. Therefore, option D is correct. The sum() method returns an int rather than an OptionalInt because the sum of an empty list is zero. Therefore, option E is correct.**

---

9. Which of the following can we add after line 6 for the code to run without error and not produce any output? (Choose all that apply.)

```java
4: var stream = LongStream.of(1, 2, 3);
5: var opt = stream.map(n -> n * 10)
6: ??.filter(n -> n < 5).findFirst();
```

A.
```java
if (opt.isPresent())
    System.out.println(opt.get());
```

B.
```JAVA
if (opt.isPresent())
    System.out.println(opt.getAsLong());
```

C.
```JAVA
opt.ifPresent(System.out.println);
```

D.
```JAVA
opt.ifPresent(System.out::println);
```

E. None of these; the code does not compile.
F. None of these; line 6 throws an exception at runtime.

**My Answer: B**
**Correct Answer: B,D**

**Options B and D both compile and run without error, although neither produces any output at runtime since the stream is empty.**

---

10. Given the four statements (L, M, N, O), select and order the ones that would complete the expression and cause the code to output 10 lines. (Choose all that apply.)

```JAVA
Stream.generate(() -> "1")
L: .filter(x -> x.length()> 1)
M: .forEach(System.out::println)
N: .limit(10)
O: .peek(System.out::println)
```

**My Answer: F**
**Correct Answer: F**

**Only one of the method calls, forEach(), is a terminal operation, so any answer in which M is not the last line will not execute the pipeline. Only option F is correct. It first limits the infinite stream to a finite stream of ten elements and then prints the result.**

---

11. What changes need to be made together for this code to print the string 12345? (Choose all that apply.)

```JAVA
Stream.iterate(1, x -> x++)
.limit(5).map(x -> x)
.collect(Collectors.joining());
```

A. Change Collectors.joining() to Collectors.joining(",").
B. Change map(x -> x) to map(x -> "" + x).
C. Change x -> x++ to x -> ++x.
D. Add .forEach(System.out::print) after the call to collect().
E. Wrap the entire line in a System.out.print statement.
F. None of the above. The code already prints 12345.

**My Answer: B**
**Correct Answer: B,C,E**

**As written, the code doesn’t compile because ==the Collectors.joining() expects to get a Stream < String>==. Option B fixes this, at which point nothing is output because the collector creates a String without outputting the result. Option E fixes this and causes the output to be 11111. Since the post-increment operator is used, the stream contains an infinite number of the character 1. Option C fixes this and causes the stream to contain increasing numbers.**

---

12. Which is true of the following code?

```JAVA
Set<String> birds = Set.of("oriole", "flamingo");
Stream.concat(birds.stream(), birds.stream(), birds.stream())
.sorted() // line X
.distinct()
.findAny()
.ifPresent(System.out::println);
```

A. It is guaranteed to print flamingo as is and when line X is removed.
B. It is guaranteed to print oriole as is and when line X is removed.
C. It is guaranteed to print flamingo as is, but not when line X is removed.
D. It is guaranteed to print oriole as is, but not when line X is removed.
E. The output may vary as is.
F. The code does not compile.
G. It throws an exception because the same list is used as the source for multiple streams.

**My Answer: F**
**Correct Answer: F**

**The code does not compile because ==Stream.concat() takes two parameters==, not the three provided.**

---

13. Which of the following is true?

```JAVA
List<Integer> x1 = List.of(1, 2, 3);
List<Integer> x2 = List.of(4, 5, 6);
List<Integer> x3 = List.of();
Stream.of(x1, x2, x3).map(x -> x + 1)
.flatMap(x -> x.stream())
.forEach(System.out::print);
```

A. The code compiles and prints 123456.
B. The code compiles and prints 234567.
C. The code compiles but does not print anything.
D. The code compiles but prints stream references.
E. The code runs infinitely.
F. The code does not compile.
G. The code throws an exception.

**My Answer: B**
**Correct Answer: G**

**If the map() and flatMap() calls were reversed, option B would be correct. In this case, the Stream created from the source is of type Stream< List>. Trying to use the addition operator (+) on a List is not supported in Java. Therefore, the code does not compile, and option F is correct.**

---

14. Which of the following are true? (Choose all that apply.)

```JAVA
4: Stream<Integer> s = Stream.of(1);
5: IntStream is = s.boxed();
6: DoubleStream ds = s.mapToDouble(x -> x);
7: Stream<Integer> s2 = ds.mapToInt(x -> x);
8: s2.forEach(System.out::print);
```

A. Line 4 causes a compiler error.
B. Line 5 causes a compiler error.
C. Line 6 causes a compiler error.
D. Line 7 causes a compiler error.
E. Line 8 causes a compiler error.
F. The code compiles but throws an exception at runtime.
G. The code compiles and prints 1.

**My Answer: B**
**Correct Answer: B,D**

**Line 5 does not compile because boxed() is available only on primitive streams like IntStream, not Stream< Integer>. This makes option B one answer. Line 7 does not compile for two reasons making option D the second answer. First, converting from a double to an int would require an explicit cast. Also, mapToInt() returns an IntStream, so the data type of s2 is incorrect**

---

15. Given the generic type String, the partitioningBy() collector creates a ``Map<Boolean, List<String>>`` when passed to collect() by default. When a downstream collector is passed to partitioningBy(), which return types can be created? (Choose all that apply.)

`A. Map<boolean, List<String>>`
`B. Map<Boolean, List<String>>`
`C. Map<Boolean, Map<String>>`
`D. Map<Boolean, Set<String>>`
`E. Map<Long, TreeSet<String>>`
`F. None of the above`

**My Answer: B,D**
**Correct Answer: B,D**

**a Map with a Boolean key and a value type that can be customized to any Collection.**

---

16. Which of the following statements are true about this code? (Choose all that apply.)
```java
20: Predicate<String> empty = String::isEmpty;
21: Predicate<String> notEmpty = empty.negate();
22:
23: var result = Stream.generate(() -> "")
24: .limit(10)
25: .filter(notEmpty)
26: .collect(Collectors.groupingBy(k -> k))
27: .entrySet()
28: .stream()
29: .map(Entry::getValue)
30: .flatMap(Collection::stream)
31: .collect(Collectors.partitioningBy(notEmpty));
32: System.out.println(result);
```

A. It outputs {}.
B. It outputs {false=[], true=[]}.
C. If we changed line 31 from partitioningBy(notEmpty) to
groupingBy(n -> n), it would output {}.
D. If we changed line 31 from partitioningBy(notEmpty) to
groupingBy(n -> n), it would output {false=[], true=[]}.
E. The code does not compile.
F. The code compiles but does not terminate at runtime.

**My Answer: A**
**Correct Answer: B,C**

**The partitioningBy() operation always returns a map with two Boolean keys, even if there are no corresponding values. Therefore, option B is correct if the code is kept as is. By contrast, groupingBy() returns only keys that are actually needed, making option C correct if the code is modified on line 31.**

---
17. What is the result of the following?

```JAVA
var s = DoubleStream.of(1.2, 2.4);
s.peek(System.out::println).filter(x -> x> 2).count();
```

A. 1
B. 2
C. 2.4
D. 1.2 and 2.4
E. There is no output.
F. The code does not compile.
G. An exception is thrown

**My Answer: A**
**Correct Answer: D**

**The terminal operation is count(). Since there is a terminal operation, the intermediate operations run. The peek() operation comes before the filter(), so both numbers are printed, making option D the answer.**

---

18. What is the output of the following?

```JAVA
11: public class Paging {
12: record Sesame(String name, boolean human) {
13: @Override public String toString() {
14: return name();
15: }
16: }
17: record Page(List<Sesame> list, long count) {}
18:
19: public static void main(String[] args) {
20: var monsters = Stream.of(new Sesame("Elmo", false));
21: var people = Stream.of(new Sesame("Abby", true));
22: printPage(monsters, people);
23: }
24:
25: private static void printPage(Stream<Sesame> monsters,
26: Stream<Sesame> people) {
27: Page page = Stream.concat(monsters, people)
28: .collect(Collectors.teeing(
29: Collectors.filtering(s -> s.name().startsWith("E"),
30: Collectors.toList()),
31: Collectors.counting(),
32: (l, c) -> new Page(l, c)));
33: System.out.println(page);
34: } }
```

A. Page[list=[Abby], count=1]
B. Page[list=[Abby], count=2]
C. Page[list=[Elmo], count=1]
D. Page[list=[Elmo], count=2]
E. The code does not compile due to Stream.concat().
F. The code does not compile due to Collectors.teeing().
G. The code does not compile for another reason.

**My Answer: F**
**Correct Answer: D**

**Line 29 filters by names starting with E, that rules out options A and B. Finally, line 31 counts the entire list, which is of size 2, giving us option D as the answer.**

---

19. What is the simplest way of rewriting this code?
```java
List<Integer> x = IntStream.range(1, 6)
.mapToObj(i -> i)
.collect(Collectors.toList());
x.forEach(System.out::println);
```

A.
``IntStream.range(1, 6);``
B.
`IntStream.range(1, 6)`
`.forEach(System.out::println);`
C.
`IntStream.range(1, 6)`
`.mapToObj(i -> i)`
`.forEach(System.out::println);`
D. None of the above is equivalent.
E. The provided code does not compile.

**My Answer: B**
**Correct Answer: B**

Both lists and streams have forEach() methods. There is no reason to collect into a list just to loop through it. 

---

20. Which of the following throw an exception when an Optional is empty? (Choose all that apply.)

A. opt.orElse("");
B. opt.orElseGet(() -> "");
C. opt.orElseThrow();
D. opt.orElseThrow(() -> throw new Exception());
E. opt.orElseThrow(RuntimeException::new);
F. opt.get();
G. opt.get("");

**My Answer: D,E,G**
**Correct Answer: C,E,F**

Options A and B compile and return an empty string without throwing an exception, using a String and Supplier parameter, respectively. Option G does not compile as the get() method does not take a parameter. Options C and F throw a NoSuchElementException. Option E throws a RuntimeException. Option D looks correct but will compile only if the throw is removed. Remember, the orElseThrow() should get a lambda expression or method reference that returns an exception, not one that throws an exception.

---

21. What is the output of the following?

```JAVA
var spliterator = Stream.generate(() -> "x").spliterator();

spliterator.tryAdvance(System.out::print);
var split = spliterator.trySplit();
split.tryAdvance(System.out::print);
```

A. x
B. xx
C. A long list of x’s
D. There is no output.
E. The code does not compile.
F. The code compiles but does not terminate at runtime.

**My Answer: F**
**Correct Answer: B**

**The spliterator() method is a terminal operation since it returns a Spliterator rather than a Stream. The tryAdvance() method gets the first element and prints a single x. ==The trySplit() method takes a large number of elements from the stream. Since this is an infinite stream, it doesn’t attempt to take half==. Then tryAdvance() is called on the new split variable, and another x is printed. Since there are two values printed, option B is correct.**

---

# Chapter 11 - Exceptions and Localization #Chapter

## Understanding Exceptions

A program can fail for just about any reason.

-  The code tries to connect to a website, but the Internet connection is down.
-  You made a coding mistake and tried to access an invalid index in an array.
-  One method calls another with a value that the method doesn’t support.

### The Role of Exceptions

An exception is Java’s way of saying, “I give up. I don’t know what to do right now. You deal with it.” When you write a method, you can either deal with the exception or make it the calling code’s problem.
**==These are the two approaches Java uses when dealing with exceptions. A method can handle the exception case itself or make it the caller’s responsibility.==**

### Understanding Exception Types

An exception is an event that alters program flow. Java has a ``Throwable`` class for all objects that represent these events.

![[Pasted image 20240427221324.png]]

#### Checked Exceptions

**==A checked exception is an exception that must be declared or handled by the application code where it is thrown. In Java, checked exceptions all inherit ``Exception`` but not ``RuntimeException``.==**

Java has a rule called the handle or declare rule. The handle or declare rule means that all checked exceptions that could be thrown within a method are either wrapped in compatible ``try`` and ``catch`` blocks or declared in the method signature. Because checked exceptions tend to be anticipated, Java enforces the rule that the programmer must do something to show that the exception was thought about

```java
void fall(int distance) throws IOException {
	if(distance > 10) {
		throw new IOException();
	}
}
```

**==The ``throw`` keyword tells Java that you want to throw an ``Exception``, while the ``throws`` keyword simply declares that the method might throw an ``Exception``. It also might not.==**
How do you handle exception ? 

```java
void fall(int distance) {
	try {
		if(distance > 10) {
			throw new IOException();
		}
	} catch (Exception e) {
		e.printStackTrace();
	}
}
```

#### Unchecked Exceptions

**==An unchecked exception is any exception that does not need to be declared or handled by the application code where it is thrown. Unchecked exceptions are often referred to as runtime exceptions==**

A runtime exception is defined as the ``RuntimeException`` class and its subclasses. Runtime exceptions tend to be unexpected but not necessarily fatal. An unchecked exception can occur on nearly any line of code, as it is not required to be handled or declared. For example, a ``NullPointerException`` can be thrown in the body of the following method if the input reference is ``null``:

```java
void fall(String input) {
	System.out.println(input.toLowerCase());
}
```

The code will compile if you declare an unchecked exception. However, it is redundant.

#### Error and Throwable

``Error`` means something went so horribly wrong that your program should not attempt to recover from it.
**==For the exam, the only thing you need to know about ``Throwable`` is that it’s the parent class of all exceptions, including the ``Error`` class.==**

![[Pasted image 20240427222354.png]]

### Throwing an Exception

Any Java code can throw an exception; this includes code you write. You might encounter an exception that was made up for the exam. This is fine. On the exam, you will see two types of code that result in an exception. 
- The first is code that’s wrong.

```java
String[] animals = new String[0];
System.out.println(animals[0]); // ArrayIndexOutOfBoundsException
```

This code throws an ``ArrayIndexOutOfBoundsException`` since the array has no elements. That means **==questions about exceptions can be hidden in questions that appear to be about something else.==**

- The second way for code to result in an exception is to explicitly request Java to throw one.

```java
throw new Exception();
throw new Exception("Ow! I fell.");
throw new RuntimeException();
throw new RuntimeException("Ow! I fell.");
```

The ``throw`` keyword tells Java that you want some other part of the code to deal with the exception.

---
**``throw`` vs. ``throws``**

**Anytime you see ``throw`` or ``throws`` on the exam, make sure the correct one is being used.** 
- ==**The ``throw`` keyword is used as a statement inside a code block to ``throw`` a new exception or rethrow an existing exception,**==  
- ==**the ``throws`` keyword is used only at the end of a method declaration to indicate what exceptions it supports.**==

---

Additionally, you should know that **==an ``Exception`` is an ``Object``. This means you can store it in an object reference, and this is legal:==**

```java
var e = new RuntimeException();
throw e;
```

The exam might also try to trick you !!

```java
throw RuntimeException(); // DOES NOT COMPILE
```

The exception is never instantiated with the ``new`` keyword.

```java
3: try {
	4: throw new RuntimeException();
	5: throw new ArrayIndexOutOfBoundsException(); // DOES NOT COMPILE
6: } catch (Exception e) {}
```

Since line 4 throws an exception, line 5 can never be reached during runtime. The compiler recognizes this and reports an unreachable code error.

### Calling Methods That Throw Exceptions

When you’re calling a method that throws an exception, the rules are the same as within a method

```java
class NoMoreCarrotsException extends Exception {}
public class Bunny {
	public static void main(String[] args) {
		eatCarrot(); // DOES NOT COMPILE
	}
	private static void eatCarrot() throws NoMoreCarrotsException {}
}
```

The problem is that ``NoMoreCarrotsException`` is a checked exception. **==Checked exceptions must be handled or declared.==**

```java
public static void main(String[] args) throws NoMoreCarrotsException {
	eatCarrot();
}

public static void main(String[] args) {
	try {
		eatCarrot();
	} catch (NoMoreCarrotsException e) {
		System.out.print("sad rabbit");
	}
}
```

noticed that ``eatCarrot()`` didn’t throw an exception; it just declared that it could. This is enough for the compiler to require the caller to handle or declare the exception. The compiler is still on the lookout for unreachable code. Declaring an unused exception isn’t considered unreachable code. It gives the method the option to change the implementation to throw that exception in the future.

```java
public void bad() {
	try {
		eatCarrot();
	} catch (NoMoreCarrotsException e) { // DOES NOT COMPILE
		System.out.print("sad rabbit");
	}
}
private void eatCarrot() {}
```

Java knows that ``eatCarrot()`` can’t ``throw`` a checked exception—which means there’s no way for the catch block in ``bad()`` to be reached.

---
**==When you see a checked exception declared inside a ``catch`` block on the exam, make sure the code in the associated ``try`` block is capable of throwing the exception or a subclass of the exception==. If not, the code is unreachable and does not compile. Remember that this rule does not extend to unchecked exceptions or exceptions declared in a method signature.**

---

### Overriding Methods with Exceptions

**==An overridden method may not declare any new or broader checked exceptions than the method it inherits.==**

```java
class CanNotHopException extends Exception {}

class Hopper {
	public void hop() {}
}

class Bunny extends Hopper {
	public void hop() throws CanNotHopException {} // DOES NOT COMPILE
}
```

Java knows ``hop()`` isn’t allowed to throw any checked exceptions because the ``hop()`` method in the superclass ``Hopper`` doesn’t declare any. **==An overridden method in a subclass is allowed to declare fewer exceptions than the superclass or interface. This is legal because callers are already handling them.==**

```java
class Hopper {
	public void hop() throws CanNotHopException {}
}
class Bunny extends Hopper {
	public void hop() {} // This is fine
}
```

**==An overridden method not declaring one of the exceptions thrown by the parent method is similar to the method declaring that it throws an exception it never actually throws. This is perfectly legal.==** Similarly, a class is allowed to declare a subclass of an exception type. The idea is the same. The superclass or interface has already taken care of a broader type.
### Printing an Exception

There are three ways to print an exception.

- ==**let Java print it out,**== 
- ==**print just the message,**== 
- ==**print where the stack trace comes from==**

```java
5: public static void main(String[] args) {
	6: try {
		7: hop();
	8: } catch (Exception e) {
		9: System.out.println(e + "\n");
		10: System.out.println(e.getMessage()+ "\n");
		11: e.printStackTrace();
	12: }
13: }
14: private static void hop() {
		15: throw new RuntimeException("cannot hop");
16: }
```

```text
java.lang.RuntimeException: cannot hop
cannot hop
java.lang.RuntimeException: cannot hop
at Handling.hop(Handling.java:15)
at Handling.main(Handling.java:7)
```

The stack trace is usually the most helpful because it shows the hierarchy of method calls that were made to reach the line that threw the exception

## Recognizing Exception Classes

### ``RuntimeException`` Classes

**==``RuntimeException`` and its subclasses are unchecked exceptions that don’t have to be handled or declared. They can be ``thrown`` by the programmer or the JVM.==**

![[Pasted image 20240427224648.png]]

#### ``ArithmeticException``

Trying to divide an ``int`` by zero gives an undefined result. When this occurs, the JVM will throw an ``ArithmeticException``:

```java
int answer = 11 / 0;
```

```text
Exception in thread "main" java.lang.ArithmeticException: / by zero
```

#### ``ArrayIndexOutOfBoundsException``

array indexes start with 0 and go up to 1 less than the length of the array—which means this code will throw an ``ArrayIndexOutOfBoundsException``:

```java
int[] countsOfMoose = new int[3];
System.out.println(countsOfMoose[-1]);
```
```text
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException:
Index -1
out of bounds for length 3
```

#### ``ClassCastException``

Java tries to protect you from impossible casts.

```java
String type = "moose";
Integer number = (Integer) type; // DOES NOT COMPILE
```

More complicated code thwarts Java’s attempts to protect you

```java
String type = "moose";
Object obj = type;
Integer number = (Integer) obj; // ClassCastException
```

The compiler sees a cast from ``Object`` to ``Integer``. This could be okay. The compiler doesn’t realize there’s a ``String`` in that ``Object``.

```text
Exception in thread "main" java.lang.ClassCastException:
java.base/java.lang.String
cannot be cast to java.lang.base/java.lang.Integer
```

#### ``NullPointerException``

Instance variables and methods must be called on a non-null reference. If the reference is ``null``, the JVM will throw a ``NullPointerException``.

```java
1: public class Frog {
	2: public void hop(String name, Integer jump) {
		3: System.out.print(name.toLowerCase() + " " + jump.intValue());
	4: }
	5:
	6: public static void main(String[] args) {
		7: new Frog().hop(null, 1);
	8: } 
}
```

```text
Exception in thread "main" java.lang.NullPointerException: Cannot invoke
"String.toLowerCase()" because "<parameter1>" is null
```

**==The JVM now tells you the object reference that triggered the ``NullPointerException``! This new feature is called *Helpful ``NullPointerExceptions``*.==**

#### ``IllegalArgumentException``

``IllegalArgumentException`` is a way for your program to protect itself.

```java
public void setNumberEggs(int numberEggs) {
	if (numberEggs < 0)
		throw new IllegalArgumentException("# eggs must not be negative");
	this.numberEggs = numberEggs;
}
```
```text
Exception in thread "main"
java.lang.IllegalArgumentException: # eggs must not be negative
```

#### ``NumberFormatException``

Java provides methods to convert strings to numbers. When these are passed an invalid value, they throw a ``NumberFormatException``. The idea is similar to ``IllegalArgumentException``. Since this is a common problem, Java gives it a separate class. In fact, **==``NumberFormatException`` is a subclass of ``IllegalArgumentException``.==**

```java
Integer.parseInt("abc");
```
```text
Exception in thread "main"
java.lang.NumberFormatException: For input string: "abc"
```

**==For the exam, you need to know that ``NumberFormatException`` is a subclass of ``IllegalArgumentException``.==**

### Checked Exception Classes

**==Checked exceptions have Exception in their hierarchy but not ``RuntimeException``. They must be handled or declared.==**
 For the exam, you need to know that these are all checked exceptions that must be handled or declared. You also need to know that **==``FileNotFoundException`` and ``NotSerializableException`` are subclasses of ``IOException``.==**

![[Pasted image 20240427232101.png]]

### Error Classes

Errors are unchecked exceptions that extend the ``Error`` class. They are thrown by the JVM and should not be handled or declared

![[Pasted image 20240427232351.png]]
## Handling Exceptions

### Using ``try`` and ``catch`` Statements

Java uses a ``try`` statement to separate the logic that might throw an exception from the logic to handle that exception.

![[Pasted image 20240428114439.png]]

The code in the ``try`` block is run normally. If any of the statements throws an exception that can be caught by the exception type listed in the ``catch`` block, the ``try`` block stops running, and execution goes to the ``catch`` statement. **==If none of the statements in the ``try`` block throws an exception that can be caught, the ``catch`` clause is not run. The curly braces are required for ``try`` and ``catch`` blocks.==**

```JAVA
3: void explore() {
	4: try {
		5: fall();
		6: System.out.println("never get here");
	7: } catch (RuntimeException e) {
		8: getUp();
	9: }
		10: seeAnimals();
11: }
12: void fall() { throw new RuntimeException(); }
```

invalid ``try`` statements that the exam might try to trick you with

```java
try // DOES NOT COMPILE
	fall();
catch (Exception e)
	System.out.println("get up");
```

The problem is that the braces ``{}`` are missing. The ``try`` statements are like methods in that the curly braces are required even if there is only one statement inside the code blocks, while ``if`` statements and loops are special and allow you to omit the curly braces.

```java
try { // DOES NOT COMPILE
	fall();
}
```

This code doesn’t compile because the ``try`` block doesn’t have anything after it. Remember, **==the point of a ``try`` statement is for something to happen if an exception is thrown. Without another clause, the ``try`` statement is lonely==**. There is a special type of ``try`` statement that includes an implicit ``finally`` block

### Chaining ``catch`` Blocks

For the exam, you may be given exception classes and need to understand how they function. Here’s how to tackle them. 
- ==**First, you must be able to recognize if the exception is a checked or an unchecked exception.**== 
- ==**Second, you need to determine whether any of the exceptions are subclasses of the others.==**

```java
class AnimalsOutForAWalk extends RuntimeException {}
class ExhibitClosed extends RuntimeException {}
class ExhibitClosedForLunch extends ExhibitClosed {}
```

```java
public void visitPorcupine() {
	try {
		seeAnimal();
	} catch (AnimalsOutForAWalk e) { // first catch block
		System.out.print("try back later");
	} catch (ExhibitClosed e) { // second catch block
		System.out.print("not today");
	}
}
```

**==A rule exists for the order of the ``catch`` blocks. Java looks at them in the order they appear. If it is impossible for one of the ``catch`` blocks to be executed, a compiler error about unreachable code occurs.==**

```java
public void visitMonkeys() {
	try {
		seeAnimal();
	} catch (ExhibitClosedForLunch e) { // Subclass exception
		System.out.print("try back later");
	} catch (ExhibitClosed e) { // Superclass exception
		System.out.print("not today");
	}
}
```

If the more specific ``ExhibitClosedForLunch`` exception is thrown, the first catch block runs. If not, Java checks whether the superclass ``ExhibitClosed`` exception is thrown and catches it.

```java
public void visitMonkeys() {
	try {
		seeAnimal();
	} catch (ExhibitClosed e) {
		System.out.print("not today");
	} catch (ExhibitClosedForLunch e) { // DOES NOT COMPILE
		System.out.print("try back later");
	}
}
```

If the more specific ``ExhibitClosedForLunch`` exception is thrown, the ``catch`` block for ``ExhibitClosed`` runs—which means there is no way for the second ``catch`` block to ever run. Java correctly tells you there is an unreachable ``catch`` block.

```java
public void visitSnakes() {
	try {
	} catch (IllegalArgumentException e) {
	} catch (NumberFormatException e) { // DOES NOT COMPILE
	}
}
```

``NumberFormatException`` is a subclass of ``IllegalArgumentException``? This example is the reason why. Since ``NumberFormatException`` is a subclass, it will always be caught by the first ``catch`` block, making the second ``catch`` block unreachable code that does not compile

**==To review multiple ``catch`` blocks, remember that at most one ``catch`` block will run, and it will be the first ``catch`` block that can handle the exception. Also, remember that an exception defined by the ``catch`` statement is only in scope for that ``catch`` block.==**

```java
public void visitManatees() {
	try {
	} catch (NumberFormatException e1) {
		System.out.println(e1);
	} catch (IllegalArgumentException e2) {
		System.out.println(e1); // DOES NOT COMPILE
	}
}
```

### Applying a Multi-catch Block

```java
public static void main(String args[]) {
	try {
		System.out.println(Integer.parseInt(args[1]));
	} catch (ArrayIndexOutOfBoundsException e) {
		System.out.println("Missing or invalid input");
	} catch (NumberFormatException e) {
		System.out.println("Missing or invalid input");
	}
}
```

A multi-catch block allows multiple exception types to be caught by the same ``catch`` block

```java
public static void main(String[] args) {
	try {
		System.out.println(Integer.parseInt(args[1]));
	} catch (ArrayIndexOutOfBoundsException | NumberFormatException e) {
		System.out.println("Missing or invalid input");
	}
}
```

If you wanted, you could still have a second ``catch`` block for Exception in case you want to handle other types of exceptions differently. 

![[Pasted image 20240428121129.png]]

Notice how there is only one variable name in the ``catch`` clause. Java is saying that the variable named e can be of type ``Exception1`` or ``Exception2``

The exam might try to trick you with invalid syntax. **==Remember that the exceptions can be listed in any order within the catch clause. However, the variable name must appear only once and at the end.==**

```java
catch(Exception1 e | Exception2 e | Exception3 e) // DOES NOT COMPILE
catch(Exception1 e1 | Exception2 e2 | Exception3 e3) // DOES NOT COMPILE
catch(Exception1 | Exception2 | Exception3 e)
```

**==Java intends multi-catch to be used for exceptions that aren’t related, and it prevents you from specifying redundant types in a multi-catch.==**

```java
try {
	throw new IOException();
} catch (FileNotFoundException | IOException p) {} // DOES NOT COMPILE
```
```text
The exception FileNotFoundException is already caught by the alternative
IOException
```

**==The one difference between multi-catch blocks and chaining ``catch`` blocks is that order does not matter for a multi-catch block within a single catch expression.==**
### Adding a ``finally`` Block

The ``try`` statement also lets you run code at the end with a ``finally`` clause, regardless of whether an exception is thrown.

**==There are two paths through code with both a ``catch`` and a ``finally``. If an exception is thrown, the ``finally`` block is run after the ``catch`` block. If no exception is thrown, the ``finally`` block is run after the ``try`` block completes.==**

```java
12: void explore() {
	13: try {
		14: seeAnimals();
		15: fall();
	16: } catch (Exception e) {
		17: getHugFromDaddy();
	18: } finally {
		19: seeMoreAnimals();
	20: }
	21: goHome();
22: }
```

![[Pasted image 20240428121807.png]]

The ``finally`` block is executed, and execution continues after the ``try`` statement. The exam will try to trick you with missing clauses or clauses in the wrong order

```java
25: try { // DOES NOT COMPILE
	26: fall();
27: } finally {
	28: System.out.println("all better");
29: } catch (Exception e) {
	30: System.out.println("get up");
31: }
32:
33: try { // DOES NOT COMPILE
	34: fall();
35: }
36:
37: try {
	38: fall();
39: } finally {
	40: System.out.println("all better");
41: }
```

**==The ``catch`` block is not required if ``finally`` is present.==**

```java
public static void main(String[] unused) {
	StringBuilder sb = new StringBuilder();
try {
	sb.append("t");
} catch (Exception e) {
	sb.append("c");
} finally {
	sb.append("f");
}
sb.append("a");
System.out.print(sb.toString()); // tfa
}
```

The ``try`` block is executed. Since no exception is thrown, Java goes straight to the ``finally`` block. Then the code after the ``try`` statement is run.

There is one additional rule you should know for ``finally`` blocks. **==If a ``try`` statement with a ``finally`` block is entered, then the ``finally`` block will always be executed, regardless of whether the code completes successfully.==**

```java
12: int goHome() {
	13: try {
		14: // Optionally throw an exception here
		15: System.out.print("1");
		16: return -1;
	17: } catch (Exception e) {
		18: System.out.print("2");
		19: return -2;
	20: } finally {
		21: System.out.print("3");
		22: return -3;
	23: }
24: }
```

What is the return value of the ``goHome()`` method? In this case, it’s always -3. Because the ``finally`` block is executed shortly before the method completes, it interrupts the return statement from inside both the ``try`` and ``catch`` blocks.

For the exam, you need to remember that a ``finally`` block will always be executed.

```java
31: } finally {
	32: info.printDetails();
	33: System.out.print("Exiting");
	34: return "zoo";
35: }
```

If info was ``null``, then the ``finally`` block would be executed, but it would stop on line 32 and throw a ``NullPointerException``. Lines 33 and 34 would not be executed.
## Automating Resource Management

Often, your application works with files, databases, and various connection objects. Commonly, these external data sources are referred to as resources. In many cases, you open a connection to the resource, whether it’s over the network or within a file system. You then read/write the data you want. Finally, you close the resource to indicate that you are done with it.
For the exam, a resource is typically a file or database that requires some kind of stream or connection to read or write data.
### Introducing Try-with-Resources

```java
4: public void readFile(String file) {
	5: FileInputStream is = null;
	6: try {
		7: is = new FileInputStream("myfile.txt");
		8: // Read file data
	9: } catch (IOException e) {
		10: e.printStackTrace();
	11: } finally {
		12: if(is != null) {
			13: try {
				14: is.close();
			15: } catch (IOException e2) {
				16: e2.printStackTrace();
			17: }
		18: }
	19: }
20: }
```

Half the lines of code in this method are just closing a resource. And the more resources you have, the longer code like this becomes.

To solve this, Java includes the *try-with- resources* statement to automatically close all resources opened in a try clause. This feature is also known as automatic resource management, because Java automatically takes care of the closing.

```java
4: public void readFile(String file) {
	5: try (FileInputStream is = new FileInputStream("myfile.txt")) {
		6: // Read file data
	7: } catch (IOException e) {
		8: e.printStackTrace();
	9: }
10: }
```

by using a try-with-resources statement, we guarantee that as soon as a connection passes out of scope, Java will attempt to close it within the same method. Behind the scenes, the compiler replaces a try-with-resources block with a ``try`` and ``finally`` block. We refer to this “hidden” ``finally`` block as an implicit ``finally`` block since it is created and used by the compiler automatically.

---

**Unlike garbage collection, resources are not automatically closed when they go out of scope. Therefore, it is recommended that you close resources in the same block of code that opens them. By using a try-with- resources statement to open all your resources, this happens automatically.**

---

### Basics of Try-with- Resources

![[Pasted image 20240428124109.png]]

**==one or more resources can be opened in the ``try`` clause. When multiple resources are opened, they are closed in the reverse of the order in which they were created.==** Also, notice that **==parentheses are used to list those resources, and semicolons are used to separate the declarations.==** This works just like declaring multiple indexes in a for loop. a ``catch`` block is optional with a try-with- resources statement.

```java
4: public void readFile(String file) throws IOException {
	5: try (FileInputStream is = new FileInputStream("myfile.txt")) {
		6: // Read file data
	7: }
8: }
```
==**``try`` statement must have one or more ``catch`` blocks or a ``finally`` block. A try-with- resources statement differs from a ``try`` statement in that neither of these is required, although a developer may add both**==
#### Constructing Try-with- Resources Statements

Only classes that implement the ``AutoCloseable`` interface can be used in a try-with- resources statement.

```java
try (String reptile = "lizard") {}
```
Inheriting ``AutoCloseable`` requires implementing a compatible ``close()`` method.

```java
interface AutoCloseable {
	public void close() throws Exception;
}
```

the implemented version of ``close()`` can choose to throw ``Exception`` or a subclass or not throw any exceptions at all.

```java
public class MyFileClass implements AutoCloseable {
	private final int num;
	public MyFileClass(int num) { this.num = num; }
	@Override public void close() {
		System.out.println("Closing: " + num);
	} 
}
```

#### Declaring Resources

While try-with- resources does support declaring multiple variables, each variable must be declared in a separate statement.

```java
try (MyFileClass is = new MyFileClass(1), // DOES NOT COMPILE
	os = new MyFileClass(2)) {
}
try (MyFileClass ab = new MyFileClass(1), // DOES NOT COMPILE
	MyFileClass cd = new MyFileClass(2)) {
}
```

- The first example does not compile because it is missing the data type, and it uses a comma ``(,)`` instead of a semicolon ``(;)``.
- The second example does not compile because it also uses a comma ``(,)`` instead of a semicolon ``(;)``. **==Each resource must include the data type and be separated by a semicolon ``(;)``.==**

You can declare a resource using ``var`` as the data type in a try-with- resources statement, since resources are local variables.

```java
try (var f = new BufferedInputStream(new FileInputStream("it.txt"))) {
	// Process file
}
```
#### Scope of Try-with-Resources
 
 **==The resources created in the try clause are in scope only within the ``try`` block. This is another way to remember that the implicit ``finally`` runs before any catch/finally blocks that you code yourself.==** The implicit close has run already, and the resource is no longer available.

```java
3: try (Scanner s = new Scanner(System.in)) {
	4: s.nextLine();
5: } catch(Exception e) {
	6: s.nextInt(); // DOES NOT COMPILE
7: } finally {
	8: s.nextInt(); // DOES NOT COMPILE
9: }
```

The problem is that ``Scanner`` has gone out of scope at the end of the ``try`` clause
#### Following Order of Operations

**==When working with try-with-  resources statements, it is important to know that resources are closed in the reverse of the order in which they are created.==**

```java
public static void main(String... xyz) {
	try (MyFileClass bookReader = new MyFileClass(1);
		MyFileClass movieReader = new MyFileClass(2)) {
		System.out.println("Try Block");
	throw new RuntimeException();
	} catch (Exception e) {
		System.out.println("Catch Block");
	} finally {
		System.out.println("Finally Block");
	}
}
```
```text
Try Block
Closing: 2
Closing: 1
Catch Block
Finally Block
```
#### Applying Effectively Final

While resources are often created in the try-with-resources statement, it is possible to declare them ahead of time, provided they are marked ``final`` or effectively final.

```java
11: public static void main(String... xyz) {
	12: final var bookReader = new MyFileClass(4);
	13: MyFileClass movieReader = new MyFileClass(5);
	14: try (bookReader;
	15: var tvReader = new MyFileClass(6);
	16: movieReader) {
		17: System.out.println("Try Block");
	18: } finally {
		19: System.out.println("Finally Block");
	20: }
21: }
```

- Line 12 declares a final variable ``bookReader``, while line 13 declares an effectively final variable ``movieReader``. Both of these resources can be used in a try-with- resources statement. ``movieReader`` is effectively final because it is a local variable that is assigned a value only once.
- Lines 14 and 16 use the new syntax to declare resources in a try-with- resources statement, using just the variable name and separating the resources with a semicolon ``(;)``. Line 15 uses the normal syntax for declaring a new resource within the ``try`` clause.

```text
Try Block
Closing: 5
Closing: 6
Closing: 4
Finally Block
```

**==If you come across a question on the exam that uses a try-with-resources statement with a variable not declared in the try clause, make sure it is effectively final.==**

```java
31: var writer = Files.newBufferedWriter(path);
32: try (writer) { // DOES NOT COMPILE
33: writer.append("Welcome to the zoo!");
34: }
35: writer = null;
```

The ``writer`` variable is reassigned on line 35, resulting in the compiler not considering it effectively final. Since it is not an effectively final variable, it cannot be used in a try-with-resources statement on line 32.
The other place the exam might try to trick you is accessing a resource after it has been closed.

```java
41: var writer = Files.newBufferedWriter(path);
42: writer.append("This write is permitted but a really bad idea!");
43: try (writer) {
	44: writer.append("Welcome to the zoo!");
45: }
46: writer.append("This write will fail!"); // IOException
```

While it is possible to write to the resource before the try-with- resources statement, it is not afterward.
### Understanding Suppressed Exceptions

What happens if the ``close()`` method throws an exception?

```java
public class TurkeyCage implements AutoCloseable {
	public void close() {
		System.out.println("Close gate");
	}
	public static void main(String[] args) {
		try (var t = new TurkeyCage()) {
			System.out.println("Put turkeys in");
		}
	}
}
```

```java
1: public class JammedTurkeyCage implements AutoCloseable {
	2: public void close() throws IllegalStateException {
		3: throw new IllegalStateException("Cage door does not close");
	4: }
	5: public static void main(String[] args) {
		6: try (JammedTurkeyCage t = new JammedTurkeyCage()) {
			7: System.out.println("Put turkeys in");
		8: } catch (IllegalStateException e) {
			9: System.out.println("Caught: " + e.getMessage());
		10: }
	11: }
12: }
```

The ``close()`` method is automatically called by try-with- resources. It throws an exception, which is caught by our catch block and prints the following:

```text
Caught: Cage door does not close
```

What happens if the ``try`` block also throws an exception? **==When multiple exceptions are thrown, all but the first are called suppressed exceptions. The idea is that Java treats the first exception as the primary one and tacks on any that come up while automatically closing.==**

```java
5: public static void main(String[] args) {
	6: try (JammedTurkeyCage t = new JammedTurkeyCage()) {
		7: throw new IllegalStateException("Turkeys ran off");
	8: } catch (IllegalStateException e) {
		9: System.out.println("Caught: " + e.getMessage());
	10: for (Throwable t: e.getSuppressed())
		11: System.out.println("Suppressed: "+t.getMessage());
	12: }
13: }
```

- Line 7 throws the primary exception. At this point, the try clause ends, and Java automatically calls the ``close()`` method.
- Line 3 of ``JammedTurkeyCage`` throws an ``IllegalStateException``, which is added as a suppressed exception.
- Then line 8 catches the primary exception.
- Line 9 prints the message for the primary exception.
- Lines 10 and 11 iterate through any suppressed exceptions and print them. The program prints the following:

```text
Caught: Turkeys ran off
Suppressed: Cage door does not close
```

**==Keep in mind that the ``catch`` block looks for matches on the primary exception.==**

```java
5: public static void main(String[] args) {
	6: try (JammedTurkeyCage t = new JammedTurkeyCage()) {
		7: throw new RuntimeException("Turkeys ran off");
	8: } catch (IllegalStateException e) {
		9: System.out.println("caught: " + e.getMessage());
	10: }
11: }
```

- Line 7 again throws the primary exception. Java calls the ``close()`` method and adds a suppressed exception. 
- Line 8 would catch the ``IllegalStateException``. However, we don’t have one of those. The primary exception is a ``RuntimeException``. Since this does not match the catch clause, the exception is thrown to the caller. Eventually, the ``main()`` method would output something like the following:

```text
Exception in thread "main" java.lang.RuntimeException: Turkeys ran off
at JammedTurkeyCage.main(JammedTurkeyCage.java:7)
Suppressed: java.lang.IllegalStateException:
Cage door does not close
at JammedTurkeyCage.close(JammedTurkeyCage.java:3)
at JammedTurkeyCage.main(JammedTurkeyCage.java:8)
```

---

**If more than two resources throw an exception, the first one to be thrown becomes the primary exception, and the rest are grouped as suppressed exceptions. And since resources are closed in the reverse of the order in which they are declared, the primary exception will be on the last declared resource that throws an exception.**

---

**==Keep in mind that suppressed exceptions apply only to exceptions thrown in the ``try`` clause==**. The following example does not throw a suppressed exception:

```java
5: public static void main(String[] args) {
	6: try (JammedTurkeyCage t = new JammedTurkeyCage()) {
		7: throw new IllegalStateException("Turkeys ran off");
	8: } finally {
		9: throw new RuntimeException("and we couldn't find them");
	10: }
11: }
```

==**exceptions thrown in `finally` block are suppressed if an exception is thrown in `try` block also**.==
## Formatting Values

### Formatting Numbers

the ``NumberFormat`` interface, which has two commonly used methods:

```java
public final String format(double number)
public final String format(long number)
```

Since ``NumberFormat`` is an interface, we need the concrete ``DecimalFormat`` class to use it. It includes a constructor that takes a pattern ``String``:

```java
public DecimalFormat(String pattern)
```

![[Pasted image 20240428140003.png]]

```java
12: double d = 1234.567;
13: NumberFormat f1 = new DecimalFormat("###,###,###.0");
14: System.out.println(f1.format(d)); // 1,234.6
15:
16: NumberFormat f2 = new DecimalFormat("000,000,000.00000");
17: System.out.println(f2.format(d)); // 000,001,234.56700
18:
19: NumberFormat f3 = new DecimalFormat("Your Balance $#,###,###.##");
20: System.out.println(f3.format(d)); // Your Balance $1,234.57
```

- Line 14 displays the digits in the number, rounding to the nearest 10th after the decimal. The extra positions to the left are omitted because we used #.
- Line 17 adds leading and trailing zeros to make the output the desired length.
- Line 20 shows prefixing a non-formatting character along with rounding because fewer digits are printed than available. Notice that the commas are automatically removed if they are used between # symbols.

### Formatting Dates and Times

The date and time classes support many methods to get data out of them.

```java
LocalDate date = LocalDate.of(2022, Month.OCTOBER, 20);
System.out.println(date.getDayOfWeek()); // THURSDAY
System.out.println(date.getMonth()); // OCTOBER
System.out.println(date.getYear()); // 2022
System.out.println(date.getDayOfYear()); // 293
```

Java provides a class called ``DateTimeFormatter`` to display standard formats.

```java
LocalDate date = LocalDate.of(2022, Month.OCTOBER, 20);
LocalTime time = LocalTime.of(11, 12, 34);
LocalDateTime dt = LocalDateTime.of(date, time);

System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE)); // 2022-10-20
System.out.println(time.format(DateTimeFormatter.ISO_LOCAL_TIME)); // 11:12:34
System.out.println(dt.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)); // 2022-10- 20T11: 12:34
```

The ``DateTimeFormatter`` will throw an exception if it encounters an incompatible type.

```java
date.format(DateTimeFormatter.ISO_LOCAL_TIME); // RuntimeException
time.format(DateTimeFormatter.ISO_LOCAL_DATE); // RuntimeException
```

### Customizing the Date/Time Format

``DateTimeFormatter`` supports a custom format using a date format ``String``.

```java
var f = DateTimeFormatter.ofPattern("MMMM dd, yyyy 'at' hh:mm");
System.out.println(dt.format(f)); // October 20, 2022 at 11:12
```

Java assigns each letter or symbol a specific date/time part. **==Case matters!==** sing m instead of M means it will return the minute of the hour, not the month of the year.
 
 The number often dictates the format of the date/time part. Using M by itself outputs the minimum number of characters for a month, such as 1 for January, while using MM always outputs two digits, such as 01. Furthermore, using MMM prints the three-letter abbreviation, such as Jul for July, while MMMM prints the full month name.

![[Pasted image 20240428141810.png]]

```java
var dt = LocalDateTime.of(2022, Month.OCTOBER, 20, 6, 15, 30);

var formatter1 = DateTimeFormatter.ofPattern("MM/dd/yyyy hh:mm:ss");
System.out.println(dt.format(formatter1)); // 10/20/2022 06:15:30

var formatter2 = DateTimeFormatter.ofPattern("MM_yyyy_-dd");
System.out.println(dt.format(formatter2)); // 10_2022_-20

var formatter3 = DateTimeFormatter.ofPattern("h:mm z");
System.out.println(dt.format(formatter3)); // DateTimeException
```

The third example throws an exception at runtime because the underlying ``LocalDateTime`` does not have a time zone specified. If ``ZonedDateTime`` were used instead, the code would complete successfully
trying to format a month for a ``LocalTime`` or an hour for a ``LocalDate`` will result in a runtime exception.

![[Pasted image 20240428141942.png]]

#### Selecting a ``format()`` Method

The date/time classes contain a ``format()`` method that will take a formatter, while the formatter classes contain a ``format()`` method that will take a date/time value.

```java
var dateTime = LocalDateTime.of(2022, Month.OCTOBER, 20, 6, 15, 30);
var formatter = DateTimeFormatter.ofPattern("MM/dd/yyyy hh:mm:ss");

System.out.println(dateTime.format(formatter)); // 10/20/2022 06:15:30
System.out.println(formatter.format(dateTime)); // 10/20/2022 06:15:30
```
#### Adding Custom Text Values

What if you want your format to include some custom text values? If you just type them as part of the format String, the formatter will interpret each character as a date/time symbol.

One way to address this would be to break the formatter into multiple smaller formatters and then concatenate the results.

```java
var dt = LocalDateTime.of(2022, Month.OCTOBER, 20, 6, 15, 30);

var f1 = DateTimeFormatter.ofPattern("MMMM dd, yyyy ");
var f2 = DateTimeFormatter.ofPattern(" hh:mm");
System.out.println(dt.format(f1) + "at" + dt.format(f2));
```

While this works, it could become difficult if a lot of text values and date symbols are intermixed. Luckily, Java includes a much simpler solution. **==You can escape the text by surrounding it with a pair of single quotes ``(')``.==** Escaping text instructs the formatter to ignore the values inside the single quotes and just insert them as part of the final value.

```java
var f = DateTimeFormatter.ofPattern("MMMM dd, yyyy 'at' hh:mm");
System.out.println(dt.format(f)); // October 20, 2022 at 06:15
```

But what if you need to display a single quote in the output, too? Java supports this by putting two single quotes next to each other.

```java
var g1 = DateTimeFormatter.ofPattern("MMMM dd', Party''s at' hh:mm");
System.out.println(dt.format(g1)); // October 20, Party's at 06:15

var g2 = DateTimeFormatter.ofPattern("'System format, hh:mm: 'hh:mm");
System.out.println(dt.format(g2)); // System format, hh:mm: 06:15

var g3 = DateTimeFormatter.ofPattern("'NEW! 'yyyy', yay!'");
System.out.println(dt.format(g3)); // NEW! 2022, yay!
```

If you don’t escape the text values with single quotes, an exception will be thrown at runtime if the text cannot be interpreted as a date/time symbol.

```java
DateTimeFormatter.ofPattern("The time is hh:mm"); // Exception thrown
```

## Supporting Internationalization and Localization

Internationalization is the process of designing your program so it can be adapted. This involves placing strings in a properties file and ensuring that the proper data formatters are used. Localization means supporting multiple locales or geographic regions. You can think of a locale as being like a language and country pairing.

### Picking a Locale

The ``Locale`` class is in the ``java.util`` package. The first useful ``Locale`` to find is the user’s current locale.

```java
Locale locale = Locale.getDefault();
System.out.println(locale); // en_US.
```

This default output tells us that our computers are using English and are sitting in the United States.

Notice the format. **==First comes the lowercase language code. The language is always required. Then comes an underscore followed by the uppercase country code. The country is optional==**

![[Pasted image 20240502145834.png]]

```java
US // Cannot have country without language
enUS // Missing underscore
US_en // The country and language are reversed
EN // Language must be lowercase
```

---

**Pay attention to uppercase/lowercase and the underscore. For example, if you see a locale expressed as es_CO, then you should know that the language is es and the country is CO, even if you didn’t know that they represent Spanish and Colombia, respectively**

---

selects a locale other than the default one. There are three common ways of doing this.

1. The first is to use the built-in constants in the ``Locale`` class, available for some common locales.

```java
System.out.println(Locale.GERMAN); // de
System.out.println(Locale.GERMANY); // de_DE
```

- The first example selects the German language, which is spoken in many countries, including Austria (de_AT) and Liechtenstein (de_LI). 
- The second example selects both German the language and Germany the country.
Only one includes a country code.

2. The second way of selecting a ``Locale`` is to use the constructors to create a new object. You can pass just a language, or both a language and country:

```java
System.out.println(new Locale("fr")); // fr
System.out.println(new Locale("hi", "IN")); // hi_IN
```

The first is the language French, and the second is Hindi in India.
Java will let you create a ``Locale`` with an invalid language or country, such as xx_XX. However, it will not match the Locale that you want to use, and your program will not behave as expected.

3. The builder design pattern lets you set all of the properties that you care about and then build the ``Locale`` at the end. **==This means that you can specify the properties in any order.==**

```java
Locale l1 = new Locale.Builder()
.setLanguage("en")
.setRegion("US")
.build();

Locale l2 = new Locale.Builder()
.setRegion("US")
.setLanguage("en")
.build();

System.out.println(Locale.getDefault()); // en_US
Locale locale = new Locale("fr");
Locale.setDefault(locale);
System.out.println(Locale.getDefault()); // fr
```

### Localizing Numbers

formatting or parsing currency and number values can change depending on your locale. For example, in the United States, the dollar sign is prepended before the value along with a decimal point for values less than one dollar, such as $2.15. In Germany, though, the euro symbol is appended to the value along with a comma for values less than one euro, such as 2,15 €.

Luckily, the ``java.text`` package includes classes to save the day. The first step to formatting or parsing data is the same: obtain an instance of a ``NumberFormat``. Once you have the ``NumberFormat`` instance, you can call ``format()`` to turn a number into a ``String``, or you can use ``parse()`` to turn a ``String`` into a number.

---

**The format classes are not thread-safe. Do not store them in instance variables or static variables.**

---

![[Pasted image 20240502151338.png]]

#### Formatting Numbers

When we format data, we convert it from a structured object or primitive value into a ``String``. The ``NumberFormat.format()`` method formats the given number based on the locale associated with the ``NumberFormat`` object.

```java
var us = NumberFormat.getInstance(Locale.US);
System.out.println(us.format(attendeesPerMonth)); // 266,666

var gr = NumberFormat.getInstance(Locale.GERMANY);
System.out.println(gr.format(attendeesPerMonth)); // 266.666

var ca = NumberFormat.getInstance(Locale.CANADA_FRENCH);
System.out.println(ca.format(attendeesPerMonth)); // 266 666
```

This shows how our U.S., German, and French Canadian guests can all see the same information in the number format they are accustomed to using. In practice, we would just call ``NumberFormat.getInstance()`` and rely on the user’s default locale to format the output.

Formatting currency works the same way.

```java
double price = 48;
var myLocale = NumberFormat.getCurrencyInstance();
System.out.println(myLocale.format(price));
```

---

**In the real world, use int or ``BigDecimal`` for money and not double. Doing math on amounts with double is dangerous because the values are stored as floating-point numbers.**

---

Finally, the exam may have examples that show formatting percentages:

```java
double successRate = 0.802;

var us = NumberFormat.getPercentInstance(Locale.US);
System.out.println(us.format(successRate)); // 80%

var gr = NumberFormat.getPercentInstance(Locale.GERMANY);
System.out.println(gr.format(successRate)); // 80 %
```

#### Parsing Numbers

When we parse data, we convert it from a ``String`` to a structured object or primitive value. The ``NumberFormat.parse()`` method accomplishes this and takes the locale into consideration.

For example, if the locale is the English/United States (en_US) and the number contains commas, the commas are treated as formatting symbols. If the locale relates to a country or language that uses commas as a decimal separator, the comma is treated as a decimal point.

```java
String s = "40.45";

var en = NumberFormat.getInstance(Locale.US);
System.out.println(en.parse(s)); // 40.45

var fr = NumberFormat.getInstance(Locale.FRANCE);
System.out.println(fr.parse(s)); // 40
```

**==The lesson is to make sure that you parse using the right locale!==**

The ``parse()`` method is also used for parsing currency.

```java
String income = "$92,807.99";
var cf = NumberFormat.getCurrencyInstance();
double value = (Double) cf.parse(income);
System.out.println(value); // 92807.99
```

The currency string "$92,807.99" contains a dollar sign and a comma. The ``parse`` method strips out the characters and converts the value to a number. The return value of parse is a ``Number`` object. ``Number`` is the parent class of all the ``java.lang`` wrapper classes, so the return value can be cast to its appropriate data type. The ``Number`` is cast to a ``Double`` and then automatically unboxed into a double.

#### Formatting with ``CompactNumberFormat``

``CompactNumberFormat`` is similar to ``DecimalFormat``, but it is designed to be used in places where print space may be limited. It is opinionated in the sense that it picks a format for you, and locale-specific in that output can change depending on your location.

```java
var formatters = Stream.of(
	NumberFormat.getCompactNumberInstance(), // 7M
	NumberFormat.getCompactNumberInstance(Locale.getDefault(), Style.SHORT), // 7M
	NumberFormat.getCompactNumberInstance(Locale.getDefault(), Style.LONG), // 7 million
	
	NumberFormat.getCompactNumberInstance(Locale.GERMAN, Style.SHORT), // 7 Mio.
	NumberFormat.getCompactNumberInstance(Locale.GERMAN, Style.LONG), // 7 Millionen
	NumberFormat.getNumberInstance()); // 7,123,456
formatters.map(s -> s.format(7_123_456)).forEach(System.out::println);
```

Notice that the first two lines are the same. **==If you don’t specify a style, ``SHORT`` is used by default==**. Next, notice that the values except the last one (which doesn’t use a compact number formatter) are truncated. There’s a reason it’s called a compact number formatter!

The following summarizes the rules for ``CompactNumberFormat``:

-  ==**First it determines the highest range for the number, such as thousand (K), million (M), billion (B), or trillion (T).**==
-  ==**It then returns up to the first three digits of that range, rounding the last digit as needed.**==
-  ==**Finally, it prints an identifier. If ``SHORT`` is used, a symbol is returned. If ``LONG`` is used, a space followed by a word is returned.==**

### Localizing Dates

![[Pasted image 20240502153410.png]]

Each method in the table takes a ``FormatStyle`` parameter (or two) with possible values ``SHORT``, ``MEDIUM``, ``LONG``, and ``FULL``. What if you need a formatter for a specific locale? Easy enough—just append ``withLocale(locale)`` to the method call.

```JAVA
public static void print(DateTimeFormatter dtf,
	LocalDateTime dateTime, Locale locale) {
	System.out.println(dtf.format(dateTime) + " -- - " + dtf.withLocale(locale).format(dateTime));
}

public static void main(String[] args) {
	Locale.setDefault(new Locale("en", "US"));
	var italy = new Locale("it", "IT");
	var dt = LocalDateTime.of(2022, Month.OCTOBER, 20, 15, 12, 34);
	// 10/20/22 --- 20/10/22
	print(DateTimeFormatter.ofLocalizedDate(SHORT),dt,italy);
	// 3:12 PM --- 15:12
	print(DateTimeFormatter.ofLocalizedTime(SHORT),dt,italy);
	// 10/20/22, 3:12 PM --- 20/10/22, 15:12
	print(DateTimeFormatter.ofLocalizedDateTime(SHORT,SHORT),dt,italy);
}
```

### Specifying a Locale Category

When you call ``Locale.setDefault()`` with a locale, several display and formatting options are internally selected. If you require finer-grained control of the default locale, Java subdivides the underlying formatting options into distinct categories with the ``Locale.Category`` enum.

The ``Locale.Category`` enum is a nested element in Locale that supports distinct locales for displaying and formatting data.

![[Pasted image 20240502154257.png]]

```java
10: public static void printCurrency(Locale locale, double money) {
11: System.out.println(
12: NumberFormat.getCurrencyInstance().format(money)
13: + ", " + locale.getDisplayLanguage());
14: }

15: public static void main(String[] args) {
	16: var spain = new Locale("es", "ES");
	17: var money = 1.23;
	18:
	19: // Print with default locale
	20: Locale.setDefault(new Locale("en", "US"));
	21: printCurrency(spain, money); // $1.23, Spanish
	22:
	23: // Print with selected locale display
	24: Locale.setDefault(Category.DISPLAY, spain);
	25: printCurrency(spain, money); // $1.23, español
	26:
	27: // Print with selected locale format
	28: Locale.setDefault(Category.FORMAT, spain);
	29: printCurrency(spain, money); // 1,23 €, español
30: }
```

The code prints the same data three times. First it prints the language of the spain and money variables using the locale en_US. Then it prints it using the DISPLAY category of es_ES, while the ``FORMAT`` category remains en_US. Finally, it prints the data using both categories set to es_ES.

**==For the exam, You just need to know that you can set parts of the locale independently. You should also know that calling ``Locale.setDefault(us)`` after the previous code snippet will change both locale categories to en_US.==**

## Loading Properties with Resource Bundles

A resource bundle contains the locale-specific objects to be used by a program. It is like a map with keys and values. The resource bundle is commonly stored in a properties file. A properties file is a text file in a specific format with key/value pairs.

```java
Locale us = new Locale("en", "US");
Locale france = new Locale("fr", "FR");
Locale englishCanada = new Locale("en", "CA");
Locale frenchCanada = new Locale("fr", "CA");
```

properties files. It is conceptually similar to a ``Map<String,String>``, with each line representing a different key/value. The key and value are separated by an equal sign ``(=)`` or colon ``(:)``.
### Creating a Resource Bundle

**==If we don’t have a country-specific resource bundle, Java will use a language-specific one.==**

```java
Zoo_en.properties
hello=Hello
open=The zoo is open

Zoo_fr.properties
hello=Bonjour
open=Le zoo est ouvert
```

The filenames match the name of our resource bundle, Zoo. They are then followed by an underscore ``(_)``, target locale, and ``.properties`` file extension.

```java
10: public static void printWelcomeMessage(Locale locale) {
	11: var rb = ResourceBundle.getBundle("Zoo", locale);
	12: System.out.println(rb.getString("hello")
	13: + ", " + rb.getString("open"));
14: }
15: public static void main(String[] args) {
	16: var us = new Locale("en", "US");
	17: var france = new Locale("fr", "FR");
	18: printWelcomeMessage(us); // Hello, The zoo is open
	19: printWelcomeMessage(france); // Bonjour, Le zoo est ouvert
20: }
```

Since a resource bundle contains key/value pairs, you can even loop through them to list all of the pairs. The ``ResourceBundle`` class provides a ``keySet()`` method to get a set of all keys.

```java
var us = new Locale("en", "US");
ResourceBundle rb = ResourceBundle.getBundle("Zoo", us);
rb.keySet().stream()
	.map(k ->k + ": " + rb.getString(k))
	.forEach(System.out::println);
```

### Picking a Resource Bundle

There are two methods for obtaining a resource bundle that you should be familiar with for the exam.

```java
ResourceBundle.getBundle("name");
ResourceBundle.getBundle("name", locale);
```

 The first uses the default locale. Either the exam tells you what to assume as the default locale, or it uses the second approach.

Java handles the logic of picking the best available resource bundle for a given key. **==It tries to find the most specific value.==**

![[Pasted image 20240503201144.png]]

1. ==**Look for the resource bundle for the requested locale, followed by the one for the default locale.**==
2. ==**For each locale, check the language/country, followed by just the language.**==
3. ==**Use the default resource bundle if no matching locale can be found.==**

---

**When Java is searching for a matching resource bundle, it will first check for a resource bundle file with the matching class name.**

---

What is the maximum number of files that Java would need to consider in order to find the appropriate resource bundle with the following code?

```java
Locale.setDefault(new Locale("hi"));
ResourceBundle rb = ResourceBundle.getBundle("Zoo", new Locale("en"));
```

1. `Zoo_en.properties`
2. `Zoo_hi.properties`
3. `Zoo.properties`

The requested locale is en, so we start with that. Since the en locale does not contain a country, we move on to the default locale, hi. Again, there’s no country, so we end with the default bundle.

### Selecting Resource Bundle Values

**==Java isn’t required to get all of the keys from the same resource bundle. It can get them from any parent of the matching resource bundle.==**

![[Pasted image 20240503201719.png]]

Once a resource bundle has been selected, only properties along a single hierarchy will be used.
Contrast this behavior with Table 11.11, in which the default en_US resource bundle is used if no other resource bundles are available. What does this mean, exactly? Assume the requested locale is fr_FR and the default is en_US. The JVM will provide data from en_US only if there is no matching fr_FR or fr resource bundle. If it finds a fr_FR or fr resource bundle, then only those bundles, along with the default bundle, will be used.

```java
Zoo.properties
name=Vancouver Zoo

Zoo_en.properties
hello=Hello
open=is open

Zoo_en_US.properties
name=The Zoo

Zoo_en_CA.properties
visitors=Canada visitors
```

```java
11: Locale.setDefault(new Locale("en", "US"));
12: Locale locale = new Locale("en", "CA");
13: ResourceBundle rb = ResourceBundle.getBundle("Zoo", locale);
14: System.out.print(rb.getString("hello"));
15: System.out.print(". ");
16: System.out.print(rb.getString("name"));
17: System.out.print(" ");
18: System.out.print(rb.getString("open"));
19: System.out.print(" ");
20: System.out.print(rb.getString("visitors"));
```
```text
Hello. Vancouver Zoo is open Canada visitors
```

- The default locale is en_US, and the requested locale is ``en_CA``.
- First, Java goes through the available resource bundles to find a match. It finds one right away with ``Zoo_en_CA.properties``. This means the default locale of en_US is irrelevant.
- Line 14 doesn’t find a match for the key hello in ``Zoo_en_CA.properties``, so it goes up the hierarchy to ``Zoo_en.properties``.
- Line 16 doesn’t find a match for name in either of the first two properties files, so it has to go all the way to the top of the hierarchy to ``Zoo.properties``.
- Line 18 has the same experience as line 14, using ``Zoo_en.properties``.
- Finally, line 20 has an easier job of it and finds a matching key in ``Zoo_en_CA.properties``.

Even when the property wasn’t found in ``en_CA`` or ``en`` resource bundles, the program preferred using ``Zoo.properties`` (the default resource bundle) rather than ``Zoo_en_US.properties`` (the default locale).
What if a property is not found in any resource bundle? Then an exception is thrown.

### Formatting Messages

The convention is to use a number inside braces such as {0}, {1}, etc. The number indicates the order in which the parameters will be passed. Although resource bundles don’t support this directly, the ``MessageFormat`` class does.

```java
helloByName=Hello, {0} and {1}
```

The second parameter to format() is a vararg, allowing you to specify any number of input values.

```java
String format = rb.getString("helloByName");
System.out.print(MessageFormat.format(format, "Tammy", "Henry")); // Hello, Tammy and Henry
```

### Using the Properties Class

```java
import java.util.Properties;
public class ZooOptions {
	public static void main(String[] args) {
		var props = new Properties();
		props.setProperty("name", "Our zoo");
		props.setProperty("open", "10am");
	}
}
```

The ``Properties`` class is commonly used in handling values that may not exist.

```java
System.out.println(props.getProperty("camel")); // null
System.out.println(props.getProperty("camel", "Bob")); // Bob
```

If a key were passed that actually existed, both statements would print it. This is commonly referred to as providing a default, or a backup value, for a missing key.

The ``Properties`` class also includes a get() method, but only ``getProperty()`` allows for a default value.

```java
props.get("open"); // 10am
props.get("open", "The zoo will be open soon"); // DOES NOT COMPILE
```

## Summary #OCP_Summary

**==Exceptions can be divided into two categories: checked and unchecked. In Java, checked exceptions inherit ``Exception`` but not ``RuntimeException`` and must be handled or declared. Unchecked exceptions inherit ``RuntimeException`` or ``Error`` and do not need to be handled or declared. It is considered a poor practice to catch an ``Error``.**==

==**can create your own checked or unchecked exceptions by extending ``Exception`` or ``RuntimeException``, respectively. You can also define custom constructors and messages for your exceptions, which will show up in stack traces.**==

==**Automatic resource management can be enabled by using a try-with-resources statement to ensure that the resources are properly closed. Resources are closed at the conclusion of the ``try`` block, in the reverse of the order in which they are declared. A suppressed exception occurs when more than one exception is thrown, often as part of a ``finally`` block or try-with-resources ``close()`` operation.**==

==**Java includes a number of built-in classes to format numbers and dates. We reviewed how to create custom formatters for each. You should be able to read these custom formats when you encounter them on the exam.**==

==**Localization involves creating programs that adapt to change. You can create a ``Locale`` class with a required lowercase language code and optional uppercase country code. For example, ``en`` and ``en_US`` are locales for English and U.S. English, respectively. You need to know how to format number and date/time values based on locale, including the new ``CompactNumberFormat`` class.**==

==**A ``ResourceBundle`` allows specifying key/value pairs in a properties file. Java goes through candidate resource bundles from the most specific to the most general to find a match. If no matches are found for the requested locale, Java switches to the default locale and then finally the default resource bundle. Once a matching resource bundle is found, Java looks only in the hierarchy of that resource bundle to select values.==**

## Exam Essentials #Essential

**Understand the various types of exceptions**. All exceptions are subclasses of ``java.lang.Throwable``. Subclasses of ``java.lang.Error`` should never be caught. Only subclasses of j``ava.lang.Exception`` should be handled in application code.

**Differentiate between checked and unchecked exceptions**. Unchecked exceptions do not need to be caught or handled and are subclasses of ``java.lang.RuntimeException`` or ``java.lang.Error``. All other subclasses of ``java.lang.Exception`` are checked exceptions and must be handled or declared.

**Understand the flow of a try statement**. A ``try`` statement must have a ``catch`` or a ``finally`` block. Multiple catch blocks can be chained together, provided no superclass exception type appears in an earlier catch block than its subclass. **==A multi-catch expression may be used to handle multiple exceptions in the same catch block, provided one exception is not a subclass of another==**. The ``finally`` block runs last regardless of whether an exception is thrown.

**Be able to follow the order of a try-with-resources statement.** A try-with-resources statement is a special type of try block in which one or more resources are declared and automatically closed in the reverse of the order in which they are declared. **==It can be used with or without a ``catch`` or ``finally`` block, with the implicit finally block always executed first==**.

**Be able to write methods that declare exceptions**. Understand the difference between the ``throw`` and ``throws`` keywords and how to declare methods with exceptions. Know how to correctly override a method that declares exceptions.

**Identify valid locale strings**. Know that **==the language code is lowercase and mandatory, while the country code is uppercase and optional==**. Be able to select a locale using a built-in constant, constructor, or builder class.

**Format dates, numbers, and messages**. Be able to format dates, numbers, and messages into various ``String`` formats, and know how locale influences these formats. Know how the various number formatters (currency, percent, compact) differ. Be able to write a custom date or number formatter using symbols, including how to escape literal values.

**Determine which resource bundle Java will use to look up a key**. Be able to create resource bundles for a set of locales using properties files. Know the search order that Java uses to select a resource bundle and how the default locale and default resource bundle are considered. Once a resource bundle is found, recognize the hierarchy used to select values.
## Review Questions

1. Which of the following can be inserted on line 8 to make this code compile? (Choose all that apply.)

```java
7: public void whatHappensNext() throws IOException {
	8: // INSERT CODE HERE
9: }
```

A. System.out.println("it's ok");
B. throw new Exception();
C. throw new IllegalArgumentException();
D. throw new java.io.IOException();
E. throw new RuntimeException();
F. None of the above

**My Answer: A,C,D,E**
**Correct Answer: A,C,D,E**

**A method that declares an exception isn’t required to throw one, making option A correct. Unchecked exceptions can be thrown in any method, making options C and E correct. Option D matches the exception type declared, so it’s also correct. Option B is incorrect because a broader exception is not allowed.**

---

2. Which statement about the following class is correct?

```java
1: class Problem extends Exception {
	2: public Problem() {}
3: }
4: class YesProblem extends Problem {}
5: public class MyDatabase {
	6: public static void connectToDatabase() throw Problem {
		7: throws new YesProblem();
	8: }
	9: public static void main(String[] c) throw Exception {
		10: connectToDatabase();
	11: }
12: }
```

A. The code compiles and prints a stack trace for YesProblem at runtime.
B. The code compiles and prints a stack trace for Problem at runtime.
C. The code does not compile because Problem defines a constructor.
D. The code does not compile because YesProblem does not define a constructor.
E. The code does not compile but would if Problem and YesProblem were switched on lines
6 and 7.
F. None of the above

**My Answer: F**
**Correct Answer: F**

**The code does not compile because the throw and throws keywords are incorrectly used on lines 6, 7, and 9.**

---

3. Which of the following are common types to localize? (Choose all that apply.)

A. Dates
B. Lambda expressions
C. Class names
D. Currency
E. Numbers
F. Variable names

**My Answer: A,D,E**
**Correct Answer: A,D,E**

**Localization refers to user-facing elements. Dates, currency, and numbers are commonly used in different formats for different countries,**

---

4. What is the output of the following snippet, assuming a and b are both 0? 

```java
3: try {
	4: System.out.print(a / b);
5: } catch (RuntimeException e) {
	6: System.out.print(-1);
7: } catch (ArithmeticException e) {
	8: System.out.print(0);
9: } finally {
	10: System.out.print("done");
11: }
```

A. -1
B. 0
C. done-1
D. done0
E. The code does not compile.
F. An uncaught exception is thrown.
G. None of the above

**My Answer: F**
**Correct Answer: E**

**The order of catch blocks is important because they’re checked in the order they appear after the try block. Because ArithmeticException is a child class of RuntimeException, the catch block on line 7 is unreachable (if an ArithmeticException is thrown in the try block, it will be caught on line 5). Line 7 generates a compiler error because it is unreachable code, making option E correct.**

---

5. Assuming the current locale uses dollars ($) and the following method is called with a double value of 100_102.2, which of the following values are printed? (Choose all that apply.)

```java
public void print(double t) {
	System.out.print(NumberFormat.getCompactNumberInstance().format(t));
	System.out.print(
		NumberFormat.getCompactNumberInstance(
		Locale.getDefault(), Style.SHORT).format(t));
	System.out.print(NumberFormat.getCurrencyInstance().format(t));
}
```

A. 100
B. $100,000.00
C. 100K
D. 100 thousand
E. 100M
F. $100,102.20
G. None of the above

**My Answer: C**
**Correct Answer: C,F**

**The code compiles and runs without issue. When a CompactNumberFormat instance is requested without a style, it uses the SHORT style by default. This results in both of the first two statements printing 100K, making option C correct. If the LONG style were used, then 100 thousand would be printed. Option F is also correct, as the full value is printed with a currency formatter.**

---

6.  What is the output of the following code?
```java
LocalDate date = LocalDate.parse("2022-04-30", DateTimeFormatter.ISO_LOCAL_DATE_TIME);
System.out.println(date.getYear() + " " + date.getMonth() + " "+ date.getDayOfMonth());
```

A. 2022 APRIL 2
B. 2022 APRIL 30
C. 2022 MAY 2
D. The code does not compile.
E. A runtime exception is thrown.

**My Answer: D**
**Correct Answer: E**

**LocalDate does not have a time element. Therefore, a date/time formatter is not appropriate. The code compiles but throws an exception at runtime, making option E correct.**

---

7. What does the following method print?
```java
11: public void tryAgain(String s) {
	12: try (FileReader r = null, p = new FileReader("")) {
		13: System.out.print("X");
		14: throw new IllegalArgumentException();
	15: } catch (Exception s) {
		16: System.out.print("A");
		17: throw new FileNotFoundException();
	18: } finally {
		19: System.out.print("O");
	20: }
21: }
```

A. XAO
B. XOA
C. One line of this method contains a compiler error.
D. Two lines of this method contain compiler errors.
E. Three or more lines of this method contain compiler errors.
F. The code compiles, but a NullPointerException is thrown at runtime.
G. None of the above

**My Answer: F**
**Correct Answer: D**

**The first compiler error is on line 12 because each resource in a try-with-resources statement must have its own data type and be separated by a semicolon (;). Line 15 does not compile because the variable s is already declared in the method. Line 17 also does not compile. The FileNotFoundException, which inherits from IOException and Exception, is a checked exception, so it must be handled in a try/catch block or declared by the method.**

---

8. Assume that all of the files mentioned in the answer choices exist and define the same keys. Which one will be used to find the key in line 8?

```java
6: Locale.setDefault(new Locale("en", "US"));
7: var b = ResourceBundle.getBundle("Dolphins");
8: System.out.println(b.getString("name"));
```

A. Dolphins.properties
B. Dolphins_US.properties
C. Dolphins_en.properties
D. Whales.properties
E. Whales_en_US.properties
F. The code does not compile.

**My Answer: C**
**Correct Answer: C**

**Java will first look for the most specific matches it can find, starting with Dolphins_en_US.properties. Since that is not an answer choice, it drops the countryand looks for Dolphins_en.properties, making option C correct. Option B is incorrectbecause a country without a language is not a valid locale.**

---

9. For what value of pattern will the following print ``<005.21> <008.49> <1,234.0>``?

```java
String pattern = " ";
var message = DoubleStream.of(5.21, 8.49, 1234)
.mapToObj(v -> new DecimalFormat(pattern).format(v))
.collect(Collectors.joining("> <"));
System.out.println("<"+message+">");
```

A. ##.#
B. 0,000.0#
C. #,###.0
D. #,###,000.0#
E. The code does not compile regardless of what is placed in the blank.
F. None of the above

**My Answer: F**
**Correct Answer: D**

**When working with a custom number formatter, the 0 symbol displays the digit as 0, even if it’s not present, while the # symbol omits the digit from the start or end of the String if it is not present. Based on the requested output, a String that displays at least three digits before the decimal (including a comma) and at least one after the decimal is required. It should display a second digit after the decimal if one is available. For this reason, option D is the correct answer.**

---

10. Which scenario is the best use of an exception?

A. An element is not found when searching a list.
B. An unexpected parameter is passed into a method.
C. The computer caught fire.
D. You want to loop through a list.
E. You don’t know how to code a method.

**My Answer: B**
**Correct Answer: B**

---

11. Which of the following exceptions must be handled or declared in the method in which they are thrown? (Choose all that apply.)

```java
class Apple extends RuntimeException {}
class Orange extends Exception {}
class Banana extends Error {}
class Pear extends Apple {}
class Tomato extends Orange {}
class Peach extends Throwable {}
```

A. Apple
B. Orange
C. Banana
D. Pear
E. Tomato
F. Peach

**My Answer: C**
**Correct Answer: B,E,F**

An exception that must be handled or declared is a checked exception. A checked exception inherits Exception but not RuntimeException. The entire hierarchy counts, so options B and E are both correct. **==Option F is also correct, as a class that inherits Throwable but not RuntimeException or Error is also checked.==**

---

12. Which of the following changes, when made independently, would make this code compile? (Choose all that apply.)

```java
1: import java.io.*;
2: public class StuckTurkeyCage implements AutoCloseable {
	3: public void close() throws IOException {
		4: throw new FileNotFoundException("Cage not closed");
	5: }
6: public static void main(String[] args) {
	7: try (StuckTurkeyCage t = new StuckTurkeyCage()) {
		8: System.out.println("put turkeys in");
	9: }
10: } 
}
```

A. Remove throws IOException from the declaration on line 3.
B. Add throws Exception to the declaration on line 6.
C. Change line 9 to } catch (Exception e) {}.
D. Change line 9 to } finally {}.
E. The code compiles as is.
F. None of the above

**My Answer: E**
**Correct Answer: B,C**

**The code does not compile as is because the exception declared by the close() method must be handled or declared. Option A is incorrect because removing the exception from the declaration causes a compilation error on line 4, as FileNotFoundException is a checked exception that must be handled or declared. Option B is correct because the unhandled exception within the main() method becomes declared. Option C is also correct because the exception becomes handled. Option D is incorrect because the exception remains unhandled.**

---

13. Which of the following are true statements about exception handling in Java? (Choose all that apply.)

A. A traditional try statement without a catch block requires a finally block.
B. A traditional try statement without a finally block requires a catch block.
C. A traditional try statement with only one statement can omit the {}.
D. A try-with-resources statement without a catch block requires a finally block.
E. A try-with-resources statement without a finally block requires a catch block.
F. A try-with-resources statement with only one statement can omit the {}.

**My Answer: A,B**
**Correct Answer: A,B**

**A try-with-resources statement does not require a catch or finally block. A traditional try statement requires at least one of the two. Neither statement can be written without a body encased in braces, {}. For these reasons, options A and B are correct.**

---

14. Assuming -g:vars is used when the code is compiled to include debug information, what is the output of the following code snippet?

```java
var huey = (String)null;
Integer dewey = null;
Object louie = null;
if(louie == huey.substring(dewey.intValue())) {
	System.out.println("Quack!");
}
```

A. A NullPointerException that does not include any variable names in the stack
trace
B. A NullPointerException naming huey in the stack trace
C. A NullPointerException naming dewey in the stack trace
D. A NullPointerException naming louie in the stack trace
E. A NullPointerException naming huey and louie in the stack trace
F. A NullPointerException naming huey and dewey in the stack trace
G. None of the above

**My Answer: F**
**Correct Answer: C**

**Starting with Java 15, NullPointerException stack traces include the name of the variable that is null by default, making option A incorrect. The first NullPointerException encountered at runtime is when dewey.intValue() is called, making option C correct. Options E and F are incorrect as only one NullPointerException exception can be thrown at a time.**

---

15. Which of the following, when inserted independently in the blank, use locale parameters that are properly formatted? (Choose all that apply.)

```java
import java.util.Locale;
public class ReadMap implements AutoCloseable {
	private Locale locale;
	private boolean closed = false;
	@Override public void close() {
		System.out.println("Folding map");
		locale = null;
		closed = true;
	}
	public void open() {
		this.locale = ;
	}
	public void use() {
		// Implementation omitted
	}
}
```

A. new Locale("xM")
B. new Locale("MQ", "ks")
C. new Locale("qw")
D. new Locale("wp", "VW")
E. Locale.create("zp")
F. new Locale.Builder().setLanguage("yw").setRegion("PM")
G. The code does not compile regardless of what is placed in the blank.

**My Answer: C,D,F**
**Correct Answer: C,D**

**The code compiles with the appropriate input, so option G is incorrect. A locale consists of a required lowercase language code and optional uppercase country code. In the Locale() constructor, the language code is provided first. For these reasons, options C and D are correct. Option E is incorrect because a Locale is created using a constructor or Locale.Builder class. Option F is really close but is missing build() at the end.Without that, option F does not compile.**

---

16. Which of the following can be inserted into the blank to allow the code to compile and run
without throwing an exception? (Choose all that apply.)

```java
var f = DateTimeFormatter.ofPattern("hh o'clock");
System.out.println(f.format( ??.now()));
```

A. ZonedDateTime
B. LocalDate
C. LocalDateTime
D. LocalTime
E. The code does not compile regardless of what is placed in the blank.
F. None of the above

**My Answer: F**
**Correct Answer: F**

**The code compiles, but the first line produces a runtime exception regardless of what is inserted into the blank, making option F correct. When creating a custom formatter, any nonsymbol code must be properly escaped using pairs of single quotes ('). In this case, it fails because o is not a symbol. Even if you didn’t know o wasn’t a symbol, the code contains an unmatched single quote. If the properly escaped value of "hh' o''clock'" were used,  then the correct answers would be ZonedDateTime, LocalDateTime, and LocalTime. Option B would not be correct because LocalDate values do not have an hour part.**

---

17. Which of the following statements about resource bundles are correct? (Choose all that apply.)

A. All keys must be in the same resource bundle to be used.
B. A resource bundle is loaded by calling the new ResourceBundle() constructor.
C. Resource bundle values are always read using the Properties class.
D. Changing the default locale lasts for only a single run of the program.
E. If a resource bundle for a specific locale is requested, then the resource bundle for the
default locale will not be used.
F. It is possible to use a resource bundle for a locale without specifying a default locale.

**My Answer: D,F**
**Correct Answer: D,F**

**Option A is incorrect because Java will look at parent bundles if a key is not found in a specified resource bundle. Option B is incorrect because resource bundles are loaded from static factory methods. Option C is incorrect, as resource bundle values are read from the ResourceBundle object directly. Option D is correct because the locale is changed only in memory. Option E is incorrect, as the resource bundle for the default locale may be used if there is no resource bundle for the specified locale (or its locale without a country code). Finally, option F is correct. The JVM will set a default locale automatically.**

---

18. What is the output of the following code?
```java
import java.io.*;

public class FamilyCar {
    static class Door implements AutoCloseable {
        public void close() {
            System.out.print("D");
        }
    }

    static class Window implements Closeable {
        public void close() {
            System.out.print("W");
            throw new RuntimeException();
        }
    }

    public static void main(String[] args) {
        var d = new Door();
        try (d; var w = new Window()) {
            System.out.print("T");
        } catch (Exception e) {
            System.out.print("E");
        } finally {
            System.out.print("F");
        }
    }
}
```

A. TWF
B. TWDF
C. TWDEF
D. TWF followed by an exception
E. TWDF followed by an exception
F. TWEF followed by an exception
G. The code does not compile.

**My Answer: E**
**Correct Answer: C**

**After both resources are declared and created in the try-with- resources statement, T is printed as part of the body. Then the try-with- resources completes and closes the resources in the reverse of the order in which they were declared. After W is printed, an exception is thrown. However, the remaining resource still needs to be closed, so D is printed. Once all the resources are closed, the exception is thrown and swallowed in the catch block, causing E to be printed. Last, the finally block is run, printing F. Therefore, the answer is TWDEF and option C is correct.**

---

19. Suppose that we have the following three properties files and code. Which bundles are used on lines 8 and 9, respectively

```properties
Dolphins.properties
name=The Dolphin
age=0

Dolphins_en.properties
name=Dolly
age=4

Dolphins_fr.properties
name=Dolly
```

```java
5: var fr = new Locale("fr");
6: Locale.setDefault(new Locale("en", "US"));
7: var b = ResourceBundle.getBundle("Dolphins", fr);
8: b.getString("name");
9: b.getString("age");
```

A. Dolphins.properties and Dolphins.properties
B. Dolphins.properties and Dolphins_en.properties
C. Dolphins_en.properties and Dolphins_en.properties
D. Dolphins_fr.properties and Dolphins.properties
E. Dolphins_fr.properties and Dolphins_en.properties
F. The code does not compile.
G. None of the above

**My Answer: E**
**Correct Answer: D**
 
 **Java will use Dolphins_fr.properties as the matching resource bundle on line 7 because it is an exact match on the language of the requested locale. Line 8 finds a matching key in this file. Line 9 does not find a match in that file; therefore, it has to look higher up in the hierarchy. Once a bundle is chosen, only resources in that hierarchy are allowed. It cannot use the default locale anymore, but it can use the default resource bundle specified by Dolphins.properties. For these reasons, option D is correct.**

---

20. What is printed by the following program?
```java
1: public class DriveBus {
	2: public void go() {
		3: System.out.print("A");
	4: try {
		5: stop();
	6: } catch (ArithmeticException e) {
		7: System.out.print("B");
	8: } finally {
		9: System.out.print("C");
	10: }
		11: System.out.print("D");
	12: }
	13: public void stop() {
			14: System.out.print("E");
			15: Object x = null;
			16: x.toString();
			17: System.out.print("F");
	18: }
	19: public static void main(String n[]) {
			20: new DriveBus().go();
	21: } 
}
```

A. AE
B. AEBCD
C. AEC
D. AECD
E. AE followed by a stack trace
F. AEBCD followed by a stack trace
G. AEC followed by a stack trace
H. A stack trace with no other output

**My Answer: G**
**Correct Answer: G**

**The main() method invokes go(), and A is printed on line 3. The stop() method is invoked, and E is printed on line 14. Line 16 throws a NullPointerException, so stop() immediately ends, and line 17 doesn’t execute. The exception isn’t caught in go(), so the go() method ends as well, but not before its finally block executes and C is printed on line 9. Because main() doesn’t catch the exception, the stack trace displays, and no further output occurs. For these reasons, AEC is printed followed by a stack trace for a NullPointerException, making option G correct.**

---

21. Which changes, when made independently, allow the following program to compile? (Choose all that apply.)

```java
1: public class AhChoo {
2: static class SneezeException extends Exception {}
3: static class SniffleException extends SneezeException {}
4: public static void main(String[] args) {
5: try {
6: throw new SneezeException();
7: } catch (SneezeException | SniffleException e) {
8: } finally {}
9: } }
```

A. Add throws SneezeException to the declaration on line 4.
B. Add throws Throwable to the declaration on line 4.
C. Change line 7 to } catch (SneezeException e) {.
D. Change line 7 to } catch (SniffleException e) {.
E. Remove line 7.
F. The code compiles correctly as is.
G. None of the above

**My Answer: C,D**
**Correct Answer: C**

**The code does not compile because the multi-catch block on line 7 cannot catch both a superclass and a related subclass. Options A and B do not address this problem, so they are incorrect. Since the try body throws SneezeException, it can be caught in a catch block, making option C correct. Option D allows the catch block to compile but causes a compiler error on line 6. Both of the custom exceptions are checked and must be handled or declared in the main() method. A SneezeException is not a SniffleException, so the exception is not handled. Likewise, option E leads to an unhandled exception compiler error on line 6.**

---

22. What is the output of the following code?

```java
try {
	LocalDateTime book = LocalDateTime.of(2022, 4, 5, 12, 30, 20);
	System.out.print(book.format(DateTimeFormatter.ofPattern("m")));
	System.out.print(book.format(DateTimeFormatter.ofPattern("z")));
	System.out.print(DateTimeFormatter.ofPattern("y").format(book));
} catch (Throwable e) {}
```

A. 4
B. 30
C. 402
D. 3002
E. 3002022
F. 402022
G. None of the above

**My Answer: G**
**Correct Answer: B**

**For this question, the date used is April 5, 2022 at 12:30:20pm. The code compiles, and either form of the formatter is correct: dateTime.format(formatter) or formatter.format(dateTime). The custom format m returns the minute, so 30 is output first. The next line throws an exception as z relates to time zone, and date/time does not have a zone component. This exception is then swallowed by the try/catch block. Since this is the only value printed, option B is correct. If the code had not thrown an exception, the last line would have printed 2022.**

---

23. Fill in the blank: A class that implements _________________ may be in a try-with- resources statement. (Choose all that apply.)

A. AutoCloseable
B. Resource
C. Exception
D. AutomaticResource
E. Closeable
F. RuntimeException
G. Serializable

**My Answer: A,E**
**Correct Answer: A,E**

**Resources must inherit AutoCloseable to be used in a try-with- resources block. Since Closeable, which is used for I/O classes, extends AutoCloseable, both may be used, making options A and E correct.**

---

24. What is the output of the following program?

```java
public class SnowStorm {
	static class WalkToSchool implements AutoCloseable {
		public void close() {
		throw new RuntimeException("flurry");
		} 
	}
	public static void main(String[] args) {
		WalkToSchool walk1 = new WalkToSchool();
		try (walk1; WalkToSchool walk2 = new WalkToSchool()) {
		throw new RuntimeException("blizzard");
		} catch(Exception e) {
		System.out.println(e.getMessage() + " " + e.getSuppressed().length);
		walk1 = null;
	} 
}
```

A. blizzard 0
B. blizzard 1
C. blizzard 2
D. flurry 0
E. flurry 1
F. flurry 2
G. None of the above

**My Answer: C**
**Correct Answer: G**

**The code does not compile because the resource walk1 is not final or effectively final and cannot be used in the declaration of a try-with- resources statement. For this reason, option G is correct. If the line that set walk1 to null were removed, then the code would compile and print blizzard 2 at runtime, with the exception inside the try block being the primary exception since it is thrown first. Then two suppressed exceptions would be added to it when trying to close the AutoCloseable resources.**

---

25. Assuming U.S. currency is in dollars ($) and German currency is in euros (€), what is the output of the following program?

```java
import java.text.NumberFormat;
import java.util.Locale;
import java.util.Locale.Category;
public record Wallet(double money) {
private String openWallet() {
Locale.setDefault(Category.DISPLAY,
new Locale.Builder().setRegion("us").build());
Locale.setDefault(Category.FORMAT,
new Locale.Builder().setLanguage("en").build());
return NumberFormat.getCurrencyInstance(Locale.GERMANY)
.format(money);
}
public void printBalance() {
System.out.println(openWallet());
}
public static void main(String... unused) {
new Wallet(2.4).printBalance();
} }
```

A. 2,40 €
B. $2.40
C. 2.4
D. The code does not compile.
E. None of the above

**My Answer: A**
**Correct Answer: A**

**The code compiles and prints the value for Germany, 2,40 €, making option A the correct answer. Note that the default locale category is ignored since an explicit currency locale is selected.**

---

26. Which lines can fill in the blank to make the following code compile? (Choose all that apply.)

```java
void rollOut() throws ClassCastException {}
	public void transform(String c) {
	try {
		rollOut();
	} catch (IllegalArgumentException | ?? ) {
	}
}
```

A. IOException a
B. Error b
C. NullPointerException c
D. RuntimeException d
E. NumberFormatException e
F. ClassCastException f
G. None of the above. The code contains a compiler error regardless of what is inserted
into the blank

**My Answer: B,F**
**Correct Answer: B,F**

**The try block is not capable of throwing an IOException, making the catch block unreachable code and option A incorrect. Options B and F are correct, as both are unchecked exceptions that do not extend or inherit from IllegalArgumentException. Remember, it is not a good idea to catch Error in practice, although because it is possible, it may come up on the exam. Option C is incorrect because the variable c is declared already in the method declaration. Option D is incorrect because the IllegalArgumentException inherits from RuntimeException, making the first declaration unnecessary. Similarly, option E is incorrect because NumberFormatException inherits from IllegalArgumentException, making the second declaration unnecessary. Since options B and F are correct, option G is incorrect.**

---

# Chapter 12 - Modules #Chapter 

## Introducing Modules

When you work on real programs, they are much bigger. A real project will consist of hundreds or thousands of classes grouped into packages. These packages are grouped into Java archive (JAR) files. A JAR is a ZIP file with some extra information, and the extension is ``.jar``.

The Java Platform Module System (JPMS) groups code at a higher level. **==The main purpose of a module is to provide groups of related packages that offer developers a particular set of functionality. It’s like a JAR file, except a developer chooses which packages are accessible outside the module==**

The Java Platform Module System includes the following:
- ==**A format for module JAR files**==
- ==**Partitioning of the JDK into modules**==
- ==**Additional command-line options for Java tools==**

### Exploring a Module

==**A module is a group of one or more packages plus a special file called ``module-info. java``. The contents of this file are the module declaration**==

![[Pasted image 20240508192201.png]]

In Figure 12.1, notice that there are arrows between many of the modules. These represent dependencies, where one module relies on code in another.

![[Pasted image 20240508192240.png]]

### Benefits of Modules

Modules look like another layer of things you need to know in order to program. While using modules is optional, it is important to understand the problems they are designed to solve:

- ==**Better access control**: In addition to the levels of access control covered in Chapter 5, “Methods,” you can have packages that are only accessible to other packages in the module.==

- ==**Clearer dependency management**: Since modules specify what they rely on, Java can complain about a missing JAR when starting up the program rather than when it is first accessed at runtime.==

- ==**Custom Java builds**: You can create a Java runtime that has only the parts of the JDK that your program needs rather than the full one at over 150 MB.==

- ==**Improved security**: Since you can omit parts of the JDK from your custom build, you don’t have to worry about vulnerabilities discovered in a part you don’t use.==

- ==**Improved performance**: Another benefit of a smaller Java package is improved startup time and a lower memory requirement.==

- ==**Unique package enforcement**: Since modules specify exposed packages, Java can ensure that each package comes from only one module and avoid confusion about what is being run.==

## Creating and Running a Modular Program

In this section, we create, build, and run the ``zoo.animal.feeding`` module. In addition to the `module-info.`
`java` file, it has one package with one class inside.

![[Pasted image 20240508192756.png]]

### Creating the Files

```java
package zoo.animal.feeding;
public class Task {
	public static void main(String... args) {
		System.out.println("All fed!");
	}
}
```

Next comes the ``module-info. java`` file. This is the simplest possible one:

```java
module zoo.animal.feeding {
}
```

There are a few key differences between a module declaration and a regular Java class declaration:

- ==**The ``module-info.java`` file must be in the root directory of your module. Regular Java classes should be in packages.**==
- ==**The module declaration must use the keyword ``module`` instead of ``class``, ``interface``, or ``enum``.**==
- ==**The module name follows the naming rules for package names. It often includes periods (.) in its name. Regular class and package names are not allowed to have dashes (-). Module names follow the same rule.==**

The next step is to make sure the files are in the right directory structure.

![[Pasted image 20240508193217.png]]

In particular, ``feeding`` is the module directory, and the ``module-info. java`` file is directly under it. Just as with a regular JAR file, we also have the ``zoo.animal.feeding`` package with one subfolder per portion of the name. The ``Task`` class is in the appropriate subfolder for its package
### Compiling Our First Module

Before we can run modular code, we need to compile it.

```java
javac -- module- path mods -d feeding feeding/zoo/animal/feeding/*.java feeding/module-info.
java
```

the ``-d`` option specifies the directory to place the class files in. The end of the command is a list of the .java files to compile. You can list the files individually or use a wildcard for all ``.java`` files in a subdirectory.

The new part is ``module-path``. This option indicates the location of any custom module files. 

---
**What about the classpath?**

**The classpath option has three possible forms: ``-cp``,`` class-path``, and ``-classpath``. You can still use these options. In fact, it is common to do so when writing nonmodular programs.**

---

Just like classpath, you can use an abbreviation in the command. The syntax ``module-path`` and ``-p`` are equivalent. That means we could have written many other commands in place of the previous command.

```java
javac -p mods -d feeding feeding/zoo/animal/feeding/*.java feeding/*.java

javac -p mods -d feeding feeding/zoo/animal/feeding/*.java feeding/module-info.java

javac -p mods -d feeding feeding/zoo/animal/feeding/Task.java feeding/module-info.java

javac -p mods -d feeding feeding/zoo/animal/feeding/Task.java feeding/*.java
```

While you can use whichever you like best, be sure that you can recognize all valid forms for the exam.

![[Pasted image 20240508193941.png]]

```java
javac -d out --module-source-path src/main/java --module com.jenkov.mymodule

"C:\Program Files\Java\jdk-9.0.4\bin\javac" -d out --module-source-path src/main/java --module com.jenkov.mymodule
```

**==The `--module-source-path` should point to the source root directory, not the module root directory. The source root directory is normally one level up from the module root directory.==**
### Running Our First Module

Suppose there is a module named ``book.module.`` Inside that module is a package named ``com.sybex,`` which has a class named ``OCP`` with a ``main()`` method. **==Pay special attention to the ``book.module/com.sybex.OCP`` part. It is important to remember that you specify the module name followed by a slash ``(/)`` followed by the fully qualified class name.==**

![[Pasted image 20240508194136.png]]

In the following example, the package name and module name are the same. **==It is common for the module name to match either the full package name or the beginning of it.==**

```java
java --module-path feeding--module zoo.animal.feeding/zoo.animal.feeding.Task
```

a short form of ``--module`` as well. The short option is ``-m``

```java
java -p feeding -m zoo.animal.feeding/zoo.animal.feeding.Task
```

![[Pasted image 20240508194349.png]]

**==The `--module` argument tells what module + main class to run==**
### Packaging Our First Module

A module isn’t much use if we can run it only in the folder it was created in. Our next step is to package it. Be sure to create a mods directory before running this command:

```java
jar -cvf mods/zoo.animal.feeding.jar -C feeding/ .
```

This represents how the module JAR will look to other code that wants to use it.

let’s run the program again, but this time using the mods directory instead of the loose classes:

```java
java -p mods -m zoo.animal.feeding/zoo.animal.feeding.Task
```

Since the module path is used, a module JAR is being run.
 
 You can package a Java module inside a standard JAR file. You do so with the standard `jar` command that comes with the Java SDK. The package directory hierarchy must start at the root of the JAR file, just like for pre Java 9 JAR files. Additionally, a Java module JAR file contains a compiled version of the module descriptor at the root of the JAR file.

```java
jar -c --file=out-jar/com-jenkov-mymodule.jar -C out/com.jenkov.mymodule 
```

The `-c` argument tells `jar` to create a new JAR file.

The `--file` argument tells the path of the output file - the created JAR file. **==Any directories you want the output JAR file to be under must already exist!==**

Once you have packaged your Java module into a JAR file, you can run it just like running a normal module. Just include the module JAR file on the module path

```java
java --module-path out-jar -m com.jenkov.mymodule/com.jenkov.mymodule.Main
```

For this command to work the module JAR file must be located in the `out-jar` directory.
## Updating Our Example for Multiple Modules

![[Pasted image 20240508195310.png]]

### Updating the Feeding Module

Since we will be having our other modules call code in the ``zoo.animal.feeding`` package, we need to declare this intent in the module declaration.

The ``exports`` directive is used to indicate that a module intends for those packages to be used by Java code outside the module. As you might expect, without an exports directive, the module is only available to be run from the command line on its own. In the following example, we export one package:


```java
module zoo.animal.feeding {
	exports zoo.animal.feeding;
}
```

Recompiling and repackaging the module will update the ``module-info.class`` inside our ``zoo.animal.feeding.jar`` file.

```java
javac -p mods -d feeding feeding/zoo/animal/feeding/*.java feeding/module-info.java

jar -cvf mods/zoo.animal.feeding.jar -C feeding/ .
```

**==Please note, that only the listed package itself is exported. No "subpackages" of the exported package are exported. That means, that if the `mymodule` package contained a subpackage named `util` then the `com.jenkov.mymodule.util` package is *not* exported just because `com.jenkov.mymodule` is.==**
### Creating a Care Module

let’s create the ``zoo.animal.care`` module. This time, we are going to have two packages. The ``zoo.animal.care.medical`` package will have the classes and methods that are intended for use by other modules. The ``zoo.animal.care.details`` package is only going to be used by this module. It will not be exported from the module. Remember that all modules must have a ``module-info.java`` file.

![[Pasted image 20240508195855.png]]

The module contains two basic packages and classes in addition to the ``module-info. java`` file

```java
// HippoBirthday.java
package zoo.animal.care.details;
import zoo.animal.feeding.*;
public class HippoBirthday {
private Task task;
}
// Diet.java
package zoo.animal.care.medical;
public class Diet { }
```

This time the ``module-info.java`` file specifies three things:

```java
1: module zoo.animal.care {
	2: exports zoo.animal.care.medical;
	3: requires zoo.animal.feeding;
4: }
```

- Line 1 specifies the name of the module. 
- Line 2 lists the package we are exporting so it can be used by other modules.
- On line 3, we see a new directive. **==The ``requires`` statement specifies that a module is needed==**. The ``zoo.animal.care`` module depends on the ``zoo.animal.feeding`` module.

Next, we need to figure out the directory structure. We will create two packages. The first is ``zoo.animal.care.details`` and contains one class named ``HippoBirthday``. The second is ``zoo.animal.care.medical``, which contains one class named ``Diet``. **==The packages begin with the same prefix as the module name. This is intentional. You can think of it as if the module name “claims” the matching package and all sub-packages.==**

```java
javac -p mods -d care \
    care/zoo/animal/care/details/*.java \
    care/zoo/animal/care/medical/*.java \
    care/module-info.java
```

Now that we have compiled code, it’s time to create the module JAR:

```java
jar -cvf mods/zoo.animal.care.jar -C care/ .
```

### Creating the Talks Module

Figure 12.8, observe that the ``zoo.animal.talks`` module depends on two modules: ``zoo.animal.feeding`` and ``zoo.animal.care``. This means that there must be two requires statements in the ``module-info. java`` file.

![[Pasted image 20240508201020.png]]

![[Pasted image 20240508201037.png]]

```java
1: module zoo.animal.talks {
	2: exports zoo.animal.talks.content;
	3: exports zoo.animal.talks.media;
	4: exports zoo.animal.talks.schedule;
	5:
	6: requires zoo.animal.feeding;
	7: requires zoo.animal.care;
8: }
```

- Line 1 shows the module name. 
- Lines 2–4 allow other modules to reference all three packages. 
- Lines 6 and 7 specify the two modules that this module depends on.

```java
// ElephantScript.java
package zoo.animal.talks.content;
public class ElephantScript { }
// SeaLionScript.java
package zoo.animal.talks.content;
public class SeaLionScript { }
// Announcement.java
package zoo.animal.talks.media;
public class Announcement {
	public static void main(String[] args) {
		System.out.println("We will be having talks");
	}
}

// Signage.java
package zoo.animal.talks.media;
public class Signage { }
// Weekday.java
package zoo.animal.talks.schedule;
public class Weekday { }
// Weekend.java
package zoo.animal.talks.schedule;
public class Weekend {}
```

The following are the commands to compile and build the module:

```java
javac -p mods -d talks \
    talks/zoo/animal/talks/content/*.java \
    talks/zoo/animal/talks/media/*.java \
    talks/zoo/animal/talks/schedule/*.java \
    talks/module-info.java

```

### Creating the Staff Module

![[Pasted image 20240508202109.png]]

![[Pasted image 20240508202120.png]]

There are three arrows in Figure 12.11 pointing from ``zoo.staff ``to other modules. These represent the three modules that are required. Since no packages are to be exposed from ``zoo.staff``, there are no exports statements.

```java
module zoo.staff {
	requires zoo.animal.feeding;
	requires zoo.animal.care;
	requires zoo.animal.talks;
}
```

```java
package zoo.staff;
public class Jobs { }
```

The following are the commands to compile and build the module:

```java
javac -p mods -d staff \
    staff/zoo/staff/*.java \
    staff/module-info.java

jar -cvf mods/zoo.staff.jar -C staff/ .
```

## Diving into the Module Declaration

### Exporting a Package

It’s also possible to export a package to a specific module.

```java
module zoo.animal.talks {
	exports zoo.animal.talks.content to zoo.staff;
	exports zoo.animal.talks.media;
	exports zoo.animal.talks.schedule;
	requires zoo.animal.feeding;
	requires zoo.animal.care;
}
```

From the ``zoo.staff`` module, nothing has changed. However, no other modules would be allowed to access that package. It is important to consider future use when designing modules.

---

**Exported Types**

**All ``public`` classes, interfaces, enums, and records are exported. Further, any ``public`` and ``protected`` fields and methods in those files are visible.** 

**Fields and methods that are ``private`` are not visible because they are not accessible outside the class. Similarly, package fields and methods are not visible because they are not accessible outside the package.****

---

**==The ``exports`` directive essentially gives us more levels of access control.==**

![[Pasted image 20240508203251.png]]

### Requiring a Module Transitively

**==``requires`` ``moduleName`` specifies that the current module depends on ``moduleName``. There’s also a ``requires`` ``transitive`` ``moduleName``, which means that any module that requires this module will also depend on ``moduleName``.==**

![[Pasted image 20240508203411.png]]

For example, ``zoo.animal.talks`` depends on ``zoo.animal.care``, which depends on ``zoo.animal.feeding``. That means the arrow between ``zoo.animal.talks`` and ``zoo.animal.feeding`` no longer appears in Figure 12.12

The first module remains unchanged. We are exporting one package to any packages that use the module.

```java
module zoo.animal.feeding {
	exports zoo.animal.feeding;
}
```

The ``zoo.animal.care`` module is the first opportunity to improve things. Rather than forcing all remaining modules to explicitly specify ``zoo.animal.feeding``, the code uses ``requires transitive``.

```java
module zoo.animal.care {
	exports zoo.animal.care.medical;
	requires transitive zoo.animal.feeding;
}
```

In the ``zoo.animal.talks`` module, we make a similar change and don’t force other modules to specify ``zoo.animal.care``.

```java
module zoo.animal.talks {
	exports zoo.animal.talks.content to zoo.staff;
	exports zoo.animal.talks.media;
	exports zoo.animal.talks.schedule;
	// no longer needed requires zoo.animal.feeding;
	// no longer needed requires zoo.animal.care;
	requires transitive zoo.animal.care;
}
```

Finally, in the ``zoo.staff`` module, we can get rid of two requires statements.

```java
module zoo.staff {
	// no longer needed requires zoo.animal.feeding;
	// no longer needed requires zoo.animal.care;
	requires zoo.animal.talks;
}
```

The more modules you have, the greater the benefits of the ``requires transitive`` compound. It is also more convenient for the caller. If you were trying to work with this zoo, you could just require ``zoo.staff`` and have the remaining dependencies automatically inferred.

#### Effects of ``requires transitive``

Applying the ``transitive`` modifiers has the following effects:

- **Module ``zoo.animal.talks`` can optionally declare that it requires the ``zoo.animal.feeding`` module, but it is not required.**
- **Module ``zoo.animal.care`` cannot be compiled or executed without access to the ``zoo.animal.feeding`` module.**
- **Module ``zoo.animal.talks`` cannot be compiled or executed without access to the ``zoo.animal.feeding`` module.**

#### Duplicate ``requires`` Statements

**==One place the exam might try to trick you is mixing ``requires`` and ``requires transitive``.==**

```java
module bad.module {
	requires zoo.animal.talks;
	requires transitive zoo.animal.talks;
}
```

Java doesn’t allow you to repeat the same module in a ``requires`` clause. It is redundant and most likely an error in coding. Keep in mind that ``requires transitive`` is like ``requires`` plus some extra behavior.

### Opening a Package

Java allows callers to inspect and call code at runtime with a technique called reflection. This is a powerful approach that allows calling code that might not be available at compile time. It can even be used to subvert access control! The opens directive is used to enable reflection of a package within a module. You only need to be aware that the opens directive exists rather than understanding it in detail for the exam.
Since reflection can be dangerous, the module system requires developers to explicitly allow reflection in the module declaration if they want calling modules to be allowed to use it.

```java
module zoo.animal.talks {
	opens zoo.animal.talks.schedule;
	opens zoo.animal.talks.media to zoo.staff;
}
```

## Creating a Service

A service is composed of an interface, any classes the interface references, and a way of looking up implementations of the interface. The implementations are not part of the service. In this example, the ``zoo.tours.api`` and ``zoo.tours.reservations`` modules make up the service since they consist of the interface and lookup functionality.

![[Pasted image 20240509210456.png]]

### Declaring the Service Provider Interface

```java
// Souvenir.java
package zoo.tours.api;
public record Souvenir(String description) { }
```

Next, the module contains a Java interface type. This ``interface`` is called the service provider interface because it specifies what behavior our service will have. In this case, it is a simple API with three methods.

```java
// Tour.java
package zoo.tours.api;
public interface Tour {
	String name();
	int length();
	Souvenir getSouvenir();
}
```

Since we are working with modules, we also need to create a ``module-info. java`` file so our module definition exports the package containing the interface. 

```java
// module-info.
java
module zoo.tours.api {
	exports zoo.tours.api;
}
```

compile and package this module.

```java
javac -d serviceProviderInterfaceModule \
    serviceProviderInterfaceModule/zoo/tours/api/*.java \
    serviceProviderInterfaceModule/module-info.java

jar -cvf mods/zoo.tours.api.jar -C serviceProviderInterfaceModule/ .
```

### Creating a Service Locator

To complete our service, we need a service locator. A service locator can find any classes that implement a service provider interface. Luckily, Java provides a ServiceLoader class to help with this task. You pass the service
provider interface type to its ``load()`` method, and Java will return any implementation services it can find.

```java
// TourFinder.java
package zoo.tours.reservations;

import java.util.*;
import zoo.tours.api.*;

public class TourFinder {

    public static Tour findSingleTour() {
        ServiceLoader<Tour> loader = ServiceLoader.load(Tour.class);
        for (Tour tour : loader)
            return tour;
        return null;
    }

    public static List<Tour> findAllTours() {
        List<Tour> tours = new ArrayList<>();
        ServiceLoader<Tour> loader = ServiceLoader.load(Tour.class);
        for (Tour tour : loader)
            tours.add(tour);
        return tours;
    }
}
```

we provided two lookup methods. The first is a convenience method if you are expecting exactly one Tour to be returned. The other returns a List, which accommodates any number of service providers. At runtime, there may be many service providers (or none) that are found by the service locator.

---

**The ``ServiceLoader`` call is relatively expensive. If you are writing a real application, it is best to cache the result.**

---

Our module definition ``exports`` the package with the lookup class ``TourFinder``. It requires the service provider interface package. It also has the uses directive since it will be looking up a service.

```java
// module-info.
java
module zoo.tours.reservations {
	exports zoo.tours.reservations;
	requires zoo.tours.api;
	uses zoo.tours.api.Tour;
}
```

both ``requires`` and ``uses`` are needed, one for compilation and one for lookup.

```java
javac -p mods -d serviceLocatorModule \
    serviceLocatorModule/zoo/tours/reservations/*.java \
    serviceLocatorModule/module-info.java

jar -cvf mods/zoo.tours.reservations.jar -C serviceLocatorModule/ .
```

---
**Using ``ServiceLoader``**
**There are two methods in ``ServiceLoader`` that you need to know for the exam.**

```java
public final class ServiceLoader<S> implements Iterable<S> {
public static <S> ServiceLoader<S> load(Class<S> service) { ... }
public Stream<Provider<S>> stream() { ... }
// Additional methods
}
```

**calling ``ServiceLoader.load()`` returns an object that you can loop through normally. However, requesting a ``Stream`` gives you a different type. The reason for this is that a ``Stream`` controls when elements are evaluated. Therefore, a ``ServiceLoader`` returns a ``Stream`` of Provider objects. You have to call ``get()`` to retrieve the value you wanted out of each Provider**

```java
ServiceLoader.load(Tour.class)
	.stream()
	.map(Provider::get)
	.mapToInt(Tour::length)
	.max()
	.ifPresent(System.out::println);
```

---
### Invoking from a Consumer

Next up is to call the service locator by a consumer. A consumer (or client) refers to a module that obtains and uses a service. Once the consumer has acquired a service via the service locator, it is able to invoke the methods provided by the service provider interface.

```java
// Tourist.java
package zoo.visitor;
import java.util.*;
import zoo.tours.api.*;
import zoo.tours.reservations.*;
public class Tourist {
	public static void main(String[] args) {
		Tour tour = TourFinder.findSingleTour();
		System.out.println("Single tour: " + tour);
		List<Tour> tours = TourFinder.findAllTours();
		System.out.println("# tours: " + tours.size());
	}
}
```

```java
// module-info.
java
module zoo.visitor {
	requires zoo.tours.api;
	requires zoo.tours.reservations;
}
```

```java
javac -p mods -d consumerModule \
    consumerModule/zoo/visitor/*.java \
    consumerModule/module-info.java

jar -cvf mods/zoo.visitor.jar -C consumerModule/ .

java -p mods -m zoo.visitor/zoo.visitor.Tourist

```

### Adding a Service Provider

A service provider is the implementation of a service provider interface. at runtime it is possible to have multiple implementation classes or modules.

Our service provider is the ``zoo.tours.agency`` package because we’ve outsourced the running of tours to a third party.

```java
// TourImpl.java
package zoo.tours.agency;
import zoo.tours.api.*;
public class TourImpl implements Tour {
	public String name() {
		return "Behind the Scenes";
	}
	public int length() {
		return 120;
	}
	public Souvenir getSouvenir() {
		return new Souvenir("stuffed animal");
	}
}
```

we need a ``module-info. java`` file to create a module.

```java
// module-info.
java
module zoo.tours.agency {
	requires zoo.tours.api;
	provides zoo.tours.api.Tour with zoo.tours.agency.TourImpl;
}
```

The module declaration requires the module containing the interface as a dependency.

---

**We have not exported the package containing the implementation. Instead, we have made the implementation available to a service provider using the interface.**

---

```java
javac -p mods -d serviceProviderModule \
    serviceProviderModule/zoo/tours/agency/*.java \
    serviceProviderModule/module-info.java

jar -cvf mods/zoo.tours.agency.jar -C serviceProviderModule/ .
```

```java
java -p mods -m zoo.visitor/zoo.visitor.Tourist
```
```text
Single tour: zoo.tours.agency.TourImpl@1936f0f5 # tours: 1
```

### Reviewing Directives and Services

Table 12.4 summarizes what we’ve covered in the section about services. **==We recommend learning really well what is needed when each artifact is in a separate module. That is most likely what you will see on the exam and will ensure that you understand the concepts.==** Table 12.5 lists all the directives you need to know for the exam.

![[Pasted image 20240509213224.png]]

## Discovering Modules

You do not need to know the output of the commands in this section. You do, however, need to know the syntax of the commands and what they do.

### Identifying Built-in Modules

**==The most important module to know is ``java.base``. It contains most of the packages you have been learning about for the exam. In fact, it is so important that you don’t even have to use the ``requires`` directive; it is available to all modular applications. Your ``module-info. java`` file will still compile if you explicitly require j``ava.base``. However, it is redundant, so it’s better to omit it.==**

![[Pasted image 20240509213600.png]]

For the exam, you need to know that module names begin with java for APIs you are likely to use and with jdk for APIs that are specific to the JDK.

![[Pasted image 20240509213640.png]]

![[Pasted image 20240509213657.png]]

### Getting Details with java

The java command has three module-related options. 
- One describes a module, 
- another lists the available modules, and 
- the third shows the module resolution logic.

#### Describing a Module

```java
module zoo.animal.feeding {
	exports zoo.animal.feeding;
}
```

The ``java`` command has an option to describe a module. The following two commands are equivalent:

```java
java -p mods -d zoo.animal.feeding
java -p mods -- describe- module zoo.animal.feeding
```

Each prints information about the module. For example, it might print this:

```java
zoo.animal.feeding file:///absolutePath/mods/zoo.animal.feeding.jar
exports zoo.animal.feeding
requires java.base mandated
```

On the third line, we see requires ``java.base`` mandated. Now, wait a minute. The module declaration very clearly does not specify any modules that ``zoo.animal.feeding`` has as dependencies.

**==Remember, the ``java.base`` module is special. It is automatically added as a dependency to all modules. This module has frequently used packages like ``java.util``. That’s what the mandated is about. You get ``java.base`` regardless of whether you asked for it. In classes, the`` java.lang`` package is automatically imported whether you type it or not. The`` java.base`` module works the same way. It is automatically available to all other modules==**

#### Listing Available Modules

The simplest form lists the modules that are part of the JDK.

```java
java --list-modules
```

When we ran it, the output went on for 70 lines and looked like this:

```java
java.base@17
java.compiler@17
java.datatransfer@17
```

This is a listing of all the modules that come with Java and their version numbers. More interestingly, you can use this command with custom code

```java
java -p mods -- list- modules
```

```java
zoo.animal.care file:///absolutePath/mods/zoo.animal.care.jar
zoo.animal.feeding file:///absolutePath/mods/zoo.animal.feeding.jar
```

Since these are custom modules, we get a location on the file system. If the project had a module version number, it would have both the version number and the file system path.

#### Showing Module Resolution

You can think of it as a way of debugging modules. It spits out a lot of output when the program starts up. Then it runs the program.

```java
java -- show- module- resolution -p feeding -m zoo.animal.feeding/zoo.animal.feeding.Task
```

```java
root zoo.animal.feeding file:///absolutePath/feeding/
java.base binds java.desktop jrt:/java.desktop
java.base binds jdk.jartool jrt:/jdk.jartool
...
jdk.security.auth requires java.naming jrt:/java.naming
jdk.security.auth requires java.security.jgss jrt:/java.security.jgss
...
All fed!
```

It starts by listing the root module. That’s the one we are running:``zoo.animal.feeding``. Then it lists many lines of packages included by the mandatory ``java.base`` module. After a while, it lists modules that have dependencies. Finally, it outputs the result of the program: ``All fed!``.
### Describing with jar

Like the java command, the ``jar`` command can describe a module.

```java
jar -f mods/zoo.animal.feeding.jar -d
jar -- file mods/zoo.animal.feeding.jar -- describe- module
```

```java
zoo.animal.feeding jar:file:///absolutePath/mods/zoo.animal.feeding.jar
/!module-info.class
exports zoo.animal.feeding
requires java.base mandated
```

### Learning about Dependencies with ``jdeps``

The ``jdeps`` command gives you information about dependencies within a module. Unlike describing a module, it looks at the code in addition to the module declaration. This tells you what dependencies are actually used rather than simply declared. Luckily, you are not expected to memorize all the options for the exam.

```java
// Animatronic.java
package zoo.dinos;

import java.time.*;
import java.util.*;
import sun.misc.Unsafe;

public class Animatronic {
    private List<String> names;
    private LocalDate visitDate;

    public Animatronic(List<String> names, LocalDate visitDate) {
        this.names = names;
        this.visitDate = visitDate;
    }

    public void unsafeMethod() {
        Unsafe unsafe = Unsafe.getUnsafe();
    }
}
```

Now we can compile this file. You might have noticed that there is no ``module-info. java file``. That is because we aren’t creating a module. We are looking into what dependencies we will need when we do modularize this ``JAR``.

```java
javac zoo/dinos/*.java
```

Compiling works, but it gives you some warnings about ``Unsafe`` being an internal API.

```java
jar -cvf zoo.dino.jar .
```

We can run the ``jdeps`` command against this ``JAR`` to learn about its dependencies. On the first two lines, the command prints the modules that we would need to add with a ``requires`` directive to migrate to the module system. It also prints a table showing what packages are used and what modules they correspond to.

```java
zoo.dino.jar -> java.base, jdk.unsupported
zoo.dinos -> java.lang, java.base, java.time, java.base, java.util, java.base, sun.misc (JDK internal API) (jdk.unsupported)

```

Note that ``java.base`` is always included. It also says which modules contain classes used by the JAR. If we run in summary mode, we only see just the first part where ``jdeps`` lists the modules.

```java
jdeps -s zoo.dino.jar
jdeps -summary zoo.dino.jar

zoo.dino.jar -> java.base
zoo.dino.jar -> jdk.unsupported
```

For a real project, the dependency list could include dozens or even hundreds of packages. It’s useful to see the summary of just the modules. This approach also makes it easier to see whether ``jdk.unsupported`` is in the list.

### Using the ``--jdk- internals`` Flag

The ``jdeps`` command has an option to provide details about these unsupported APIs

```java
jdeps -- jdk- internals zoo.dino.jar
zoo.dino.jar -> jdk.unsupported
zoo.dinos.Animatronic -> sun.misc.Unsafe
JDK internal API (jdk.unsupported)
Warning: <omitted warning>
JDK Internal API Suggested Replacement
sun.misc.Unsafe See http://openjdk.java.net/jeps/260
```

**==The ``--jdk- internals`` option lists any classes you are using that call an internal API along with which API==**. At the end, it provides a table suggesting what you should do about it. If you wrote the code calling the internal API, this message is useful. If not, the message would be useful to the team that did write the code. You, on the other hand, might need to update or replace that JAR file entirely with one that fixes the issue. **==Note that ``-jdk internals`` is equivalent to ``-- jdk- internals``==**.
### Using Module Files with ``jmod``

The final command you need to know for the exam is ``jmod``. You might think a ``JMOD`` file is a Java module file. Not quite. Oracle recommends using ``JAR`` files for most modules. **==``JMOD`` files are recommended only when you have native libraries or something that can’t go inside a ``JAR`` file==**. This is unlikely to affect you in the real world.

![[Pasted image 20240509222139.png]]

### Creating Java Runtimes with ``jlink``

One of the benefits of modules is being able to supply just the parts of Java you need.

```java
jlink -- module- path mods -- add- modules zoo.animal.talks -- output zooApp
```

- First we specify where to find the custom modules with ``-p`` or ``-- module- path``.
- Then we specify our module names with ``-- add- modules``. This will include the dependencies it requires as long as they can be found.
- Finally, we specify the folder name of our smaller JDK with ``--output``.

The output directory contains the ``bin``, ``conf``, ``include``, ``legal``, ``lib``, and man directories along with a ``release`` file. These should look familiar as you find them in the full JDK as well. When we run this command and zip up the ``zooApp`` directory, the file is only 15 MB. This is an order of magnitude smaller than the full JDK. Where did this space savings come from? There are many modules in the JDK we don’t need. Additionally, development tools like javac don’t need to be in a runtime distribution.
### Reviewing Command-Line Options

![[Pasted image 20240509222603.png]]
![[Pasted image 20240509222615.png]]

![[Pasted image 20240509222638.png]]

![[Pasted image 20240509222708.png]]

![[Pasted image 20240509222723.png]]

## Comparing Types of Modules

All the modules we’ve used so far in this chapter are called named modules. There are two other types of modules: automatic modules and unnamed modules.

### Named Modules

A named module is one containing a ``module-info. java`` file. To review, this file appears in the root of the JAR alongside one or more packages. Unless otherwise specified, a module is a named module. Named modules appear on the module path rather than the classpath.

As a way of remembering this, a named module has the name inside the ``module-info. java`` file and is on the module path.
### Automatic Modules

An automatic module appears on the module path but does not contain a ``module-info. java`` file. It is simply a regular JAR file that is placed on the module path and gets treated as a module.

As a way of remembering this, Java automatically determines the module name. The code referencing an automatic module treats it as if there is a ``module-info. java`` file present. It automatically exports all packages. It also determines the module name. How does it determine the module name,

Every JAR file contains a special folder called ``META-INF`` and, within it, a text file called ``MANIFEST.MF``. It can be created automatically when the JAR is created or by hand by the JAR’s author. Getting back to modules, many Java libraries weren’t quite ready to modularize when the feature was introduced. The authors were encouraged to declare the name they intended to use for the module by adding a property named Automatic-Module- Name into their ``MANIFEST.MF`` file.

Specifying a single property in the manifest allowed library providers to make things easier for applications that wanted to use their library in a modular application. You can think of it as a promise that when the library becomes a named module, it will use the specified module name. If the JAR file does not specify an automatic module name, Java will still allow you to use it in the module path. In this case, Java will determine the module name for you.

Java determines the automatic module name by basing it on the filename of the JAR file. First Java will remove the extension ``.jar`` from the name. Then Java will remove the version from the end of the JAR filename. This is important because we want module names to be consistent. Having a different automatic module name every time you upgraded to a new version would not be good! After all, this would force you to change the module declaration of your nice, clean, modularized application every time you pulled in a later version of the holiday calendar JAR.

Removing the version and extension gives us ``holiday-calendar``. This leaves us with a problem. Dashes (-) are not allowed in module names. Java solves this problem by converting any special characters in the name to dots (.). As a result, the module name is ``holiday.calendar``. Any characters other than letters and numbers are considered special characters in this replacement. Finally, any adjacent dots or leading/trailing dots are removed.

-  ==**If the MANIFEST.MF specifies an Automatic-Module-Name, use that. Otherwise, proceed with the remaining rules.**==
-  ==**Remove the file extension from the JAR name.**==
-  ==**Remove any version information from the end of the name. A version is digits and dots with possible extra information at the end: for example, -1.0.0 or -1.0- RC.**==
-  ==**Replace any remaining characters other than letters and numbers with dots.**==
-  ==**Replace any sequences of dots with a single dot.**==
-  ==**Remove the dot if it is the first or last character of the result.==**

![[Pasted image 20240510203235.png]]

### Unnamed Modules

An unnamed module appears on the classpath. Like an automatic module, it is a regular JAR. Unlike an automatic module, it is on the classpath rather than the module path. This means an unnamed module is treated like old code and a second-class citizen to modules. An unnamed module does not usually contain a `module-info. java` file. If it happens to contain one, that file will be ignored since it is on the classpath.

Unnamed modules do not export any packages to named or automatic modules. The unnamed module can read from any JARs on the classpath or module path. You can think of an unnamed module as code that works the way Java worked before modules.

### Reviewing Module Types

![[Pasted image 20240510203400.png]]

## Migrating an Application

Many applications were not designed to use the Java Platform Module System because they were written before it was created or chose not to use it. Ideally, they were at least designed with projects instead of as a big ball of mud
### Determining the Order

Before we can migrate our application to use modules, we need to know how the packages and libraries in the existing application are structured. Suppose we have a simple application with three JAR files, as shown in Figure 12.14. The dependencies between projects form a graph. Both of the representations in Figure 12.14 are equivalent. The arrows show the dependencies by pointing from the project that will require the dependency to the one that makes it available. In the language of modules, the arrow will go from ``requires`` to ``exports``.

![[Pasted image 20240510204054.png]]

The right side of the diagram makes it easier to identify the top and bottom that top-down and bottom-up migration refer to. Projects that do not have any dependencies are at the bottom. Projects that do have dependencies are at the top.

![[Pasted image 20240510204144.png]]

### Exploring a Bottom-Up Migration Strategy

The easiest approach to migration is a bottom-up migration. This approach works best when you have the power to convert any JAR files that aren’t already modules. For a bottom-up migration, you follow these steps:

1. ==**Pick the lowest-level project that has not yet been migrated. (Remember the way we ordered them by dependencies in the previous section?)**==
2. ==**Add a module-info. java file to that project. Be sure to add any exports to expose any package used by higher-level JAR files. Also, add a requires directive for any modules this module depends on.**==
3. ==**Move this newly migrated named module from the classpath to the module path.**==
4. ==**Ensure that any projects that have not yet been migrated stay as unnamed modules onthe classpath.**==
5. ==**Repeat with the next-lowest-level project until you are done.==**

With a bottom-up migration, you are getting the lower-level projects in good shape. This makes it easier to migrate the top-level projects at the end. It also encourages care in what is exposed. During migration, you have a mix of named modules and unnamed modules. The named modules are the lower-level ones that have been migrated. They are on the module path and not allowed to access any unnamed modules

![[Pasted image 20240510204319.png]]

### Exploring a Top-Down Migration Strategy

A top-down migration strategy is most useful when you don’t have control of every JAR file used by your application. For example, suppose another team owns one project. They are just too busy to migrate. You wouldn’t want this situation to hold up your entire migration. For a top-down migration, you follow these steps:

1. ==**Place all projects on the module path.**==
2. ==**Pick the highest-level project that has not yet been migrated.**==
3. ==**Add a module-info. java file to that project to convert the automatic module into a named module. Again, remember to add any exports or requires directives. You can use the automatic module name of other modules when writing the requires directive since most of the projects on the module path do not have names yet.**==
4. ==**Repeat with the next-highest-level project until you are done.==**

![[Pasted image 20240510204443.png]]

With a top-down migration, you are conceding that all of the lower-level dependencies are not ready but that you want to make the application itself a module. During migration, you have a mix of named modules and automatic modules. The named modules are the higher-level ones that have been migrated. They are on the module path and have access to the automatic modules. The automatic modules are also on the module path.

![[Pasted image 20240510204517.png]]

### Splitting a Big Project into Modules

For the exam, you need to understand the basic process of splitting a big project into modules.
Suppose you start with an application that has a number of packages. The first step is to break them into logical groupings and draw the dependencies between them.

![[Pasted image 20240510204601.png]]

There’s a problem with this decomposition. Do you see it? The Java Platform Module System does not allow for cyclic dependencies. A cyclic dependency, or circular dependency, is when two things directly or indirectly depend on each other. If the ``zoo.tickets.delivery`` module requires the ``zoo.tickets.discount`` module, ``zoo.tickets.discount`` is not allowed to require the ``zoo.tickets.delivery`` module. what can we do
about it? A common technique is to introduce another module. That module contains the code that the other two modules share. 

### Failing to Compile with a Cyclic Dependency

It is extremely important to understand that Java will not allow you to compile modules that have circular dependencies

![[Pasted image 20240510204748.png]]

```java
// Butterfly.java
package zoo.butterfly;
public class Butterfly {
	private Caterpillar caterpillar;
}
// module-info.
java
module zoo.butterfly {
	exports zoo.butterfly;
	requires zoo.caterpillar;
}
```

```java
// Caterpillar.java
package zoo.caterpillar;
public class Caterpillar {
	Butterfly emergeCocoon() {
		// logic omitted
	}
}
```
```java
// module-info.
java
module zoo.caterpillar {
	exports zoo.caterpillar;
	requires zoo.butterfly;
}
```

This is our circular dependency problem at work. This is one of the advantages of the module system. It prevents you from writing code that has a cyclic dependency. Such code won’t even compile!

---

**Java will still allow you to have a cyclic dependency between packages within a module. It enforces that you do not have a cyclic dependency between modules.**

---

## Summary #OCP_Summary 

**==The Java Platform Module System organizes code at a higher level than packages. Each module contains one or more packages and a ``module-info. java`` file. The`` java.base`` module is most common and is automatically supplied to all modules as a dependency.**==

==**The process of compiling and running modules uses the -``-module- path``, also known as ``-p``. Running a module uses the ``-- module option``, also known as ``-m``. The class to run is specified in the format ``moduleName/className``.**==

==**The module declaration file supports a number of directives. The ``exports`` directive specifies that a package should be accessible outside the module. It can optionally restrict that export to a specific package. The ``requires`` directive is used when a module depends on code in another module. Additionally, ``requires transitive`` can be used when all modules that require one module should always require another. The provides and uses directives are used when sharing and consuming a service. Finally, the opens directive is used to allow access via reflection.**==
 
 ==**Both the java and jar commands can be used to describe the contents of a module. The java command can additionally list available modules and show module resolution. The ``jdeps`` command prints information about packages used in addition to module-level information. The ``jmod`` command is used when dealing with files that don’t meet the requirements for a JAR. The ``jlink`` command creates a smaller Java runtime image.**==

==**There are three types of modules. Named modules contain a ``module-info. java`` file and are on the module path. They can read only from the module path. Automatic modules are also on the module path but have not yet been modularized. They might have an automatic module name set in the manifest. Unnamed modules are on the classpath.**==
 
 ==**The two most common migration strategies are top-down and bottom-up migration. Top-down migration starts migrating the module with the most dependencies and places all other modules on the module path. Bottom-up migration starts migrating a module with no dependencies and moves one module to the module path at a time. Both of these strategies require ensuring that you do not have any cyclic dependencies since the Java Platform Module System will not allow cyclic dependencies to compile.==**

## Exam Essentials #Essential 

**Create module-info.java** files. Place the module-info. java file in the root directory of the module. Know how to code exports, requires, provides, and uses directives. Additionally, be familiar with the opens directive.

**Use command-line operations with modules**. The java command can describe a module, list available modules, or show the module resolution. The jar command can describe a module similar to how the java command does. The ``jdeps`` command prints details about a module and packages. The ``jmod`` command provides various modes for working with JMOD files rather than JAR files. The ``jlink`` command creates custom Java images.

**Identify the three types of modules**. Named modules are JARs that have been modularized. Unnamed modules have not been modularized. Automatic modules are in between. They are on the module path but do not have a ``module-info. java`` file

**List built-in JDK modules**. The ``java.base`` module is available to all modules. There are about 20 other modules provided by the JDK that begin with java.* and about 30 that begin with ``jdk.*.``

**Explain top-down and bottom-up migration**. A top-down migration places all JARs on the module path, making them automatic modules while migrating from top to bottom. A bottom-up migration leaves all JARs on the classpath, making them unnamed modules while migrating from bottom to top.

**Differentiate the four main parts of a service**. A service provider interface declares the interface that a service must implement. The service locator looks up the service, and a consumer calls the service. Finally, a service provider implements the service.

## Review Questions

1. Which statement is true of the following module?

```java
|---zoo
	|--staff
		|-- Vet.java
```

A. The directory structure shown is a valid module.
B. The directory structure would be a valid module if module.java were added directly underneath zoo/staff.
C. The directory structure would be a valid module if module.java were added directly underneath zoo.
D. The directory structure would be a valid module if module-info. java were added directly underneath zoo/staff.
E. The directory structure would be a valid module if module-info. java were added directly underneath zoo.
F. None of these changes would make this directory structure a valid module.

**Modules are required to have a module-info. java file at the root directory of the module. Option E matches this requirement.**

---

2. Suppose module puppy depends on module dog and module dog depends on module animal. Fill in the blank so that code in module dog can access the animal.behavior package in module animal.

```java
module animal {
	animal.behavior;
}
```

A. export
B. exports
C. require
D. requires
E. require transitive
F. requires transitive
G. None of the above

**Options A, C, and E are incorrect because they refer to directives that don’t exist. ==The exports directive is used when allowing a package to be called by code outside of the module==, making option B the correct answer. Notice that options D and F are incorrect because of requires.**

---

3. Fill in the blanks so this command to run the program is correct:

```java
java
??zoo.animal.talks/zoo/animal/talks/Peacocks
??modules
```

A. -d and -m
B. -d and –p
C. -m and -d
D. -m and -p
E. -p and -d
F. -p and -m
G. None of the above

**The -m or -- module option is used to specify the module and class name. The -p or --module- path option is used to specify the location of the modules. Option D would be correct if the rest of the command were correct. However, running a program requires specifying the package name with periods (.) instead of slashes**

---

4. Which of the following pairs make up a service?
A. Consumer and service locator
B. Consumer and service provider interface
C. Service locator and service provider
D. Service locator and service provider interface
E. Service provider and service provider interface

**A service consists of the service provider interface and logic to look up implementations using a service locator. This makes option D correct. ==Make sure you know that the service provider itself is the implementation, which is not considered part of the service==**

---

5. A(n) ?? module is on the classpath while a(n) ?? ____________ module is on the module path. (Choose all that apply.)

A. automatic, named
B. automatic, unnamed
C. named, automatic
D. named, unnamed
E. unnamed, automatic
F. unnamed, named
G. None of the above

**Automatic modules are on the module path but do not have a module-info. java file. Named modules are on the module path and do have a module-info. Unnamed modules are on the classpath. Therefore, options E and F are correct.**

---

6. Which of the following statements are true in a module-info. java file? (Choose all that apply.)

A. The opens directive allows the use of reflection.
B. The opens directive declares that an API is called.
C. The use directive allows the use of reflection.
D. The use directive declares that an API is called.
E. The uses directive allows the use of reflection.
F. The uses directive declares that an API is called.

**Options C and D are incorrect because there is no use directive. Options A and F are correct because opens is for reflection and uses declares that an API consumes a service.**

---

7. An automatic module name is generated if one is not supplied. Which of the following JAR filenames and generated automatic module name pairs are correct? (Choose all that apply.)

A. emily-1.0.0. jar and emily
B. emily-1.0.0- SNAPSHOT. jar and emily
C. emily_the_cat-1.0.0. jar and emily_the_cat
D. emily_the_cat-1.0.0. jar and emily-the- cat
E. emily.$.jar and emily
F. emily.$.jar and emily.
G. emily.$.jar and emily..

**Any version information at the end of the JAR filename is removed, making options A and B correct. Underscores (_) are turned into dots (.), making options C and D incorrect. Other special characters like a dollar sign ($) are also turned into dots. However, adjacent dots are merged, and leading/trailing dots are removed. Therefore, option E is correct**

---

8. Which of the following statements are true? (Choose all that apply.)

A. Modules with cyclic dependencies will not compile.
B. Packages with a cyclic dependency will not compile.
C. A cyclic dependency always involves exactly two modules.
D. A cyclic dependency always involves at least two requires statements.
E. An unnamed module can be involved in a cyclic dependency with an automatic module.

**A cyclic dependency is when a module graph forms a circle. Option A is correct because the Java Platform Module System does not allow cyclic dependencies between modules. No such restriction exists for packages, making option B incorrect. A cyclic dependency can involve two or more modules that require each other, making option D correct, while option C is incorrect. Finally, option E is incorrect because ==unnamed modules cannot be referenced from an automatic module==.**

---

9. Suppose you are creating a service provider that contains the following class. Which line of code needs to be in your module-info. java?

```java
package dragon;
import magic.*;
public class Dragon implements Magic {
	public String getPower() {
		return "breathe fire";
	}
}
```

A. provides dragon.Dragon by magic.Magic;
B. provides dragon.Dragon using magic.Magic;
C. provides dragon.Dragon with magic.Magic;
D. provides magic.Magic by dragon.Dragon;
E. provides magic.Magic using dragon.Dragon;
F. provides magic.Magic with dragon.Dragon;

**The provides directive takes the interface name first and the implementing class name second and also uses with. Only option F meets these two criteria, making it the correct answer.**

---

10. What is true of a module containing a file named module-info. java with the following contents? (Choose all that apply.)

```java
module com.food.supplier {}
```

A. All packages inside the module are automatically exported.
B. No packages inside the module are automatically exported.
C. A main method inside the module can be run.
D. A main method inside the module cannot be run since the class is not exposed.
E. The module-info. java file contains a compiler error.
F. The module-info. java filename is incorrect.

**Packages inside a module are not exported by default, making option B correct and option A incorrect. Exporting is necessary for other code to use the packages; it is not necessary to call the main() method at the command line, making option C correct and option D incorrect. The module-info. java file has the correct name and compiles, making options E and F incorrect.**

---

11. Suppose module puppy depends on module dog and module dog depends on module animal. Which lines allow module puppy to access the animal.behavior package in module animal? (Choose all that apply.)

```java
module animal {
	exports animal.behavior;
}
module dog {
	?? animal; // line S
}
module puppy {
	?? dog; // line T
}
```

A. require on line S
B. require on line T
C. requires on line S
D. requires on line T
E. require transitive on line S
F. require transitive on line T
G. requires transitive on line S
H. requires transitive on line T

**Options A, B, E, and F are incorrect because they refer to directives that don’t exist. ==The requires transitive directive is used when specifying a module to be used by the requesting module and any other modules that use the requesting module==. Therefore, dog needs to specify the transitive relationship, and option G is correct. The module puppy just needs requires dog, and it gets the transitive dependencies, making option D correct. However, requires transitive does everything requires does and more, which makes option H the final answer.**


---

12. Which of the following modules are provided by the JDK? (Choose all that apply.)

A. java.base
B. java.desktop
C. java.logging
D. java.util
E. jdk.base
F. jdk.compiler
G. jdk.xerces

**Option D is incorrect because it is a package name rather than a module name. Option E is incorrect because java.base is the module name, not jdk.base. Option G is wrong because we made it up. Options A, B, C, and F are correct.**

---

13. Which of the following compiles and is equivalent to this loop?

```java
List<Unicorn> all = new ArrayList<>();
for (Unicorn current : ServiceLoader.load(Unicorn.class))
	all.add(current);
```

A.
```java
List<Unicorn> all = ServiceLoader.load(Unicorn.class)
.getStream()
.collect(Collectors.toList());
```

B.
```java
List<Unicorn> all = ServiceLoader.load(Unicorn.class)
.stream()
.collect(Collectors.toList());
```

C.
```java
List<Unicorn> all = ServiceLoader.load(Unicorn.class)
.getStream()
.map(Provider::get)
.collect(Collectors.toList());
```

D.
```java
List<Unicorn> all = ServiceLoader.load(Unicorn.class)
.stream()
.map(Provider::get)
.collect(Collectors.toList());
```

E. None of the above

**There is no getStream() method on a ServiceLoader, making options A and C incorrect. Option B does not compile because the stream() method returns a list of Provider interfaces and needs to be converted to the Unicorn interface we are interested in. Therefore, option D is correct.**

---

14. Which of the following are legal commands to run a modular program where n is the module name and c is the fully qualified class name? (Choose all that apply.)

A. java --module-path x -m n.c
B. java -- module- path x -p n.c
C. java -- module- path x-x -m n/c
D. java -- module- path x -p n/c
E. java -- module- path x-x -m n-c
F. java -- module- path x -p n-c
G. None of the above

**The -p option is a shorter form of -- module- path. Since the same option cannot be specified twice, options B, D, and F are incorrect. The -- module- path option is an alternate form of -p. The module name and class name are separated with a slash, making option C the answer. Note that x-x is legal because the module path is a folder name, so dashes are allowed.**

---

15. For a top-down migration, all modules other than named modules are ??_____________ modules and are on the ??____________.

A. automatic, classpath
B. automatic, module path
C. unnamed, classpath
D. unnamed, module path
E. None of the above

**A top-down migration strategy first places all JARs on the module path. Then it migrates the top-level module to be a named module, leaving the other modules as automatic modules. Option B is correct as it matches both of those characteristics.**

---

16. Suppose you have separate modules for a service provider interface, service provider, service locator, and consumer. If you add a second service provider module, how many of these modules do you need to recompile?

A. Zero
B. One
C. Two
D. Three
E. Four
 
 **Since this is a new module, you need to compile it. However, none of the existing modules needs to be recompiled, making option A correct. The service locator will see the new service provider simply by having that new service provider on the module path.**

---

17. Suppose we have a JAR file named cat-1.2.3- RC1. jar, and Automatic-Module- Name in the MANIFEST.MF is set to dog. What should an unnamed module referencing this automatic module include in module-info. java?

A. requires cat;
B. requires cat.RC;
C. requires cat-RC;
D. requires dog;
E. None of the above

**Trick question! ==An unnamed module doesn’t use a module-info. java file. Therefore, option E is correct. An unnamed module can access an automatic module. The unnamed module would simply treat the automatic module as a regular JAR without involving the module.info file==.**

---

18. Which commands are used to create a smaller Java image and work with native code, respectively?

A. jimage and jlink
B. jimage and jmod
C. jlink and jimage
D. jlink and jmod
E. jmod and jimage
F. jmod and jmod

**The jlink command creates a directory with a smaller Java runtime containing just what is needed. The JMOD format is for native code. Therefore, option D is correct.**

---

19. Which are true statements about the following module? (Choose all that apply.)

```java
class dragon {
	exports com.dragon.fire;
	exports com.dragon.scales to castle;
}
```

A. All modules can reference the com.dragon.fire package.
B. All modules can reference the com.dragon.scales package.
C. Only the castle module can reference the com.dragon.fire package.
D. Only the castle module can reference the com.dragon.scales package.
E. None of the above

**There is a trick here. ==A module definition uses the keyword module rather than class==. Since the code does not compile, option E is correct. If the code did compile, options A and D would be correct.**

---

20. Which would you expect to see when describing any module?
A. requires java.base mandated
B. requires java.core mandated
C. requires java.lang mandated
D. requires mandated java.base
E. requires mandated java.core
F. requires mandated java.lang
G. None of the above

**When running java with the -d option, all the required modules are listed. Additionally, the java.base module is listed since it is included automatically. The line ends with mandated, making option A correct. The java.lang is a trick since it is a package that is imported by default in a class rather than a module.**

---

21. Suppose you have separate modules for a service provider interface, service provider, service locator, and consumer. Which module(s) need to specify a requires directive on the service provider?
A. Service locator
B. Service provider interface
C. Consumer
D. Consumer and service locator
E. Consumer and service provider
F. Service locator and service provider interface
G. Consumer, service locator, and service provider interface
H. None of the above

**This question is tricky. ==The service locator must have a uses directive, but that is on the service provider interface. No modules need to specify requires on the service provider since that is the implementation==. Since none are correct, option H is the answer.**

---

22. Which are true statements? (Choose all that apply.)
A. An automatic module exports all packages to named modules.
B. An automatic module exports only the specified packages to named modules.
C. An automatic module exports no packages to named modules.
D. An unnamed module exports only the named packages to named modules.
E. An unnamed module exports all packages to named modules.
F. An unnamed module exports no packages to named modules.

**An automatic module exports all packages, making option A correct. An unnamed module is not available to any modules on the module path. Therefore, it doesn’t export any packages, and option F is correct.**

---

23. Which is the first line to contain a compiler error?

```java
1: module snake {
	2: exports com.snake.tail;
	3: exports com.snake.fangs to bird;
	4: requires skin;
	5: requires transitive skin;
6: }
```

A. Line 1
B. Line 2
C. Line 3
D. Line 4
E. Line 5
F. The code does not contain any compiler errors.

**The module name is valid, as are the exports statements. Lines 4 and 5 are tricky because each is valid independently. However, the same module name is not allowed to be used in two requires statements. The second one fails to compile on line 5, making option E the answer.**

---

24. Which are true statements about a package in a JAR on the classpath containing a module-info. java file? (Choose all that apply.)
A. It is possible to make the package available to all other modules on the classpath.
B. It is possible to make the package available to all other modules on the module path.
C. It is possible to make the package available to exactly one other specific module on the classpath.
D. It is possible to make the package available to exactly one other specific module on the module path.
E. It is possible to make sure the package is not available to any other modules on the classpath.

**Since the JAR is on the classpath, it is treated as a regular unnamed module even though it has a module-info. java file inside. Remember from learning about top-down migration that modules on the module path are not allowed to refer to the classpath, making options B and D incorrect. The classpath does not have a facility to restrict packages, making option A correct and options C and E incorrect.**

---

25. Suppose you have separate modules for a service provider interface, service provider, service locator, and consumer. Which statements are true about the directives you need to specify? (Choose all that apply.)
A. The consumer must use the requires directive.
B. The consumer must use the uses directive.
C. The service locator must use the requires directive.
D. The service locator must use the uses directive.
E. None of the above

**Options A and C are correct because both the consumer and the service locator depend on the service provider interface. Additionally, option D is correct because the service locator must specify that it uses the service provider interface to look it up.**

---

# Chapter 13 - Concurrency #Chapter 

all operating systems support what is known as *multithreaded processing*. The idea behind multithreaded processing is to allow an application or group of applications to execute multiple tasks at the same time. This allows tasks waiting for other resources to give way to other processing requests.

## Introducing Threads

- ==**A thread is the smallest unit of execution that can be scheduled by the operating system**==
- ==**A process is a group of associated threads that execute in the same shared environment.==**

- It follows, then, that a single-threaded process is one that contains exactly one thread, whereas a multithreaded process supports more than one thread.

- By shared environment, we mean that the threads in the same process share the same memory space and can communicate directly with one another.

- A task is a single unit of work performed by a thread. **==A thread can complete multiple independent tasks but only one task at a time.==**

![[Pasted image 20240520190758.png]]

By shared memory we are generally referring to ``static`` variables as well as instance and local variables passed to a thread.  ``static`` methods and variables are defined on a single class object that all instances share. For example, if one thread updates the value of a ``static`` object, this information is immediately available for other threads within the process to read.
### Understanding Thread Concurrency

==**The property of executing multiple threads and processes at the same time is referred to as concurrency.**==
How does the system decide what to execute when there are more threads available than CPUs? Operating systems use a *thread scheduler* to determine which threads should be currently executing. For example, a thread scheduler may employ a round-robin schedule in which each available thread receives an equal number of CPU cycles with which to execute, with threads visited in a circular order.

---
**The thread scheduler is a part of the operating system that manages the execution of threads. Its main job is to decide which thread should run at any given time, based on factors like thread priority and resource availability. The scheduler ensures that CPU time is efficiently distributed among all running threads, allowing for multitasking and optimal system performance.**

---

When a thread’s allotted time is complete but the thread has not finished processing, a *context switch* occurs. A **==context switch is the process of storing a thread’s current state and later restoring the state of the thread to continue execution==**. Be aware that a cost is often associated with a context switch due to lost time and having to reload a thread’s state. Intelligent thread schedulers do their best to minimize the number of context switches while keeping an application running smoothly.

Finally, a thread can interrupt or supersede another thread if it has a higher thread priority than the other thread. A *thread priority* is a numeric value associated with a thread that is taken into consideration by the thread scheduler when determining which threads should currently be executing. In Java, thread priorities are specified as integer values.

### Creating a Thread

One of the most common ways to define a task for a thread is by using the ``Runnable`` instance. ``Runnable`` is a functional interface that takes no arguments and returns no data.

```java
@FunctionalInterface public interface Runnable {
	void run();
}
```

```java
new Thread(() ->System.out.print("Hello")).start();
System.out.print("World");
```

The first line creates a new ``Thread`` object and then starts it with the ``start()`` method. Does this code print ``HelloWorld`` or ``WorldHello``? The answer is that we don’t know. Depending on the thread priority/scheduler, either is possible. **==Remember that order of thread execution is not often guaranteed.==** The exam commonly presents questions in which multiple tasks are started at the same time, and you must determine the result.

```java
Runnable printRecords = () -> {
	for (int i = 0; i < 3; i++)
	System.out.println("Printing record: " + i);
};
```

Given these instances, what is the output of the following?

```java
3: System.out.println("begin");
4: new Thread(printInventory).start();
5: new Thread(printRecords).start();
6: new Thread(printInventory).start();
7: System.out.println("end");
```

The answer is that it is unknown until runtime. The following is just one possible output:

```java
begin
Printing record: 0
Printing zoo inventory
end
Printing record: 1
Printing zoo inventory
Printing record: 2
```

This sample uses a total of four threads: the ``main()`` user thread and three additional threads created on lines 4–6. Each thread created on these lines is executed as an asynchronous task. By asynchronous, we mean that the thread executing the ``main()`` method does not wait for the results of each newly created thread before continuing. For example, lines 5 and 6 may be executed before the thread created on line 4 finishes. The opposite of this behavior is a synchronous task in which the program waits (or blocks) on line 4 for the thread to finish executing before moving on to the next line

While the order of thread execution is indeterminate once the threads have been started, the order within a single thread is still linear. In particular, the ``for()`` loop is still ordered. Also, ``begin`` always appears before ``end``.

---
**Calling ``run()`` Instead of ``start()``**

**==On the exam, be mindful of code that attempts to start a thread by calling ``run()`` instead of ``start()``. Calling ``run()`` on a ``Thread`` or a ``Runnable`` does not start a new thread==. While the following code snippets will compile, none will execute a task on a separate thread:**

```java
System.out.println("begin");
new Thread(printInventory).run();
new Thread(printRecords).run();
new Thread(printInventory).run();
System.out.println("end");
```

**Unlike the previous example, each line of this code will wait until the ``run()`` method is complete before moving on to the next line. Also unlike the previous program, the output for this code sample will be the same every time it is executed.**

---

More generally, we can create a ``Thread`` and its associated task one of two ways in Java:

-  ==**Provide a ``Runnable`` object or lambda expression to the ``Thread`` constructor.**==
-  ==**Create a class that ``extends`` ``Thread`` and overrides the ``run()`` method.==**

Creating a class that extends ``Thread`` is relatively uncommon and should only be done under certain circumstances, such as if you need to overwrite other thread methods.
### Distinguishing Thread Types

All Java applications are multithreaded because they include system threads. system thread is created by the Java Virtual Machine (JVM) and runs in the background of the application. For example, garbage collection is managed by a system thread created by the JVM. Alternatively, a user-defined thread is one created by the application developer to accomplish a specific task. The majority of the programs we’ve presented so far have contained only one user-defined thread, which calls the ``main()`` method.

System and user-defined threads can both be created as daemon threads. **==A daemon thread is one that will not prevent the JVM from exiting when the program finishes. A Java application terminates when the only threads that are running are daemon threads==**. For example, if garbage collection is the only thread left running, the JVM will automatically shut down.

```java
1: public class Zoo {
	2: public static void pause() { // Defines the thread task
		3: try {
			4: Thread.sleep(10_000); // Wait for 10 seconds
		5: } catch (InterruptedException e) {}
			6: System.out.println("Thread finished!");
		7: }
		8:
		9: public static void main(String[] unused) {
			10: var job = new Thread(() -> pause()); // Create thread
			11:
			12: job.start(); // Start thread
			13: System.out.println("Main method finished!");
	14: } 
}
```

The program will output two statements roughly 10 seconds apart:

```java
Main method finished!
---10 second wait ---
Thread finished!
```

Even though the ``main()`` method is done, the JVM will wait for the user thread to be done before ending the program. What if we change job to be a daemon thread by adding this to line 11?

```java
11: job.setDaemon(true);
```

The program will print the first statement and terminate without ever printing the second line.

```java
Main method finished!
```

**==For the exam, just remember that by default, user-defined threads are not daemons, and the program will wait for them to finish.==**
### Managing a Thread’s Life Cycle

![[Pasted image 20240520194402.png]]

- Every thread is initialized with a ``NEW`` state.
- As soon as ``start()`` is called, the thread is moved to a ``RUNNABLE`` state. Does that mean it is actually running? Not exactly: it may be running, or it may not be. **==The ``RUNNABLE`` state just means the thread is able to be run.==**
- Once the work for the thread is completed or an uncaught exception is thrown, the thread state becomes ``TERMINATED``, and no more work is performed.

**==While in a ``RUNNABLE`` state, the thread may transition to one of three states where it pauses its work: ``BLOCKED``, ``WAITING``, or ``TIMED_WAITING``.==**

### Polling with Sleep

Even though multithreaded programming allows you to execute multiple tasks at the same time, one thread often needs to wait for the results of another thread to proceed. One solution is to use polling. *Polling* is the process of intermittently checking data at some fixed interval.

Let’s say you have a thread that modifies a shared ``static`` counter value, and your ``main()`` thread is waiting for the thread to reach 1 million:

```java
public class CheckResults {
	private static int counter = 0;
	public static void main(String[] args) {
		new Thread(() -> {
			for(int i = 0; i < 1_000_000; i++) counter++;
		}).start();
		while(counter < 1_000_000) {
			System.out.println("Not reached yet");
		}
		System.out.println("Reached: "+counter);
	}
}
```

How many times does this program print ``Not reached yet``? The answer is, we don’t know! It could output 0, 10, or a million times. Using a ``while()`` loop to check for data without some kind of delay is considered a bad coding practice as it ties up CPU resources for no reason.

We can improve this result by using the ``Thread.sleep()`` method to implement polling and sleep for 1,000 milliseconds, aka 1 second:

```java
public class CheckResultsWithSleep {
    private static int counter = 0;

    public static void main(String[] a) {
        new Thread(() -> {
            for (int i = 0; i < 1_000_000; i++) counter++;
        }).start();

        while (counter < 1_000_000) {
            System.out.println("Not reached yet");
            try {
                Thread.sleep(1_000); // 1 SECOND
            } catch (InterruptedException e) {
                System.out.println("Interrupted!");
            }
        }

        System.out.println("Reached: " + counter);
    }
}
```

While one second may seem like a small amount, we have now freed the CPU to do other work instead of checking the counter variable infinitely within a loop. Notice that the ``main()`` thread alternates between ``TIMED_WAITING`` and ``RUNNABLE`` when ``sleep()`` is entered and exited, respectively.

How many times does the ``while()`` loop execute in this revised class? Still unknown! **==While polling does prevent the CPU from being overwhelmed with a potentially infinite loop, it does not guarantee when the loop will terminate==**. For example, the separate thread could be losing CPU time to a higher-priority process, resulting in multiple executions of the ``while()`` loop before it finishes.

Another issue to be concerned about is the shared counter variable. What if one thread is reading the counter variable while another thread is writing it? The thread reading the shared variable may end up with an invalid or unexpected value.

### Interrupting a Thread

While our previous solution prevented the CPU from waiting endlessly on a ``while()`` loop, it did come at the cost of inserting one-second delays into our program. If the task takes 2.1 seconds to run, the program will use the full 3 seconds, wasting 0.9 seconds. One way to improve this program is to allow the thread to interrupt the ``main()`` thread when it’s done:

```java
public class CheckResultsWithSleepAndInterrupt {
    private static int counter = 0;

    public static void main(String[] a) {
        final var mainThread = Thread.currentThread();
        
        new Thread(() -> {
            for (int i = 0; i < 1_000_000; i++) counter++;
            mainThread.interrupt();
        }).start();

        while (counter < 1_000_000) {
            System.out.println("Not reached yet");
            try {
                Thread.sleep(1_000); // 1 SECOND
            } catch (InterruptedException e) {
                System.out.println("Interrupted!");
            }
        }

        System.out.println("Reached: " + counter);
    }
}
```

This improved version includes both ``sleep()``, to avoid tying up the CPU, and ``interrupt()``, so the thread’s work ends without delaying the program. As before, our ``main()`` thread’s state alternates between ``TIMED_WAITING`` and ``RUNNABLE``. **==Calling ``interrupt()`` on a thread in the ``TIMED_WAITING`` or ``WAITING`` state causes the ``main()`` thread to become ``RUNNABLE`` again, triggering an ``InterruptedException``.==** The thread may also move to a ``BLOCKED`` state if it needs to reacquire resources when it wakes up.

---
**Calling ``interrupt()`` on a thread already in a ``RUNNABLE`` state doesn’t change the state. In fact, it only changes the behavior if the thread is periodically checking the ``Thread.isInterrupted()`` value state.**

---
## Creating Threads with the Concurrency API

The Concurrency API includes the ``ExecutorService`` interface, which defines services that create and manage threads.  first obtain an instance of an ``ExecutorService`` interface, and then you send the service tasks to be processed. The framework includes numerous useful features, such as thread pooling and scheduling. It is recommended that you use this framework any time you need to create and execute a separate task, even if you need only a single thread.

---

**When writing multithreaded programs in practice, it is often better to use the ``Concurrency API`` (or some other multithreaded SDK) rather than work with Thread objects directly. The libraries are much more robust, and it is easier to handle complex interactions.** #TIP 

---

### Introducing the Single-Thread Executor

Since ``ExecutorService`` is an interface, how do you obtain an instance of it? The Concurrency API includes the Executors factory class that can be used to create instances of the ``ExecutorService`` object.

```java
ExecutorService service = Executors.newSingleThreadExecutor();
try {
	System.out.println("begin");
	service.execute(printInventory);
	service.execute(printRecords);
	service.execute(printInventory);
	System.out.println("end");
} finally {
	service.shutdown();
}
```

Unlike our earlier example, in which we had four threads (one ``main()`` and three new threads), we have only two threads (one ``main()`` and one new thread). This means that the output, while still unpredictable, will have less variation than before

```text
Printing zoo inventory
Printing record: 0
Printing record: 1
end
Printing record: 2
Printing zoo inventory
```

Notice that the ``printRecords`` loop is no longer interrupted by other Runnable tasks sent to the thread executor. With a single-thread executor, tasks are guaranteed to be executed sequentially. Notice that the end text is output while our thread executor tasks are still running. This is because **==the ``main()`` method is still an independent thread from the ``ExecutorService``==**

### Shutting Down a Thread Executor

Once you have finished using a thread executor, it is important that you call the ``shutdown()`` method. **==A thread executor creates a non-daemon thread on the first task that is executed, so failing to call ``shutdown()`` will result in your application never terminating==**.

**==The shutdown process for a thread executor involves first rejecting any new tasks submitted to the thread executor while continuing to execute any previously submitted tasks. During this time, calling ``isShutdown()`` will return true, while ``isTerminated()`` will return false.==** If a new task is submitted to the thread executor while it is shutting down, a ``RejectedExecutionException`` will be thrown. **==Once all active tasks have been completed, ``isShutdown()`` and ``isTerminated()`` will both return true.==**

![[Pasted image 20240520201451.png]]

**==For the exam, you should be aware that ``shutdown()`` does not stop any tasks that have already been submitted to the thread executor.==**

What if you want to cancel all running and upcoming tasks? The ``ExecutorService`` provides a method called ``shutdownNow()``, which attempts to stop all running tasks and discards any that have not been started yet. It is not guaranteed to succeed because it is possible to create a thread that will never terminate, so any attempt to interrupt it may be ignored.

---

**Unfortunately, the ``ExecutorService`` interface does not extend the ``AutoCloseable`` interface, so you cannot use a try-with- resources statement. You can still use a ``finally`` block, While you are not required to use a ``finally`` block, it is considered a good practice to do so.** #TIP 

---

### Submitting Tasks

can submit tasks to an ``ExecutorService`` instance multiple ways

- **==The first method we presented, ``execute()``, is inherited from the ``Executor`` interface, which the ``ExecutorService`` interface extends. The ``execute()`` method takes a ``Runnable`` instance and completes the task asynchronously. Because the return type of the method is ``void``==**, it does not tell us anything about the result of the task. It is considered a *“fire-and- forget”* method, as once it is submitted, the results are not directly available to the calling thread.
- Fortunately, the writers of Java added ``submit()`` methods to the ``ExecutorService`` interface, which, like ``execute()``, can be used to complete tasks asynchronously. **==Unlike ``execute()``, though, ``submit()`` returns a ``Future`` instance that can be used to determine whether the task is complete. It can also be used to return a generic result object after the task has been completed.==**

**==In practice, using the ``submit()`` method is quite similar to using the ``execute()`` method, except that the ``submit()`` method returns a Future ``instance`` that can be used to determine whether the task has completed execution.==**

![[Pasted image 20240520202540.png]]

---
**Submitting Tasks: ``execute()`` vs. ``submit()``**
 
 **the ``execute()`` and ``submit()`` methods are nearly identical when applied to Runnable expressions. The ``submit()`` method has the obvious advantage of doing the same thing ``execute()`` does, but with a return object that can be used to track the result. Because of this advantage and the fact that ``execute()`` does not support Callable expressions, we tend to prefer ``submit()`` over execute(), even if we don’t store the Future reference.**

**For the exam, you need to be familiar with both ``execute()`` and ``submit()``, but in your own code we recommend ``submit()`` over ``execute()`` whenever possible.**

---
### Waiting for Results

How do we know when a task submitted to an ``ExecutorService`` is complete?

```java
Future<?> future = service.submit(() -> System.out.println("Hello"));
```

The ``Future`` type is actually an interface. For the exam, you don’t need to know any of the classes that implement ``Future``, just that a ``Future`` instance is returned by various API methods.

![[Pasted image 20240520203811.png]]

```java
import java.util.concurrent.*;

public class CheckResults {
    private static int counter = 0;

    public static void main(String[] unused) throws Exception {
        ExecutorService service = Executors.newSingleThreadExecutor();
        try {
            Future<?> result = service.submit(() -> {
                for (int i = 0; i < 1_000_000; i++) counter++;
            });
            result.get(10, TimeUnit.SECONDS); // Returns null for Runnable
            System.out.println("Reached!");
        } catch (TimeoutException e) {
            System.out.println("Not reached in time");
        } finally {
            service.shutdown();
        }
    }
}
```

This example is similar to our earlier polling implementation, but it does not use the ``Thread`` class directly. In part, this is the essence of the Concurrency API: to do complex things with threads without having to manage threads directly. It also waits at most 10 seconds, throwing a ``TimeoutException`` on the call to ``result.get()`` if the task is not done.

What is the return value of this task? As ``Future<V>`` is a generic interface, the type ``V`` is determined by the return type of the ``Runnable`` method. Since the return type of ``Runnable.run()`` is ``void``, the ``get()`` method always returns ``null`` when working with ``Runnable`` expressions.

The ``Future.get()`` method can take an optional value and enum type ``java.util.concurrent.TimeUnit``.

![[Pasted image 20240520204145.png]]

#### Introducing Callable

The ``java.util.concurrent.Callable`` functional interface is similar to ``Runnable`` except that its ``call()`` method returns a value and can throw a checked exception.

```java
@FunctionalInterface public interface Callable<V> {
	V call() throws Exception;
}
```

The ``Callable`` interface is often preferable over ``Runnable``, since it allows more details to be retrieved easily from the task after it is completed. as they are interchangeable in situations where the lambda does not
throw an exception, and there is no return type. Luckily, the ``ExecutorService`` includes an overloaded version of the ``submit()`` method that takes a ``Callable`` object and returns a generic ``Future<T>`` instance.

**==Unlike ``Runnable``, in which the ``get()`` methods always return ``null``, the ``get()`` methods on a ``Future`` instance return the matching generic type (which could also be a ``null`` value).==**

```java
var service = Executors.newSingleThreadExecutor();
try {
	Future<Integer> result = service.submit(() -> 30 + 11);
	System.out.println(result.get()); // 41
} finally {
	service.shutdown();
}
```

We could rewrite this example using ``Runnable``, some shared object, and an ``interrupt()`` or timed wait, but this implementation is a lot easier to code and understand. In essence, that’s the spirit of the Concurrency API, giving you the tools to write multithreaded code that is thread-safe, performant, and easy to follow.
#### Waiting for All Tasks to Finish

After submitting a set of tasks to a thread executor, it is common to wait for the results. One solution is to call ``get()`` on each ``Future`` object returned by the ``submit()`` method. If we don’t need the results of the tasks and are finished using our thread executor, there is a simpler approach.

First, we shut down the thread executor using the ``shutdown()`` method. Next, we use the ``awaitTermination()`` method available for all thread executors. The method waits the specified time to complete all tasks, returning sooner if all tasks finish or an ``InterruptedException`` is detected.

```java
ExecutorService service = Executors.newSingleThreadExecutor();
try {
// Add tasks to the thread executor
...
} finally {
	service.shutdown();
}
service.awaitTermination(1, TimeUnit.MINUTES);
// Check whether all tasks are finished
if(service.isTerminated()) System.out.println("Finished!");
else System.out.println("At least one task is still running");
```
### Scheduling Tasks

``ScheduledExecutorService``, which is a subinterface of ``ExecutorService``, can be used for just such a task. Like ``ExecutorService``, we obtain an instance of ``ScheduledExecutorService`` using a factory method in the ``Executors`` class,

```java
ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
```

We could store an instance of ``ScheduledExecutorService`` in an ``ExecutorService`` variable, although doing so would mean we’d have to cast the object to call any scheduling methods.

![[Pasted image 20240520205307.png]]

In practice, these methods are among the most convenient in the Concurrency API, as they perform relatively complex tasks with a single line of code. The delay and period parameters rely on the ``TimeUnit`` argument to determine the format of the value, such as seconds or milliseconds.

The first two ``schedule()`` methods in Table 13.4 take a ``Callable`` or ``Runnable``, respectively; perform the task after some delay; and return a ``ScheduledFuture`` instance. The ``ScheduledFuture`` interface is identical to the ``Future`` interface, except that it includes a ``getDelay()`` method that returns the remaining delay

```java
ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
Runnable task1 = () -> System.out.println("Hello Zoo");
Callable<String> task2 = () -> "Monkey";
ScheduledFuture<?> r1 = service.schedule(task1, 10, TimeUnit.SECONDS);
ScheduledFuture<?> r2 = service.schedule(task2, 8, TimeUnit.MINUTES)
```

---

**While these tasks are scheduled in the future, the actual execution may be delayed. For example, there may be no threads available to perform the tasks, at which point they will just wait in the queue. Also, if the ``ScheduledExecutorService`` is shut down by the time the scheduled task execution time is reached, then these tasks will be discarded.**

---

The last two methods Conceptually, they are similar as they both perform the same task repeatedly after
an initial delay. **==The difference is related to the timing of the process and when the next task starts==**.

**==The ``scheduleAtFixedRate()`` method creates a new task and submits it to the executor every period, regardless of whether the previous task finished==**.

```java
service.scheduleAtFixedRate(command, 5, 1, TimeUnit.MINUTES);
```

The ``scheduleAtFixedRate()`` method is useful for tasks that need to be run at specific intervals, such as checking the health of the animals once a day. Even if it takes two hours to examine an animal on Monday, this doesn’t mean that Tuesday’s exam should start any later in the day.

---

**Bad things can happen with ``scheduleAtFixedRate()`` if each task consistently takes longer to run than the execution interval. Imagine if your boss came by your desk every minute and dropped off a piece of paper. Now imagine that it took you five minutes to read each piece of paper. Before long, you would be drowning in piles of paper. This is how an executor feels. Given enough time, the program would submit more tasks to the executor service than could fit in memory, causing the program to crash.**

---

**==On the other hand, the ``scheduleWithFixedDelay()`` method creates a new task only after the previous task has finished==**

```java
service.scheduleWithFixedDelay(task1, 0, 2, TimeUnit.MINUTES);
```

The ``scheduleWithFixedDelay()`` method is useful for processes that you want to happen repeatedly but whose specific time is unimportant.

### Increasing Concurrency with Pools

**==A thread pool is a group of pre-instantiated reusable threads that are available to perform a set of arbitrary tasks.==**

![[Pasted image 20240520210646.png]]

**==The difference between a single-thread and a pooled-thread executor is what happens when a task is already running. While a single-thread executor will wait for the thread to become available before running the next task, a pooled-thread executor can execute the next task concurrently. If the pool runs out of available threads, the task will be queued by the thread executor and wait to be completed.==**

## Writing Thread-Safe Code

Thread-safety is the property of an object that guarantees safe execution by multiple threads at the same time.

### Understanding Thread-Safety

```java
1: import java.util.concurrent.*;
2: public class SheepManager {
	3: private int sheepCount = 0;
	4: private void incrementAndReport() {
		5: System.out.print((++sheepCount)+" ");
	6: }
	7: public static void main(String[] args) {
			8: ExecutorService service = Executors.newFixedThreadPool(20);
		9: try {
			10: SheepManager manager = new SheepManager();
		11: for(int i = 0; i < 10; i++)
			12: service.submit(() -> manager.incrementAndReport());
		13: } finally {
			14: service.shutdown();
		15: } 
	} 
}
```

What does this program output? The following are possible outputs of this program:

```TEXT
1 2 3 4 5 6 7 8 9 10
1 9 8 7 3 6 6 2 4 5
1 8 7 3 2 6 5 4 2 9
```

A problem occurs when two threads both execute the right side of the expression, reading the “old” value before either thread writes the “new” value of the variable. The two assignments become redundant; they both assign the same new value, with one thread overwriting the results of the other.

![[Pasted image 20240521195628.png]]

both threads read and write the same values, causing one of the two ``++sheepCount`` operations to be lost. Therefore, the increment operator ``++`` is not thread-safe. the unexpected result of two tasks executing at the same time is referred to as a ``race condition``.
### Accessing Data with ``volatile``

The ``volatile`` keyword is used to guarantee that access to data within memory is consistent.

**==The ``volatile`` attribute ensures that only one thread is modifying a variable at one time and that data read among multiple threads is consistent.==** In this manner, we don’t interrupt one of our zoo workers in the middle of running. So, does ``volatile`` provide thread-safety? Not exactly.

```java
3: private volatile int sheepCount = 0;
4: private void incrementAndReport() {
	5: System.out.print((++sheepCount)+" ");
6: }
```

this code is not thread-safe and could still result in numbers being missed:

```text
2 6 1 7 5 3 2 9 4 8
```

The reason this code is not thread-safe is that ``++sheepCount`` is still two distinct operations. Put another way, if the increment operator represents the expression ``sheepCount = sheepCount + 1``, then each read and write operation is thread-safe, but the combined operation is not.

---

**In practice, ``volatile`` is rarely used.**

---
### Protecting Data with Atomic Classes

the increment operator ``++`` is not thread-safe, even when ``volatile`` is used. It is not thread-safe because the operation is not atomic, carrying out two tasks, read and write, that can be interrupted by other threads.

**==Atomic is the property of an operation to be carried out as a single unit of execution without any interference from another thread==**. A thread-safe atomic version of the increment operator would perform the read and write of the variable as a single operation, not allowing any other threads to access the variable during the operation

In this case, any thread trying to access the ``sheepCount`` variable while an atomic operation is in process will have to wait until the atomic operation on the variable is complete. Conceptually, this is like setting a rule for our zoo workers that there can be only one employee in the field at a time, although they may not each report their results in order.

![[Pasted image 20240521202306.png]]

Since accessing primitives and references is common in Java, the Concurrency API includes numerous useful classes in the ``java.util.concurrent.atomic`` package.

![[Pasted image 20240521202335.png]]

```java
3: private AtomicInteger sheepCount = new AtomicInteger(0);
4: private void incrementAndReport() {
	5: System.out.print(sheepCount.incrementAndGet()+" ");
6: }
```

![[Pasted image 20240521202637.png]]

```java
2 3 1 4 5 6 7 8 9 10
1 4 3 2 5 6 7 8 9 10
1 4 3 5 6 2 7 8 10 9
```

Unlike our previous sample output, the numbers 1 through 10 will always be printed, although the order is still not guaranteed. The key in this section is that using the atomic classes ensures that the data is consistent between workers and that no values are lost due to concurrent modifications.
### Improving Access with ``synchronized`` Blocks

While atomic classes are great at protecting a single variable, they aren’t particularly useful if you need to execute a series of commands or call a method.

**==The most common technique is to use a monitor to synchronize access. A monitor, also called a lock, is a structure that supports mutual exclusion, which is the property that at most one thread is executing a particular segment of code at a given time.==** In Java, any ``Object`` can be used as a monitor, along with the ``synchronized`` keyword,

```java
var manager = new SheepManager();
synchronized(manager) {
	// Work to be completed by one thread at a time
}
```

This example is referred to as a *synchronized block*. Each thread that arrives will first check if any threads are already running the block. If the lock is not available, the thread will transition to a ``BLOCKED`` state until it can “acquire the lock.” If the lock is available (or the thread already holds the lock), the single thread will enter the block, preventing all other threads from entering. Once the thread finishes executing the block, it will release the lock, allowing one of the waiting threads to proceed.

---

**==To synchronize access across multiple threads, each thread must have access to the same ``Object``. If each thread synchronizes on different objects, the code is not thread-safe.==**

---

```java
11: for(int i = 0; i < 10; i++) {
	12: synchronized(manager) {
		13: service.submit(() -> manager.incrementAndReport());
	14: }
15: }
```

Does this solution fix the problem? No, it does not! We’ve synchronized the creation of the threads but not the execution of the threads. In this example, the threads would be created one at a time, but they might all still execute and perform their work simultaneously, resulting in the same type of output

```java
1: import java.util.concurrent.*;
2: public class SheepManager {
	3: private int sheepCount = 0;
	4: private void incrementAndReport() {
		5: synchronized(this) {
			6: System.out.print((++sheepCount)+" ");
		7: }
	8: }
	
	9: public static void main(String[] args) {
		10: ExecutorService service = Executors.newFixedThreadPool(20);
		11: try {
			12: var manager = new SheepManager();
		13: for(int i = 0; i < 10; i++)
			14: service.submit(() -> manager.incrementAndReport());
		15: } finally {
			16: service.shutdown();
		17: } 
	} 
}
```

Although all threads are still created and executed at the same time, they each wait at the synchronized block for the worker to increment and report the result before entering. While it’s random which zoo worker will run out next, it is guaranteed that there will be at most one on the field and that the results will be reported in order. We could have synchronized on any object, as long as it was the same object.

```java
4: private final Object herd = new Object();
5: private void incrementAndReport() {
	6: synchronized(herd) {
		7: System.out.print((++sheepCount)+" ");
	8: }
9: }
```

we didn’t need to make the ``herd`` variable ``final``, doing so ensures that it is not reassigned after threads start using it.

#### Synchronizing on Methods

Java provides a more convenient compiler enhancement for doing so. We can add the synchronized modifier to any instance method to synchronize automatically on the object itself.

```java
void sing() {
	synchronized(this) {
		System.out.print("La la la!");
	}
}
synchronized void sing() {
	System.out.print("La la la!");
}
```

The first uses a ``synchronized`` block, whereas the second uses the ``synchronized`` method modifier

We can also apply the ``synchronized`` modifier to ``static`` methods. **==What object is used as the monitor when we synchronize on a ``static`` method? The class object, of course!==**

```java
static void dance() {
	synchronized(SheepManager.class) {
		System.out.print("Time to dance!");
	}
}
static synchronized void dance() {
	System.out.print("Time to dance!");
}
```

You can use ``static`` synchronization if you need to order thread access across all instances rather than a single instance.
### Understanding the Lock Framework

A ``synchronized`` block supports only a limited set of functionality. For example, what if we want to check whether a lock is available and, if it is not, perform some other task? Furthermore, if the lock is never available and we synchronize on it, we might wait forever.

The Concurrency API includes the ``Lock`` interface, which is conceptually similar to using the ``synchronized`` keyword but with a lot more bells and whistles. **==Instead of synchronizing on any ``Object``, though, we can “lock” only on an object that implements the ``Lock`` interface.==**
#### Applying a ``ReentrantLock``

When you need to protect a piece of code from multithreaded processing, create an instance of ``Lock`` that all threads have access to. Each thread then calls ``lock()`` before it enters the protected code and calls ``unlock()`` before it exits the protected code.

For contrast, the following shows two implementations, one with a ``synchronized`` block and one with a ``Lock`` instance. While longer, the Lock solution has a number of features not available to the ``synchronized`` block.

```java
// Implementation #1 with a synchronized block
Object object = new Object();
synchronized(object) {
	// Protected code
}

// Implementation #2 with a Lock
Lock lock = new ReentrantLock();
try {
	lock.lock();
	// Protected code
} finally {
	lock.unlock();
}
```

These two implementations are conceptually equivalent. The ``ReentrantLock`` class is a simple monitor that implements the ``Lock`` interface and supports mutual exclusion. In other words, at most one thread is allowed to hold a lock at any given time.

---

**==While certainly not required, it is a good practice to use a ``try/finally`` block with ``Lock`` instances. Doing so ensures that any acquired locks are properly released.==** #TIP 

---

The ``ReentrantLock`` class ensures that once a thread has called ``lock()`` and obtained the lock, all other threads that call ``lock()`` will wait until the first thread calls ``unlock()``. Which thread gets the lock next depends on the parameters used to create the ``Lock`` object.

The ``ReentrantLock`` class includes a constructor that takes a single ``boolean`` and sets a “fairness” parameter. If the parameter is set to ``true``, the lock will usually be granted to each thread in the order in which it was requested. It is ``false`` by default when using the no-argument constructor. In practice, you should enable fairness only when ordering is absolutely required, as it could lead to a significant slowdown.

```java
Lock lock = new ReentrantLock();
lock.unlock(); // IllegalMonitorStateException
```

#### Attempting to Acquire a Lock

While the ``ReentrantLock`` class allows you to wait for a lock, it so far suffers from the same problem as a synchronized block. A thread could end up waiting forever to obtain a lock.

![[Pasted image 20240521205159.png]]

```java
public static void printHello(Lock lock) {
	try {
		lock.lock();
		System.out.println("Hello");
	} finally {
		lock.unlock();
	} 
}
```

##### ``tryLock()``

The ``tryLock()`` method will attempt to acquire a lock and immediately return a boolean result indicating whether the lock was obtained. Unlike the ``lock()`` method, it does not wait if another thread already holds the lock. It returns immediately, regardless of whether a lock is available.

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class LockExample {
    public static void main(String[] args) {
        Lock lock = new ReentrantLock();
        
        new Thread(() -> printHello(lock)).start();
        
        if (lock.tryLock()) {
            try {
                System.out.println("Lock obtained, entering protected code");
            } finally {
                lock.unlock();
            }
        } else {
            System.out.println("Unable to acquire lock, doing something else");
        }
    }
}
```

When you run this code, it could produce either the if or else message, depending on the order of execution. It will always print Hello, though, as the call to lock() in ``printHello()`` will wait indefinitely for the lock to become available.

Like ``lock()``, the ``tryLock()`` method should be used with a ``try/finally`` block. Fortunately, you need to release the lock only if it was successfully acquired. For this reason, it is common to use the output of ``tryLock()`` in an if statement, so that ``unlock()`` is called only when the lock is obtained.

---

**It is imperative that your program always check the return value of the ``tryLock()`` method. It tells your program whether it is safe to proceed with the operation and whether the lock needs to be released later.**

---
##### ``tryLock(long,TimeUnit)``

The ``Lock`` interface includes an overloaded version of ``tryLock(long,TimeUnit)`` that acts like a hybrid of ``lock()`` and ``tryLock()``. Like the other two methods, if a lock is available, it will immediately return with it. If a lock is unavailable, though, it will wait up to the specified time limit for the lock.

```java
Lock lock = new ReentrantLock();
new Thread(() -> printHello(lock)).start();
if(lock.tryLock(10,TimeUnit.SECONDS)) {
	try {
		System.out.println("Lock obtained, entering protected code");
	} finally {
		lock.unlock();
	}
} else {
	System.out.println("Unable to acquire lock, doing something else");
}
```

##### Acquiring the Same Lock Twice

The ``ReentrantLock`` class maintains a counter of the number of times a lock has been successfully granted to a thread. **==To release the lock for other threads to use, ``unlock()`` must be called the same number of times the lock was granted==**

```java
Lock lock = new ReentrantLock();
if(lock.tryLock()) {
	try {
		lock.lock();
		System.out.println("Lock obtained, entering protected code");
	} finally {
		lock.unlock();
	}
}
```

The thread obtains the lock twice but releases it only once. You can verify this by spawning a new thread after this code runs that attempts to obtain a lock. The following prints ``false``:

```java
new Thread(() -> System.out.print(lock.tryLock())).start(); // false
```

==**It is critical that you release a lock the same number of times it is acquired! For calls with ``tryLock()``, you need to call ``unlock()`` only if the method returned true.**==

#### Reviewing the ``Lock`` Framework

the ``ReentrantLock`` class supports the same features as a synchronized block while adding a number of improvements:

- ==**Ability to request a lock without blocking.**==
- ==**Ability to request a lock while blocking for a specified amount of time.**==
- ==**A lock can be created with a fairness property, in which the lock is granted to threads in the order in which it was requested.**==

### Orchestrating Tasks with a ``CyclicBarrier``

How to orchestrate complex tasks with many steps. To coordinate these tasks, we can use the ``CyclicBarrier`` class:

```java
import java.util.concurrent.*;

public class LionPenManager {
    private void removeLions() { 
        System.out.println("Removing lions"); 
    }

    private void cleanPen() { 
        System.out.println("Cleaning the pen"); 
    }

    private void addLions() { 
        System.out.println("Adding lions"); 
    }

    public void performTask() {
        removeLions();
        cleanPen();
        addLions();
    }

    public static void main(String[] args) {
        var service = Executors.newFixedThreadPool(4);
        try {
            var manager = new LionPenManager();
            for (int i = 0; i < 4; i++)
                service.submit(() -> manager.performTask());
        } finally {
            service.shutdown();
        }
    }
}
```

```text
Removing lions
Removing lions
Cleaning the pen
Adding lions
Removing lions
Cleaning the pen
Adding lions
Removing lions
Cleaning the pen
Adding lions
Cleaning the pen
Adding lions
```

Although the results are ordered within a single thread, the output is entirely random among multiple workers
 
 We can improve these results by using the ``CyclicBarrier`` class. The ``CyclicBarrier`` takes in its constructors a limit value, indicating the number of threads to wait for. As each thread finishes, it calls the ``await()`` method on the cyclic barrier. Once the specified number of threads have each called ``await()``, the barrier is released, and all threads can continue.

```java
import java.util.concurrent.*;

public class LionPenManager {
    private void removeLions() { 
        System.out.println("Removing lions"); 
    }

    private void cleanPen() { 
        System.out.println("Cleaning the pen"); 
    }

    private void addLions() { 
        System.out.println("Adding lions"); 
    }

    public void performTask(CyclicBarrier c1, CyclicBarrier c2) {
        try {
            removeLions();
            c1.await();
            cleanPen();
            c2.await();
            addLions();
        } catch (InterruptedException | BrokenBarrierException e) {
            // Handle checked exceptions here
        }
    }

    public static void main(String[] args) {
        var service = Executors.newFixedThreadPool(4);
        try {
            var manager = new LionPenManager();
            var c1 = new CyclicBarrier(4);
            var c2 = new CyclicBarrier(4, () -> System.out.println("*** Pen Cleaned!"));
            for (int i = 0; i < 4; i++)
                service.submit(() -> manager.performTask(c1, c2));
        } finally {
            service.shutdown();
        }
    }
}
```

```text
Removing lions
Removing lions
Removing lions
Removing lions
Cleaning the pen
Cleaning the pen
Cleaning the pen
Cleaning the pen
*** Pen Cleaned!
Adding lions
Adding lions
Adding lions
Adding lions
```

The ``CyclicBarrier`` class allows us to perform complex, multithreaded tasks while all threads stop and wait at logical barriers. This solution is superior to a single-threaded solution, as the individual tasks, such as removing the lions, can be completed in parallel by all four zoo workers.

---

**Reusing ``CyclicBarrier``**

**After a ``CyclicBarrier`` limit is reached (aka the barrier is broken), all threads are released, and the number of threads waiting on the ``CyclicBarrier`` goes back to zero. At this point, the ``CyclicBarrier`` may be used again for a new set of waiting threads. For example, if our ``CyclicBarrier`` limit is 5 and we have 15 threads that call await(), the ``CyclicBarrier`` will be activated a total of three times.**

---

## Using Concurrent Collections

### Understanding Memory Consistency Errors

The purpose of the concurrent collection classes is to solve common memory consistency errors. **==A memory consistency error occurs when two threads have inconsistent views of what should be the same data==**. Conceptually, we want writes on one thread to be available to another thread if it accesses the concurrent collection after the write has occurred.
When two threads try to modify the same nonconcurrent collection, the JVM may throw a ``ConcurrentModificationException`` at runtime. In fact, it can happen with a single thread.

```java
11: var foodData = new HashMap<String, Integer>();
12: foodData.put("penguin", 1);
13: foodData.put("flamingo", 2);
14: for(String key: foodData.keySet())
15: foodData.remove(key);
```

This snippet will throw a ``ConcurrentModificationException`` during the second iteration of the loop, since the iterator on ``keySet()`` is not properly updated after the first element is removed. Changing the first line to use a ``ConcurrentHashMap`` will prevent the code from throwing an exception at runtime.

```java
11: var foodData = new ConcurrentHashMap<String, Integer>();
```

The concurrent classes were created to help avoid common issues in which multiple threads are adding and removing objects from the same collections. At any given instance, all threads should have the same consistent view of the structure of the collection.

### Working with Concurrent Classes

You should use a concurrent collection class any time you have multiple threads modify a collection outside a synchronized block or method, even if you don’t expect a concurrency problem. Without the concurrent collections, multiple threads accessing a collection could result in an exception being thrown or, worse, corrupt data!

---

**If the collection is immutable (and contains immutable objects), the concurrent collections are not necessary. Immutable objects can be accessed by any number of threads and do not require synchronization. By definition, they do not change, so there is no chance of a memory consistency error.**

---

When passing around a concurrent collection, a caller may need to know the particular implementation class. That said, it is considered a good practice to pass around a nonconcurrent interface reference when possible, similar to how we instantiate a ``HashMap`` but often pass around a ``Map`` reference:

```java
Map<String,Integer> map = new ConcurrentHashMap<>();
```

![[Pasted image 20240523201341.png]]

For the exam, you don’t need to know any class-specific concurrent methods. You just need to know the inherited methods, such as ``get()`` and ``set()`` for List instances.
 
 The ``Skip`` classes might sound strange, but they are just “sorted” versions of the associated concurrent collections. **==When you see a class with ``Skip`` in the name, just think “sorted concurrent” collections, and the rest should follow naturally.==**

The ``CopyOnWrite`` classes behave a little differently than the other concurrent examples you have seen. These classes create a copy of the collection any time a reference is added, removed, or changed in the collection and then update the original collection reference to point to the copy. These classes are commonly used to ensure an iterator doesn’t see modifications to the collection.

```java
List<Integer> favNumbers = new CopyOnWriteArrayList<>(List.of(4, 3, 42));
for (var n : favNumbers) {
	System.out.print(n + " "); // 4 3 42
	favNumbers.add(n+1);
	System.out.println();
	System.out.println("Size: " + favNumbers.size()); // Size: 6
}
```
 
 Despite adding elements, the iterator is not modified, and the loop executes exactly three times. Alternatively, if we had used a regular ``ArrayList`` object, a ``ConcurrentModificationException`` would have been thrown at runtime.  **==``CopyOnWrite`` classes can use a lot of memory, since a new collection structure is created any time the collection is modified. Therefore, they are commonly used in multithreaded environment situations where reads are far more common than writes==**

### Obtaining Synchronized Collections

Concurrency API also includes methods for obtaining synchronized versions of existing nonconcurrent collection objects. These synchronized methods are defined in the ``Collections`` class. They operate on the inputted collection and return a reference that is the same type as the underlying collection.

![[Pasted image 20240523202602.png]]

## Identifying Threading Problems

A threading problem can occur in multithreaded applications when two or more threads interact in an unexpected and undesirable way.
Although the Concurrency API reduces the potential for threading issues, it does not eliminate them. In practice, finding and identifying threading issues within an application is often one of the most difficult tasks a developer can undertake.

### Understanding Liveness

many thread operations can be performed independently, but some require coordination. For example, synchronizing on a method requires all threads that call the method to wait for other threads to finish before continuing.

What happens to the application while all of these threads are waiting? In many cases, the waiting is ephemeral, and the user has very little idea that any delay has occurred. In other cases, though, the waiting may be extremely long, perhaps infinite.

Liveness is the ability of an application to be able to execute in a timely manner. Liveness problems, then, are those in which the application becomes unresponsive or is in some kind of “stuck” state. **==More precisely, liveness problems are often the result of a thread entering a ``BLOCKING`` or ``WAITING`` state forever, or repeatedly entering/exiting these states==**. For the exam, there are three types of liveness issues with which you should be familiar: deadlock, starvation, and livelock.

#### Deadlock

*Deadlock* occurs when two or more threads are blocked forever, each waiting on the other.

```java
import java.util.concurrent.*;

class Food {}
class Water {}

public record Fox(String name) {
    public void eatAndDrink(Food food, Water water) {
        synchronized (food) {
            System.out.println(name() + " Got Food!");
            move();
            synchronized (water) {
                System.out.println(name() + " Got Water!");
            }
        }
    }

    public void drinkAndEat(Food food, Water water) {
        synchronized (water) {
            System.out.println(name() + " Got Water!");
            move();
            synchronized (food) {
                System.out.println(name() + " Got Food!");
            }
        }
    }

    public void move() {
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    public static void main(String[] args) {
        // Create participants and resources
        var foxy = new Fox("Foxy");
        var tails = new Fox("Tails");
        var food = new Food();
        var water = new Water();

        // Process data
        var service = Executors.newScheduledThreadPool(10);
        try {
            service.submit(() -> foxy.eatAndDrink(food, water));
            service.submit(() -> tails.drinkAndEat(food, water));
        } finally {
            service.shutdown();
        }
    }
}
```

In this example, ``Foxy`` obtains the food and then moves to the other side of the environment to obtain the water. Unfortunately, ``Tails`` already drank the water and is waiting for the food to become available. The result is that our program outputs the following, and it hangs indefinitely:

```text
Foxy Got Food!
Tails Got Water!
```

This example is considered a deadlock because both participants are permanently blocked, waiting on resources that will never become available.
#### Starvation
 
 *Starvation* occurs when a single thread is perpetually denied access to a shared resource or lock. **==The thread is still active, but it is unable to complete its work as a result of other threads constantly taking the resource that it is trying to access==**.

#### Livelock

*Livelock* occurs when two or more threads are conceptually blocked forever, although they are each still active and trying to complete their task. **==Livelock is a special case of resource starvation in which two or more threads actively try to acquire a set of locks, are unable to do so, and restart part of the process==**.
Livelock is often a result of two threads trying to resolve a deadlock. In practice, livelock is often a difficult issue to detect. Threads in a livelock state appear active and able to respond to requests, even when they are stuck in an endless cycle.

### Managing Race Conditions

A race condition is an undesirable result that occurs when two tasks that should be completed sequentially are completed at the same time.

![[Pasted image 20240523204408.png]]

What result does the web server return when both users attempt to create an account with the same username in Figure 13.6?

**Possible Outcomes for This Race Condition**
-  Both users are able to create accounts with the username ``ZooFan``.
-  Neither user is able to create an account with the username ``ZooFan``, and an error message is returned to both users.
-  One user is able to create an account with the username ``ZooFan``, while the other user receives an error message.

The first outcome is really bad, as it leads to users trying to log in with the same username. Whose data do they see when they log in? The second outcome causes both user to have to try again, which is frustrating but at least doesn’t lead to corrupt or bad data.

For the exam, you should understand that race conditions lead to invalid data if they are not properly handled. Even the solution where both participants fail to proceed is preferable to one in which invalid data is permitted to enter the system.

## Working with Parallel Streams

- A serial stream is a stream in which the results are ordered, with only one entry being processed at a time.
- A parallel stream is capable of processing results concurrently, using multiple threads.

Using a parallel stream can change not only the performance of your application but also the expected results.

---

**The number of threads available in a parallel stream is proportional to the number of available CPUs in your environment.**

---

### Creating Parallel Streams

The Stream API was designed to make creating parallel streams quite easy. For the exam, you should be familiar with two ways of creating a parallel stream.

```java
Collection<Integer> collection = List.of(1,2);
Stream<Integer> p1 = collection.stream().parallel(); // 1
Stream<Integer> p2 = collection.parallelStream(); // 2
```

- ==**The first way to create a parallel stream is from an existing stream. Any stream can be made parallel!**==
- ==**The second way to create a parallel stream is from a Java ``Collection`` class.==**


---

**The Stream interface includes a method ``isParallel()`` that can be used to test whether the instance of a stream supports parallel processing. Some operations on streams preserve the parallel attribute, while others do not.**

---

### Performing a Parallel Decomposition

A parallel decomposition is the process of taking a task, breaking it into smaller pieces that can be performed concurrently, and then reassembling the results. The more concurrent a decomposition, the greater the performance improvement of using parallel streams.

```java
private static int doWork(int input) {
	try {
		Thread.sleep(5000);
	} catch (InterruptedException e) {}
		return input;
}
```

```java
10: long start = System.currentTimeMillis();
11: List.of(1,2,3,4,5)
	12: .stream()
	13: .map(w -> doWork(w))
	14: .forEach(s -> System.out.print(s + " "));
15:
16: System.out.println();
17: var timeTaken = (System.currentTimeMillis()-start)/ 1000;
18: System.out.println("Time: "+timeTaken+" seconds");
```

this code will output

```text
1 2 3 4 5
Time: 25 seconds
```

the results are ordered and predictable because we are using a serial stream. It also took around 25 seconds to process all five results, one at a time. What happens if we replace line 12 with one that uses a ``parallelStream()``?

```java
3 2 1 5 4
Time: 5 seconds
```

the results are no longer ordered or predictable. The ``map()`` and ``forEach()`` operations on a parallel stream are equivalent to submitting multiple Runnable lambda expressions to a pooled thread executor and then waiting for the results.

---

Ordering Results

If your stream operation needs to guarantee ordering and you’re not sure if it is serial or parallel, you can replace line 14 with one that uses`` forEachOrdered()``: 

```java
14: .forEachOrdered(s -> System.out.print(s + " "));
```
```text
1 2 3 4 5
Time: 5 seconds
```

---
### Processing Parallel Reductions

A parallel reduction is a reduction operation applied to a parallel stream. The results for parallel reductions can differ from what you expect when working with serial streams.
#### Performing Order-Based

Since order is not guaranteed with parallel streams, methods such as ``findAny()`` on parallel streams may result in unexpected behavior.

```java
System.out.print(List.of(1,2,3,4,5,6)
.parallelStream()
.findAny()
.get());
```

The JVM allocates a number of threads and returns the value of the first one to return a result, which could be 4, 2, and so on.  While neither the serial nor the parallel stream is guaranteed to return the first value, the serial stream often does. With a parallel stream, the results are likely to be more random.

What about operations that consider order, such as`` findFirst()``, ``limit()``, and ``skip()``? Order is still preserved, but performance may suffer on a parallel stream as a result of a parallel processing task being forced to coordinate all of its threads in a synchronized-like fashion. On the plus side, the results of ordered operations on a parallel stream will be consistent with a serial stream. For example, calling ``skip(5).limit(2).findFirst()`` will return the same result on ordered serial and parallel streams.
#### Combining Results with ``reduce()``

```java
<U> U reduce(U identity,
BiFunction<U,? super T,U> accumulator,
BinaryOperator<U> combiner)
```

```java
System.out.println(List.of('w', 'o', 'l', 'f')
.parallelStream()
.reduce("",
(s1,c) -> s1 + c,
(s2,s3) -> s2 + s3)); // wolf
```

On parallel streams, the ``reduce()`` method works by applying the reduction to pairs of elements within the stream to create intermediate values and then combining those intermediate values to produce a final result. **==Put another way, in a serial stream, wolf is built one character at a time. In a parallel stream, the intermediate values wo and lf are created and then combined.==**

With parallel streams, we now have to be concerned about order. What if the elements of a string are combined in the wrong order to produce wlfo or flwo? **==The Stream API prevents this problem while still allowing streams to be processed in parallel, as long as you follow one simple rule: make sure that the accumulator and combiner produce the same result regardless of the order they are called in.==**

While the requirements for the input arguments to the ``reduce()`` method hold true for both serial and parallel streams, you may not have noticed any problems in serial streams because the result was always ordered. With parallel streams, though, order is no longer guaranteed, and any argument that violates these rules is much more likely to produce side effects or unpredictable results.

```java
System.out.println(List.of(1,2,3,4,5,6)
.parallelStream()
.reduce(0, (a, b) -> (a -b)));
// PROBLEMATIC ACCUMULATOR
```

It may output -21, 3, or some other value.

```java
System.out.println(List.of("w","o","l","f")
.parallelStream()
.reduce("X", String::concat)); // XwXoXlXf
```

On a serial stream, it prints ``Xwolf``, but on a parallel stream, the result is ``XwXoXlXf``. As part of the parallel process, the identity is applied to multiple elements in the stream, resulting in very unexpected data.

---
**Selecting a ``reduce()`` Method**

**Although the one-and two-argument versions of ``reduce()`` support parallel processing, it is recommended that you use the three-argument version of ``reduce()`` when working with parallel streams. Providing an explicit combiner method allows the JVM to partition the operations in the stream more efficiently.**

---

#### Combining Results with ``collect()``

Like ``reduce()``, the Stream API includes a three-argument version of ``collect()`` that takes accumulator and combiner operators along with a supplier operator instead of an identity.

```java
<R> R collect(Supplier<R> supplier,
BiConsumer<R, ? super T> accumulator,
BiConsumer<R, R> combiner)
```

Also, like ``reduce()``, the accumulator and combiner operations must be able to process results in any order. In this manner, the three-argument version of ``collect()`` can be performed as a parallel reduction

```java
Stream<String> stream = Stream.of("w", "o", "l", "f").parallel();
SortedSet<String> set = stream.collect(ConcurrentSkipListSet::new,
	Set::add,
	Set::addAll);
System.out.println(set); // [f, l, o, w]
```

Performing parallel reductions with a collector requires additional considerations. For example, if the collection into which you are inserting is an ordered data set, such as a List, the elements in the resulting collection must be in the same order, regardless of whether you use a serial or parallel stream. This may reduce performance, though, as some operations cannot be completed in parallel.

#### Performing a Parallel Reduction on a Collector
 
 Every ``Collector`` instance defines a ``characteristics()`` method that returns a set of ``Collector.Characteristics`` attributes. When using a ``Collector`` to perform a parallel reduction, a number of properties must hold true. Otherwise, the ``collect()`` operation will execute in a single-threaded fashion.

**Requirements for Parallel Reduction with ``collect()``**
-  ==**The stream is parallel.**==
-  ==**The parameter of the ``collect()`` operation has the ``Characteristics.CONCURRENT`` characteristic.**==
-  ==**Either the stream is unordered or the collector has the characteristic ``Characteristics.UNORDERED``.==**

For example, while ``Collectors.toSet()`` does have the ``UNORDERED`` characteristic, it does not have the ``CONCURRENT`` characteristic. Therefore, the following is not a parallel reduction even with a parallel stream:

```java
parallelStream.collect(Collectors.toSet()); // Not a parallel reduction
```

The Collectors class includes two sets of static methods for retrieving collectors, ``toConcurrentMap()`` and ``groupingByConcurrent()``, both of which are ``UNORDERED`` and ``CONCURRENT``. These methods produce Collector instances capable of performing parallel reductions efficiently

```java
Stream<String> ohMy = Stream.of("lions", "tigers", "bears").parallel();
ConcurrentMap<Integer, String> map = ohMy
.collect(Collectors.toConcurrentMap(String::length, k -> k, (s1, s2) -> s1 + "," + s2));
System.out.println(map); // {5=lions,bears, 6=tigers}
System.out.println(map.getClass()); // java.util.concurrent.ConcurrentHashMap
```

```java
var ohMy = Stream.of("lions", "tigers", "bears").parallel();
ConcurrentMap<Integer, List<String>> map = ohMy.collect(
Collectors.groupingByConcurrent(String::length));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}
```

## Summary #Summary 

**==You should know how to create and define the thread’s work using a ``Runnable`` instance, as well as how to pause and interrupt the thread. When working with the ``Concurrency`` API, you should also know how to create threads using Callable lambda expressions.**==

==**At this point, you should know how to concurrently execute tasks using ``ExecutorService`` like a pro. You should also know which ``ExecutorService`` instances are available, including scheduled and pooled services.**==

==**Thread-safety is about protecting data from being corrupted by multiple threads modifying it at the same time. Java offers many tools to keep data safe, including atomic classes, synchronized methods/blocks, the Lock framework, and ``CyclicBarrier``. The Concurrency API also includes numerous collection classes that handle multithreaded access for you. You should be familiar with the concurrent collections, including the ``CopyOnWrite`` classes, which create a new underlying structure any time the underlying collection is modified.**==

==**When processing tasks concurrently, a variety of potential threading issues can arise. Deadlock, starvation, and livelock can result in programs that appear stuck, while race conditions can result in unpredictable data. For the exam, you need to know only the basic theory behind these concepts. In professional software development, however, finding and resolving such problems is a valuable skill.**==

==**parallel streams and showed you how to use them to perform parallel decompositions and reductions. Parallel streams can greatly improve the performance of your application. They can also cause unexpected results since the processing is no longer ordered. Remember to avoid stateful lambda expressions, especially when working with parallel streams.==**

## Exam Essentials #Essential 

**Be able to write thread-safe code**. Thread-safety is about protecting shared data from concurrent access. A monitor can be used to ensure that only one thread processes a particular section of code at a time. In Java, monitors can be implemented with asynchronized block or method or using an instance of Lock. ``ReentrantLock`` has a number of advantages over using a synchronized block, including the ability to check whether a lock is available without blocking it, as well as supporting the fair acquisition of locks. To achieve synchronization, two or more threads must coordinate on the same shared object.

**Be able to apply the atomic classes**. An atomic operation is one that occurs without interference from another thread. The Concurrency API includes a set of atomic classes that are similar to the primitive classes, except that they ensure that operations on them are performed atomically. Know the difference between an atomic variable and one marked with the volatile modifier.

**Create concurrent tasks with a thread executor service using ``Runnable`` and ``Callable``.** An ``ExecutorService`` creates and manages a single thread or a pool of threads. Instances of ``Runnable`` and ``Callable`` can both be submitted to a thread executor and will be completed using the available threads in the service. ``Callable`` differs from ``Runnable`` in that ``Callable`` returns a generic data type and can throw a checked exception. A ``ScheduledExecutorService`` can be used to schedule tasks at a fixed rate or with a fixed interval between executions.

**Be able to use the concurrent collection classes**. The Concurrency API includes numerous collection classes that include built-in support for multithreaded processing, such as ``ConcurrentHashMap``. It also includes a class ``CopyOnWriteArrayList`` that creates a copy of its underlying list structure every time it is modified and is useful in highly concurrent environments.

**Identify potential threading problems**. Deadlock, starvation, and livelock are three threading problems that can occur and result in threads never completing their task. Deadlock occurs when two or more threads are blocked forever. Starvation occurs when a single thread is perpetually denied access to a shared resource. Livelock is a form of starvation where two or more threads are active but conceptually blocked forever. Finally, race conditions occur when two threads execute at the same time, resulting in an unexpected outcome.

**Understand the impact of using parallel streams**. The Stream API allows for the easy creation of parallel streams. Using a parallel stream can cause unexpected results, since the order of operations may no longer be predictable. Some operations, such as ``reduce()`` and ``collect()``, require special consideration to achieve optimal performance when applied to a parallel stream.

## Review Questions

1. Given the following code snippet, which options correctly create a parallel stream? (Choose all that apply.)

```java
var c = new ArrayList<Thread>();
var s = c.stream();
var p = ??;
```

`A. new ParallelStream(s)`
`B. c.parallel()`
`C. s.parallelStream()`
`D. c.parallelStream()`
`E. new ParallelStream(c)`
`F. s.parallel()`
 
 **There is no such class within the Java API called ParallelStream, so options A and E are incorrect. ==The method defined in the Stream class to create a parallel stream from an existing stream is parallel(); therefore, option F is correct==, and option C is incorrect. ==The method defined in the Collection class to create a parallel stream from a collection is parallelStream(); therefore, option D is correct==, and option B is incorrect.**

----

2. Given that the sum of the numbers from 1 (inclusive) to 10 (exclusive) is 45, what are the possible results of executing the following program? (Choose all that apply.)

```java
1: import java.util.concurrent.locks.*;
2: import java.util.stream.*;
3: public class Bank {
4: private Lock vault = new ReentrantLock();
5: private int total = 0;
6: public void deposit(int value) {
7: try {
8: vault.tryLock();
9: total += value;
10: } finally { vault.unlock(); }
11: }
12: public static void main(String[] unused) {
13: var bank = new Bank();
14: IntStream.range(1, 10).parallel()
15: .forEach(s -> bank.deposit(s));
16: System.out.println(bank.total);
17: } }
```

A. 45 is printed.
B. A number less than 45 is printed.
C. A number greater than 45 is printed.
D. An exception is thrown.
E. None of the above, as the code does not compile.

**The tryLock() method returns immediately with a value of false if the lock cannot be acquired. Unlike lock(), it does not wait for a lock to become available. This code fails to check the return value on line 8, resulting in the protected code being entered regardless of whether the lock is obtained. In some executions (when tryLock() returns true on every call), the code will complete successfully and print 45 at runtime, making option A correct. On other executions (when tryLock() returns false at least once), the unlock() method on line 10 will throw an IllegalMonitorStateException at runtime, making option D correct. Option B would be possible if line 10 did not throw an exception.**

---

3. Which of the following statements about the Callable call() and Runnable run() methods are correct? (Choose all that apply.)

A. Both methods return void.
B. Both can throw unchecked exceptions.
C. Both can be implemented with lambda expressions.
D. Runnable returns a generic type.
E. Both can throw checked exceptions.
F. Callable returns a generic type.

==**Runnable returns void and Callable returns a generic type==, making options A and D incorrect and option F correct. All methods are capable of throwing unchecked exceptions, so option B is correct. Only Callable is capable of throwing checked exceptions, so option E is incorrect. Both Runnable and Callable are functional interfaces that can be implemented with a lambda expression, so option C is also correct.**

---

4. Which lines need to be changed to make the code compile? (Choose all that apply.)

```java
ExecutorService service = // w1
Executors.newSingleThreadScheduledExecutor();
service.scheduleWithFixedDelay(() -> {
System.out.println("Open Zoo");
return null; // w2
}, 0, 1, TimeUnit.MINUTES);
var result = service.submit(() -> System.out.println("Wake Staff")); // w3 
System.out.println(result.get()); // w4
```

A. It compiles and runs without issue.
B. Line w1
C. Line w2
D. Line w3
E. Line w4
F. It compiles but throws an exception at runtime.

**The code does not compile, so options A and F are incorrect. The first problem is that although a ScheduledExecutorService is created, it is assigned to an ExecutorService. The type of the variable on line w1 would have to be updated to ScheduledExecutorService for the code to compile, making option B correct. The second problem is that scheduleWithFixedDelay() supports only Runnable, not Callable, and any attempt to return a value is invalid in a Runnable lambda expression; therefore, line w2 will also not compile, and option C is correct. The rest of the lines compile without issue, so options D and E are incorrect.**

---

5. What statement about the following code is true?

```java
var value1 = new AtomicLong(0);
final long[] value2 = {0};
IntStream.iterate(1, i -> 1).limit(100).parallel()
.forEach(i -> value1.incrementAndGet());
IntStream.iterate(1, i -> 1).limit(100).parallel()
.forEach(i -> ++value2[0]);
System.out.println(value1+" "+value2[0]);
```

A. It outputs 100 100.
B. It outputs 100 99.
C. The output cannot be determined ahead of time.
D. The code does not compile.
E. It compiles but throws an exception at runtime.
F. It compiles but enters an infinite loop at runtime.
G. None of the above

**The code compiles and runs without throwing an exception or entering an infinite loop, so options D, E, and F are incorrect. The key here is that the increment operator ++ is not atomic. While the first part of the output will always be 100, the second part is nondeterministic. It may output any value from 1 to 100, because the threads can overwrite each other’s work. Therefore, option C is the correct answer, and options A and B are incorrect.**

---

6.  Which statements about the following code are correct? (Choose all that apply.)

```java
var data = List.of(2,5,1,9,8);
data.stream().parallel()
.mapToInt(s -> s)
.peek(System.out::print)
.forEachOrdered(System.out::print);
```

A. The peek() method will print the entries in the sorted order: 12589.
B. The peek() method will print the entries in the original order: 25198.
C. The peek() method will print the entries in an order that cannot be determined ahead of time.
D. The forEachOrdered() method will print the entries in the sorted order: 12589. 
E. The forEachOrdered() method will print the entries in the original order: 25198.
F. The forEachOrdered() method will print the entries in an order that cannot be determined ahead of time.
G. The code does not compile.

**The code compiles, so option G is incorrect. The peek() method on a parallel stream will process the elements concurrently, so the order cannot be determined ahead of time, and option C is correct. ==The forEachOrdered() method will process the elements in the order in which they are stored in the stream==, making option E correct. None of the methods sort the elements, so options A and D are incorrect.**

---

7. Fill in the blanks: ___??_______ occur(s) when two or more threads are blocked forever but both appear active. ___??____ occur(s) when two or more threads try to complete a related task at the same time, resulting in invalid or unexpected data.

A. Livelock, Deadlock
B. Deadlock, Starvation
C. Race conditions, Deadlock
D. Livelock, Race conditions
E. Starvation, Race conditions
F. Deadlock, Livelock

**Livelock occurs when two or more threads are conceptually blocked forever, although they are each still active and trying to complete their task. A race condition is an undesirable result that occurs when two tasks that should have been completed sequentially are completed at the same time. For these reasons, option D is correct.**

---

8. Assuming this class is accessed by only a single thread at a time, what is the result of calling the countIceCreamFlavors() method?

```java
import java.util.stream.LongStream;
public class Flavors {
private static int counter;
public static void countIceCreamFlavors() {
counter = 0;
Runnable task = () -> counter++;
LongStream.range(0, 500)
.forEach(m -> new Thread(task).run());
System.out.println(counter);
} }
```

A. The method consistently prints a number less than 500.
B. The method consistently prints 500.
C. The method compiles and prints a value, but that value cannot be determined ahead of time.
D. The method does not compile.
E. The method compiles but throws an exception at runtime.
F. None of the above

**==Be wary of run() vs. start() on the exam! The method looks like it executes a task concurrently, but it runs synchronously==. In each iteration of the forEach() loop, the process waits for the run() method to complete before moving on. For this reason, the code is thread-safe. Since the program consistently prints 500 at runtime, option B is correct. Note that if start() had been used instead of run() (or the stream was parallel), then the output would be indeterminate, and option C would have been correct.**

---

9. Which happens when a new task is submitted to an ExecutorService in which no threads are available?

A. The executor throws an exception when the task is submitted.
B. The executor discards the task without completing it.
C. The executor adds the task to an internal queue and completes when there is an available thread.
D. The thread submitting the task waits on the submit call until a thread is available before continuing.
E. The executor stops an existing task and starts the newly submitted one.

**If a task is submitted to a thread executor, and the thread executor does not have any available threads, the call to the task will return immediately with the task being queued internally by the thread executor. For this reason, option C is the correct answer.**

---

10. What is the result of executing the following code snippet?

```java
List<Integer> lions = new ArrayList<>(List.of(1,2,3));
List<Integer> tigers = new CopyOnWriteArrayList<>(lions);
Set<Integer> bears = new ConcurrentSkipListSet<>();
bears.addAll(lions);
for(Integer item: tigers) tigers.add(4); // x1
for(Integer item: bears) bears.add(5); // x2
System.out.println(lions.size() + " " + tigers.size() + " " + bears.size());
```

A. It outputs 3 6 4.
B. It outputs 6 6 6.
C. It outputs 6 3 4.
D. The code does not compile.
E. It compiles but throws an exception at runtime on line x1.
F. It compiles but throws an exception at runtime on line x2.
G. It compiles but enters an infinite loop at runtime.

**The code compiles without issue, so option D is incorrect. The CopyOnWriteArrrayList class is designed to preserve the original list on iteration, so the first loop will be executed exactly three times and, in the process, will increase the size of tigers to six elements. The ConcurrentSkipListSet class allows modifications, and since it enforces the uniqueness of its elements, the value 5 is added only once, leading to a total of four elements in bears. Finally, despite using the elements of lions to populate the collections, tigers and bears are not backed by the original list, so the size of lions is 3 throughout this program. For these reasons, the program prints 3 6 4, and option A is correct.**

---

11. What statements about the following code are true? (Choose all that apply.)

```java
Integer i1 = List.of(1, 2, 3, 4, 5).stream().findAny().get();
synchronized(i1) { // y1
Integer i2 = List.of(6, 7, 8, 9, 10)
.parallelStream()
.sorted()
.findAny().get(); // y2
System.out.println(i1 + " " + i2);
}
```

A. The first value printed is always 1.
B. The second value printed is always 6.
C. The code will not compile because of line y1.
D. The code will not compile because of line y2.
E. The code compiles but throws an exception at runtime.
F. The output cannot be determined ahead of time.
G. It compiles but waits forever at runtime.

**The code compiles and runs without issue, so options C, D, E, and G are incorrect. There are two important things to notice. First, synchronizing on the first variable doesn’t impact the results of the code. Second, sorting on a parallel stream does not mean that findAny() will return the first record. The findAny() method will return the value from the first thread that retrieves a record. Therefore, the output is not guaranteed, and option F is correct. Option A looks correct, but even on serial streams, findAny() is free to select any element.**

---

12. Assuming each call to takeNap() takes five seconds to execute without throwing an exception, what is the expected result of executing the following code snippet?

```java
ExecutorService service = Executors.newFixedThreadPool(4);
try {
service.execute(() -> takeNap());
service.execute(() -> takeNap());
service.execute(() -> takeNap());
} finally {
service.shutdown();
}
service.awaitTermination(2, TimeUnit.SECONDS);
System.out.println("DONE!");
```

A. It will immediately print DONE!.
B. It will pause for 2 seconds and then print DONE!.
C. It will pause for 5 seconds and then print DONE!.
D. It will pause for 15 seconds and then print DONE!.
E. It will throw an exception at runtime.
F. None of the above, as the code does not compile.

**The code snippet submits three tasks to an ExecutorService, shuts it down, and then waits for the results. The awaitTermination() method waits a specified amount of time for all tasks to complete and the service to finish shutting down. Since each five-second task is still executing, the awaitTermination() method will return with a value of false after two seconds but not throw an exception. For these reasons, option B is correct.**

---

13. What statements about the following code are true? (Choose all that apply.)
```java
System.out.print(List.of("duck","flamingo","pelican")
.parallelStream().parallel() // q1
.reduce(0,
(c1, c2) -> c1.length() + c2.length(), // q2
(s1, s2) -> s1 + s2)); // q3
```

A. It compiles and runs without issue, outputting the total length of all strings in the stream.
B. The code will not compile because of line q1.
C. The code will not compile because of line q2.
D. The code will not compile because of line q3.
E. It compiles but throws an exception at runtime.
F. None of the above

**The code does not compile, so options A and E are incorrect. The problem here is that c1 is an Integer and c2 is a String, so the code fails to combine on line q2, since calling length() on an Integer is not allowed, and option C is correct. The rest of the lines compile without issue. Note that calling parallel() on an already parallel stream is allowed, and it may return the same object.**

---

14. What statements about the following code snippet are true? (Choose all that apply.)

```java
Object o1 = new Object();
Object o2 = new Object();
var service = Executors.newFixedThreadPool(2);
var f1 = service.submit(() ->
{
synchronized (o1) {
synchronized (o2) { System.out.print("Tortoise"); }
}
});
var f2 = service.submit(() ->
{
synchronized (o2) {
synchronized (o1) { System.out.print("Hare"); }
}
});
f1.get();
f2.get();
```

A. The code will always output Tortoise followed by Hare.
B. The code will always output Hare followed by Tortoise.
C. If the code does output anything, the order cannot be determined.
D. The code does not compile.
E. The code compiles but may produce a deadlock at runtime.
F. The code compiles but may produce a livelock at runtime.
G. It compiles but throws an exception at runtime.
 
 **The code compiles without issue, so option D is incorrect. Since both tasks are submitted to the same thread executor pool, the order cannot be determined, so options A and B are incorrect, and option C is correct. The key here is that the order in which the resources o1 and o2 are synchronized could result in a deadlock. For example, if the first thread gets a lock on o1 and the second thread gets a lock on o2 before either thread can get their second lock, the code will hang at runtime, making option E correct. The code cannot produce a livelock, since both threads are waiting, so option F is incorrect. Finally, if a deadlock does occur, an exception will not be thrown, so option G is incorrect.**

---

15. Which statement about the following code snippet is correct?

```java
2: var cats = Stream.of("leopard", "lynx", "ocelot", "puma")
3: .parallel();
4: var bears = Stream.of("panda","grizzly","polar").parallel();
5: var data = Stream.of(cats,bears).flatMap(s ->
s)
6: .collect(Collectors.groupingByConcurrent(
7: s ->
!s.startsWith("p")));
8: System.out.println(data.get(false).size()
9: + " " + data.get(true).size());
```

A. It outputs 3 4.
B. It outputs 4 3.
C. The code will not compile because of line 6.
D. The code will not compile because of line 7.
E. The code will not compile because of line 8.
F. It compiles but throws an exception at runtime.

**The code compiles and runs without issue, so options C, D, E, and F are incorrect. The collect() operation groups the animals into those that do and do not start with the letter p. Note that there are four animals that do not start with the letter p and three animals that do. The logical complement operator (!) before the startsWith() method means that results are reversed, so the output is 3 4, and option A is correct, making option B incorrect.**

---

16. Assuming one minute is enough time for all the threads within this program to complete, what are the possible results of executing the following program? (Choose all that apply.)

```java
public class RocketShip {
private volatile int fuel;
private void launch(int checks) {
var p = new ArrayList<Thread>();
for (int i = 0; i < checks; i++)
p.add(new Thread(() ->
fuel++));
p.forEach(Thread::interrupt);
p.forEach(Thread::start);
p.forEach(Thread::interrupt);
}
public static void main(String[] args) throws Exception {
var ship = new RocketShip();
ship.launch(100);
Thread.sleep(60*1000);
System.out.print(ship.fuel);
} }
```

A. It prints a number less than 100.
B. It prints 100.
C. It prints a number greater than 100.
D. It does not compile.
E. It compiles but throws an InterruptedException at runtime.

**The code compiles just fine. If the calls to fuel++ are ordered sequentially, then the program will print 100 at runtime, making option B correct. On the other hand, the calls may overwrite each other. The volatile attribute only guarantees memory consistency, not thread-safety, making option A correct and option C incorrect. Option E is also incorrect, as no InterruptedException is thrown by this code. Remember, interrupt() only impacts a thread that is in a WAITING or TIMED_WAITING state. Calling interrupt() on a thread in a NEW or RUNNABLE state has no impact unless the code is running and explicitly checking the isInterrupted() method.**

---

17. Which statements about methods in ReentrantLock are correct? (Choose all that apply.)

A. The lock() method will attempt to acquire a lock without waiting indefinitely for it.
B. The testLock() method will attempt to acquire a lock without waiting indefinitely for it.
C. The attemptLock() method will attempt to acquire a lock without waiting indefinitely for it.
D. By default, a ReentrantLock fairly releases to each thread in the order in which it was requested.
E. Calling the unlock() method once will release a resource so that other threads can obtain the lock.
F. None of the above

**The lock() method will wait indefinitely for a lock, so option A is incorrect. Options B and C are also incorrect, as the correct method name to attempt to acquire a lock is tryLock(). Option D is incorrect, as fairness is set to false by default and must be enabled by using an overloaded constructor. Finally, option E is incorrect because a thread that holds the lock may have called lock() or tryLock() multiple times. A thread needs to call unlock() once for each call to lock() and successful tryLock(). Option F is the correct answer since none of the other options are valid statements.**

---

18. Which of the following are valid Callable expressions? (Choose all that apply.)

A. a -> {return 10;}
B. () -> {String s = "";} 
C. () -> 5
D. () -> {returnnull}
E. () -> "The" + "Zoo"
F. (int count) -> count+1
G. () -> {System.out.println("Giraffe"); return 10;}

**A Callable lambda expression takes no values and returns a generic type; therefore, options C, E, and G are correct. Options A and F are incorrect because they both take an input parameter. Option B is incorrect because it does not return a value. Option D is not a valid lambda expression, because it is missing a semicolon at the end of the return statement, which is required when inside braces {}.**

---

19. What is the result of executing the following application? (Choose all that apply.)

```java
import java.util.concurrent.*;
import java.util.stream.*;
public class PrintConstants {
public static void main(String[] args) {
var s = Executors.newScheduledThreadPool(10);
DoubleStream.of(3.14159,2.71828) // b1
.forEach(c ->
s.submit( // b2
() ->
System.out.println(10*c))); // b3
s.execute(() ->
System.out.println("Printed"));
} }
```

A. It compiles and outputs the two numbers followed by Printed.
B. The code will not compile because of line b1.
C. The code will not compile because of line b2.
D. The code will not compile because of line b3.
E. It compiles, but the output cannot be determined ahead of time.
F. It compiles but throws an exception at runtime.
G. It compiles but waits forever at runtime.

**The application compiles and does not throw an exception. Even though the stream is processed in sequential order, the tasks are submitted to a thread executor, which may complete the tasks in any order. Therefore, the output cannot be determined ahead of time, and option E is correct. Finally, the thread executor is never shut down; therefore, the code will run but never terminate, making option G also correct.**

---

20. What is the result of executing the following program? (Choose all that apply.)

```java
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;
public class PrintCounter {
static int count = 0;
public static void main(String[] args) throws
InterruptedException, ExecutionException {
var service = Executors.newSingleThreadExecutor();
try {
var r = new ArrayList<Future<?>>();
IntStream.iterate(0,i ->
i+1).limit(5).forEach(
i ->
r.add(service.execute(() ->
{count++;})) // n1
);
for(Future<?> result : r) {
System.out.print(result.get()+" "); // n2
}
} finally { service.shutdown(); }
} }
```

A. It prints 0 1 2 3 4
B. It prints 1 2 3 4 5
C. It prints null null null null null
D. It hangs indefinitely at runtime.
E. The output cannot be determined.
F. The code will not compile because of line n1.
G. The code will not compile because of line n2.

**The key to solving this question is to remember that the execute() method returns void, not a Future object. Therefore, line n1 does not compile, and option F is the correct answer. If the submit() method had been used instead of execute(), option C would have been the correct answer, as the output of the submit(Runnable) task is a Future< ?> object that can only return null on its get() method.**

---

21. Given the following code snippet and blank lines on p1 and p2, which values guarantee that 1 is printed at runtime? (Choose all that apply.)

```java
var data = List.of(List.of(1,2),
List.of(3,4),
List.of(5,6));
data. // p1
.flatMap(s ->
s.stream())
. // p2
.ifPresent(System.out::print);
```

A. stream() on line p1, findFirst() on line p2
B. stream() on line p1, findAny() on line p2
C. parallelStream() on line p1, findAny() on line p2
D. parallelStream() on line p1, findFirst() on line p2
E. The code does not compile regardless of what is inserted into the blanks.
F. None of the above

**The findFirst() method guarantees the first element in the stream will be returned, whether it is serial or parallel, making options A and D correct. While option B may consistently print 1 at runtime, the behavior of findAny() on a serial stream is not guaranteed, so option B is incorrect. Option C is likewise incorrect, with the output being random at runtime.**

---

22. Assuming one minute is enough time for the tasks submitted to the service executor to complete, what is the result of executing countSheep()? (Choose all that apply.)

```java
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
public class BedTime {
private AtomicInteger s1 = new AtomicInteger(0); // w1
private int s2 = 0;
private void countSheep() throws InterruptedException {
var service = Executors.newSingleThreadExecutor(); // w2
try {
for (int i = 0; i < 100; i++)
service.execute(() ->
{
s1.getAndIncrement(); s2++; }); // w3
Thread.sleep(60*1000);
System.out.println(s1 + " " + s2);
} finally { service.shutdown(); }
}
public static void main(String... nap) throws InterruptedException {
new BedTime().countSheep();
} }
```

A. The method consistently prints 100 99.
B. The method consistently prints 100 100.
C. The output cannot be determined ahead of time.
D. The code will not compile because of line w1.
E. The code will not compile because of line w2.
F. The code will not compile because of line w3.
G. It compiles but throws an exception at runtime.

**The code compiles and runs without issue. The key aspect to notice in the code is that a single-thread executor is used, meaning that no task will be executed concurrently. Therefore, the results are valid and predictable, with 100 100 being the output, and option B is the correct answer. If a thread executor with more threads was used, then the s2++ operations could overwrite each other, making the second value indeterminate at the end of the program. In this case, option C would be the correct answer.**

---

23. What is the result of executing the following application? (Choose all that apply.)

```java
import java.util.concurrent.*;
import java.util.stream.*;
public class StockRoomTracker {
public static void await(CyclicBarrier cb) { // j1
try { cb.await(); } catch (Exception e) {}
}
public static void main(String[] args) {
var cb = new CyclicBarrier(10,
() ->
System.out.println("Stock Room Full!")); // j2
IntStream.iterate(1, i ->
1).limit(9).parallel()
.forEach(i ->
await(cb)); // j3
} }
```

A. It outputs Stock Room Full!
B. The code will not compile because of line j1.
C. The code will not compile because of line j2.
D. The code will not compile because of line j3.
E. It compiles but throws an exception at runtime.
F. It compiles but waits forever at runtime.

**The code compiles without issue, so options B, C, and D are incorrect. The limit on the cyclic barrier is 10, but the stream can generate only up to 9 threads that reach the barrier; therefore, the limit can never be reached, and option F is the correct answer, making options A and E incorrect. Even if the limit(9) statement was changed to limit(10), the program could still hang since the JVM might not allocate 10 threads to the parallel stream.**

---

24. What statements about the following class definition are true? (Choose all that apply.)

```java
public final class TicketManager {
private int tickets;
private static TicketManager instance;
private TicketManager() {}
static synchronized TicketManager getInstance() { // k1
if (instance==null) instance = new TicketManager(); // k2
return instance;
}
public int getTicketCount() { return tickets; }
public void addTickets(int value) {tickets += value;} // k3
public void sellTickets(int value) {
synchronized (this) { // k4
tickets -=
value;
} } }
```

A. It compiles without issue.
B. The code will not compile because of line k2.
C. The code will not compile because of line k3.
D. The locks acquired on k1 and k4 are on the same object.
E. The class correctly protects the tickets data from race conditions.
F. At most one instance of TicketManager will be created in an application that uses this class.

**The class compiles without issue, so option A is correct. Since getInstance() is a static method and sellTickets() is an instance method, lines k1 and k4 synchronize on different objects, making option D incorrect. The class is not thread-safe because the addTickets() method is not synchronized, and option E is incorrect. One thread could call sellTickets() while another thread calls addTickets(), possibly resulting in bad data. Finally, option F is correct because the getInstance() method is synchronized. Since the constructor is private, this method is the only way to create an instance of TicketManager outside the class. The first thread to enter the method will set the instance variable, and all other threads will use the existing value. This is a singleton pattern.**

---

25. Assuming an implementation of the performCount() method is provided prior to runtime,
which of the following are possible results of executing the following application? (Choose all that apply.)

```java
import java.util.*;
import java.util.concurrent.*;
public class CountZooAnimals {
public static void performCount(int animal) {
// IMPLEMENTATION OMITTED
}
public static void printResults(Future<?> f) {
try {
System.out.println(f.get(1, TimeUnit.DAYS)); // o1
} catch (Exception e) {
System.out.println("Exception!");
}
}
public static void main(String[] args) throws Exception {
final var r = new ArrayList<Future<?>>();
ExecutorService s = Executors.newSingleThreadExecutor();
try {
for(int i = 0; i < 10; i++) {
final int animal = i;
r.add(s.submit(() ->
performCount(animal))); // o2
}
r.forEach(f ->
printResults(f));
} finally { s.shutdown(); }
} }
```

A. It outputs a number 10 times.
B. It outputs a Boolean value 10 times.
C. It outputs a null value 10 times.
D. It outputs Exception! 10 times.
E. It hangs indefinitely at runtime.
F. The code will not compile because of line o1.
G. The code will not compile because of line o2.

**The code compiles and runs without issue, so options F and G are incorrect. The return**
**type of performCount() is void, so submit() is interpreted as being applied to a Runnable expression. While submit(Runnable) does return a Future< ?>, calling get() on it always returns null. For this reason, options A and B are incorrect, and option C is correct. The performCount() method can also throw a runtime exception, which will then be thrown by the get() call as an ExecutionException; therefore, option D is also a correct answer. Finally, it is also possible for our performCount() to hang indefinitely, such as with a deadlock or infinite loop. Luckily, the call to get() includes a timeout value. While each call to Future.get() can wait up to a day for a result, it will eventually finish, so option E is incorrect.**

---

# Chapter 14 - I/O #Chapter 

## Referencing Files and Directories

###  Conceptualizing the File System

Data is stored on persistent storage devices, such as hard disk drives and memory cards. A file within the storage device holds data. Files are organized into hierarchies using directories. A directory is a location that can contain files as well as other directories. When working with directories in Java, we often treat them like files.

To interact with files, we need to connect to the file system. The file system is in charge of reading and writing data within a computer. Different operating systems use different file systems to manage their data.

The JVM will automatically connect to the local file system, allowing you to perform the same operations across multiple platforms. Next, the root directory is the topmost directory in the file system, from which all files and directories inherit.

A path is a representation of a file or directory within a file system. Each file system defines its own path separator character that is used between directory entries. The value to the left of a separator is the parent of the value to the right of the separator.

----
**Operating System File Separators**

**Different operating systems vary in their format of pathnames. For example, Unix-based systems use the forward slash, ``/``, for paths, whereas Windows-based systems use the backslash, ``\``, character. That said, many programming languages and file systems support both types of slashes when writing path statements. Java offers a system property to retrieve the local separator character for the current environment:**

```java
System.out.print(System.getProperty("file.separator"));
```


---

![[Pasted image 20240605101736.png]]

We use both absolute and relative paths to the file or directory within the file system.
- **==The absolute path of a file or directory is the full path from the root directory to the file or directory, including all subdirectories that contain the file or directory.**== 
- ==**Alternatively, the relative path of a file or directory is the path from the current working directory to the file or directory==**

Determining whether a path is relative or absolute is file-system dependent. To match the exam, we adopt the following conventions:

-  ==**If a path starts with a forward slash (/), it is absolute, with / as the root directory, such as /bird/parrot.png.**==
-  ==**If a path starts with a drive letter (c:), it is absolute, with the drive letter as the root directory, such as C:/bird/info.**==
-  ==**Otherwise, it is a relative path, such as bird/parrot.png.==**

![[Pasted image 20240605102051.png]]

![[Pasted image 20240605102445.png]]

**==A symbolic link is a special file within a file system that serves as a reference or pointer to another file or directory.==** For example, the following paths reference the same file:

```java
/fish/shark/swim.txt
/zoo/user/favorite/swim.txt
```

In general, symbolic links are transparent to the user, as the operating system takes care of resolving the reference to the actual file. While the I/O APIs do not support symbolic links, NIO.2 includes full support for creating, detecting, and navigating symbolic links within the file system.

### Creating a File or Path

In order to do anything useful, you first need an object that represents the path to a particular file or directory on the file system. Using legacy I/O, this is the ``java.io.File`` class, whereas with NIO.2, it is the ``java.nio.file.Path`` interface. The ``File`` class and ``Path`` interface cannot read or write data within a file, although they are passed as a reference to other classes

---

**Remember, a ``File`` or ``Path`` can represent a file or a directory.** #TIP 

---

#### Creating a File

The ``File`` class is created by calling its constructor

```java
File zooFile1 = new File("/home/tiger/data/stripes.txt");
File zooFile2 = new File("/home/tiger", "data/stripes.txt");
File parent = new File("/home/tiger");
File zooFile3 = new File(parent, "data/stripes.txt");
System.out.println(zooFile1.exists());
```

All three create a ``File`` object that points to the same location on disk. If we passed null as the parent to the final constructor, it would be ignored, and the method would behave the same way as the single ``String`` constructor.

#### Creating a Path

Since ``Path`` is an interface, we can’t create an instance directly. Java provides a number of classes and methods that you can use to obtain ``Path`` objects. 

The simplest and most straightforward way to obtain a Path object is to use a static factory method defined on ``Path`` or ``Paths``.

```java
Path zooPath1 = Path.of("/home/tiger/data/stripes.txt");
Path zooPath2 = Path.of("/home", "tiger", "data", "stripes.txt");

Path zooPath3 = Paths.get("/home/tiger/data/stripes.txt");
Path zooPath4 = Paths.get("/home", "tiger", "data", "stripes.txt");

System.out.println(Files.exists(zooPath1));
```

Both methods allow passing a varargs parameter to pass additional path elements. The values are combined and automatically separated by the operating system–dependent file separator.

there are two ways of doing the same thing here. The ``Path.of()`` method was introduced in Java 11 as a static method on the interface. The Paths factory class also provides a ``get()`` method to do the same thing. Note the s at the end of the ``Paths`` class to distinguish it from the ``Path`` interface.
#### Switching between File and Path

Since ``File`` and ``Path`` both reference locations on disk, it is helpful to be able to convert between them.

```java
File file = new File("rabbit");
Path nowPath = file.toPath();
File backToFile = nowPath.toFile();
```

When working with newer applications, you should rely on NIO.2’s ``Path`` interface, as it contains a lot more features.
#### Obtaining a Path from the ``FileSystems`` Class

NIO.2 makes extensive use of creating objects with factory classes. **==The ``FileSystems`` class creates instances of the abstract ``FileSystem`` class. The latter includes methods for working with the file system directly. Both ``Paths.get()`` and ``Path.of()`` are shortcuts for this ``FileSystem`` method.==**

```java
Path zooPath1 = FileSystems.getDefault().getPath("/home/tiger/data/stripes.txt");
Path zooPath2 = FileSystems.getDefault().getPath("/home", "tiger", "data", "stripes.txt");
```

#### Reviewing I/O and NIO.2 Relationships

The model for I/O is smaller, and you only need to understand the ``File`` class. In contrast, NIO.2 has more features and makes extensive use of the factory pattern. Many of your interactions with NIO.2 will require two
types: an abstract class or interface and a factory or helper class.

![[Pasted image 20240605104538.png]]

**==In particular, keep an eye on whether the class name is singular or plural. Classes with plural names include methods to create or operate on class/interface instances with singular names==**. Remember, as a convenience a ``Path`` can also be created from the ``Path`` interface using the static factory ``of()`` method.

---

**==The ``java.io.File`` is the I/O class, while ``Files`` is an NIO.2 helper class. ``Files`` operates on ``Path`` instances, not ``java.io.File`` instances==. We know this is confusing, but they are from completely different APIs!**

---

![[Pasted image 20240605104803.png]]

## Operating on File and Path

### Using Shared Functionality

Many operations can be done using both the I/O and NIO.2 libraries.

![[Pasted image 20240607101202.png]]

![[Pasted image 20240607101216.png]]
![[Pasted image 20240607101237.png]]

```java
11: var file = new File("C:\\data\\zoo.txt");
12: if (file.exists()) {
		13: System.out.println("Absolute Path: " + file.getAbsolutePath());
		14: System.out.println("Is Directory: " + file.isDirectory());
		15: System.out.println("Parent Path: " + file.getParent());
		16: if (file.isFile()) {
			17: System.out.println("Size: " + file.length());
			18: System.out.println("Last Modified: " + file.lastModified());
		19: } else {
			20: for (File subfile : file.listFiles()) {
				21: System.out.println(" " + subfile.getName());
			22: } 
			} 
		} 
	}
```

```text
Absolute Path: C:\data\zoo.txt
Is Directory: false
Parent Path: C:\data
Size: 12382
Last Modified: 1650610000000

Absolute Path: C:\data
Is Directory: true
Parent Path: C:\
employees.txt
zoo.txt
zoo-backup.txt
```

you see that the output of an I/O-based program is completely dependent on the directories and files available at runtime in the underlying file system. **==On the exam, you might see paths that look like files but are directories or vice versa. For example, /data/zoo.txt could be a file or a directory, even though it has a file extension. Don’t assume it is either unless the question tells you it is!==**

```java
25: public static void nio() throws IOException {
	26: var path = Path.of("C:\\data\\zoo.txt");
	27: if (Files.exists(path)) {
			28: System.out.println("Absolute Path: " + path.toAbsolutePath());
			29: System.out.println("Is Directory: " + Files.isDirectory(path));
			30: System.out.println("Parent Path: " + path.getParent());
			31: if (Files.isRegularFile(path)) {
			32: System.out.println("Size: " + Files.size(path));
			33: System.out.println("Last Modified: "
			34: + Files.getLastModifiedTime(path));
		35: } else {
			36: try (Stream<Path> stream = Files.list(path)) {
			37: stream.forEach(p ->
			38: System.out.println(" " + p.getName()));
		39: }
		}
	} 
}
```

Most of this example is equivalent and replaces the I/O method calls in the previous tables with the NIO.2 versions. However, there are key differences.

- First, line 25 declares a checked exception. More APIs in NIO.2 throw ``IOException`` than the I/O APIs did.
- Second, lines 36–39 use a ``Stream`` and a lambda instead of a loop. Since streams use lazy evaluation, this means the method will load each path element as needed, rather than the entire directory at once.

---

**Closing the Stream**

**in the last code sample, we put our ``Stream`` object inside a try-with- resources? The NIO.2 stream-based methods open a connection to the file system that must be properly closed; otherwise, a resource leak could ensue. A resource leak within the file system means the path may be locked from modification long after the process that used it is completed.**

**If you assumed that a stream’s terminal operation would automatically close the underlying file resources, you’d be wrong. There was a lot of debate about this behavior when it was first presented; in short, requiring developers to close the stream won out.**

**On the plus side, not all streams need to be closed: only those that open resources, like the ones found in NIO.2. For instance, you didn’t need to close any of the streams you worked with in Chapter 10, “Streams.”**

**Finally, the exam doesn’t always properly close NIO.2 resources. To match the exam, we sometimes skip closing NIO.2 resources in review and practice questions. ==Always use try-with- resources statements with these NIO.2 methods in your own code==.**

---

### Handling Methods That Declare ``IOException``

Many of the methods declare ``IOException``. Common causes of a method throwing this exception include the following:

-  ==**Loss of communication to the underlying file system.**==
-  ==**File or directory exists but cannot be accessed or modified.**==
-  ==**File exists but cannot be overwritten.**==
-  ==**File or directory is required but does not exist.==**

As a rule of thumb, if a NIO.2 method declares an ``IOException``, it usually requires the paths it operates on to exist.
### Providing NIO.2 Optional Parameters

Many of the NIO.2 methods include a varargs that takes an optional list of values.

![[Pasted image 20240607102753.png]]
![[Pasted image 20240607102810.png]]

```java
Path path = Paths.get("schedule.xml");
boolean exists = Files.exists(path, LinkOption.NOFOLLOW_LINKS);
```

The ``Files.exists()`` simply checks whether a file exists. But if the parameter is a symbolic link, the method checks whether the target of the symbolic link exists, instead. Providing ``LinkOption.NOFOLLOW_LINKS`` means the default behavior will be overridden, and the method will check whether the symbolic link itself exists. Note that some of the enums in Table 14.5 inherit an interface. That means some methods accept a variety of enum types
### Interacting with NIO.2 Paths

**==Just like ``String`` values, ``Path`` instances are immutable.==**

```java
Path p = Path.of("whale");
p.resolve("krill");
System.out.println(p); // whale
```

Many of the methods available in the ``Path`` interface transform the path value in some way and return a new ``Path`` object, allowing the methods to be chained.

```java
Path.of("/zoo/../home").getParent().normalize().toAbsolutePath();
```

#### Viewing the Path

The ``Path`` interface contains three methods to retrieve basic information about the path representation. 
-  The ``toString()`` method returns a ``String`` representation of the entire path. In fact, it is the only method in the Path interface to return a ``String``
- The ``getNameCount()`` and ``getName()`` methods are often used together to retrieve the number of elements in the path and a reference to each element, respectively. **==These two methods do not include the root directory as part of the path==**.

```java
Path path = Paths.get("/land/hippo/harry.happy");
System.out.println("The Path Name is: " + path);
for(int i=0; i<path.getNameCount(); i++)
	System.out.println(" Element " + i + " is: " + path.getName(i));
```

Notice that we didn’t call ``toString()`` explicitly on the second line. Remember, **==Java calls ``toString()`` on any Object as part of string concatenation.==**

```text
The Path Name is: /land/hippo/harry.happy
Element 0 is: land
Element 1 is: hippo
Element 2 is: harry.happy
```

Even though this is an absolute path, the root element is not included in the list of names.

```java
var p = Path.of("/");
System.out.print(p.getNameCount()); // 0
System.out.print(p.getName(0)); // IllegalArgumentException
```
#### Creating Part of the Path

The ``Path`` interface includes the ``subpath(``) method to select portions of a path. It takes two parameters: **==an inclusive ``beginIndex`` and an exclusive ``endIndex``==**

```java
var p = Paths.get("/mammal/omnivore/raccoon.image");
System.out.println("Path is: " + p);
for (int i = 0; i < p.getNameCount(); i++) {
	System.out.println(" Element " + i + " is: " + p.getName(i));
}
System.out.println();
System.out.println("subpath(0,3): " + p.subpath(0, 3));
System.out.println("subpath(1,2): " + p.subpath(1, 2));
System.out.println("subpath(1,3): " + p.subpath(1, 3));
```

```text
Path is: /mammal/omnivore/raccoon.image
Element 0 is: mammal
Element 1 is: omnivore
Element 2 is: raccoon.image
subpath(0,3): mammal/omnivore/raccoon.image
subpath(1,2): omnivore
subpath(1,3): omnivore/raccoon.image
```

**==Like ``getNameCount()`` and ``getName()``, ``subpath()`` is zero-indexed and does not include the root. Also like ``getName()``, ``subpath()`` throws an exception if invalid indices are provided.==**

```java
var q = p.subpath(0, 4); // IllegalArgumentException
var x = p.subpath(1, 1); // IllegalArgumentException
```
#### Accessing Path Elements

The ``Path`` interface contains numerous methods for retrieving particular elements of a ``Path``, returned as ``Path`` objects themselves. 
- ==**The ``getFileName()`` method returns the ``Path`` element of the current file or directory,**== 
- ==**while ``getParent()`` returns the full path of the containing directory.**== 
- ==**The ``getParent()`` method returns null if operated on the root path or at the top of a relative path.**== 
- ==**The ``getRoot()`` method returns the root element of the file within the file system, or null if the path is a relative path.==**

```java
public void printPathInformation(Path path) {
	System.out.println("Filename is: " + path.getFileName());
	System.out.println(" Root is: " + path.getRoot());
	Path currentParent = path;
while((currentParent = currentParent.getParent()) != null)
	System.out.println(" Current parent is: " + currentParent);
	System.out.println();
}
```

The ``while`` loop in the ``printPathInformation()`` method continues until ``getParent()`` returns null.

```java
printPathInformation(Path.of("zoo"));
printPathInformation(Path.of("/zoo/armadillo/shells.txt"));
printPathInformation(Path.of("./armadillo/../shells.txt"));
```

```text
Filename is: zoo
Root is: null

Filename is: shells.txt
Root is: /
Current parent is: /zoo/armadillo
Current parent is: /zoo
Current parent is: /

Filename is: shells.txt
Root is: null
Current parent is: ./armadillo/..
Current parent is: ./armadillo
Current parent is: .
```

in the first and last examples, the ``getParent()`` method does not traverse relative paths outside the current working directory. these methods do not resolve the path symbols and treat them as a distinct part of the path

#### Resolving Paths

Suppose you want to concatenate paths in a manner similar to how we concatenate strings. **==The ``resolve()`` method provides overloaded versions that let you pass either a ``Path`` or ``String`` parameter. The object on which the ``resolve()`` method is invoked becomes the basis of the new ``Path`` object, with the input argument being appended onto the ``Path``==**

```java
Path path1 = Path.of("/cats/../panther");
Path path2 = Path.of("food");
System.out.println(path1.resolve(path2));
```
```text
/cats/../panther/food
```

Like the other methods ``resolve()`` does not clean up path symbols. In this example, the input argument to the ``resolve()`` method was a relative path, but what if it had been an absolute path?

```java
Path path3 = Path.of("/turkey/food");
System.out.println(path3.resolve("/tiger/cage"));
```
```text
/tiger/cage
```

**==Simply put, you cannot combine two absolute paths using ``resolve()``.==**

---

**On the exam, when you see ``resolve()``, think concatenation.** #TIP 

---
#### Relativizing a Path

The Path interface includes a ``relativize()`` method for constructing the relative path from one ``Path`` to another, often using path symbols.

```java
var path1 = Path.of("fish.txt");
var path2 = Path.of("friendly/birds.txt");
System.out.println(path1.relativize(path2));
System.out.println(path2.relativize(path1));
```
```text
../friendly/birds.txt
../../fish.txt
```

The idea is this: if you are pointed at a path in the file system, what steps would you need to take to reach the other path? For example, to get to fish.txt from friendly/birds.txt, you need to go up two levels (the file itself counts as one level) and then select fish.txt.
**==If both path values are relative, the ``relativize()`` method computes the paths as if they are in the same current working directory. Alternatively, if both path values are absolute, the method computes the relative path from one absolute location to another, regardless of the current working directory.==**

```java
Path path3 = Paths.get("E:\\habitat");
Path path4 = Paths.get("E:\\sanctuary\\raven\\poe.txt");
System.out.println(path3.relativize(path4));
System.out.println(path4.relativize(path3));
```
```text
..\sanctuary\raven\poe.txt
..\..\..\habitat
```

**==The ``relativize()`` method requires both paths to be absolute or relative and throws an exception if the types are mixed.==**

```java
Path path1 = Paths.get("/primate/chimpanzee");
Path path2 = Paths.get("bananas.txt");
path1.relativize(path2); // IllegalArgumentException
```

On Windows-based systems, it also requires that if absolute paths are used, both paths must have the same root directory or drive letter

```java
Path path3 = Paths.get("C:\\primate\\chimpanzee");
Path path4 = Paths.get("D:\\storage\\bananas.txt");
path3.relativize(path4); // IllegalArgumentException
```

#### Normalizing a Path

Java provides the ``normalize()`` method to eliminate unnecessary redundancies in a path. 
the path symbol ``..`` refers to the parent directory, while the path symbol ``.`` refers to the current directory.

```java
var p1 = Path.of("./armadillo/../shells.txt");
System.out.println(p1.normalize()); // shells.txt

var p2 = Path.of("/cats/../panther/food");
System.out.println(p2.normalize()); // /panther/food

var p3 = Path.of("../../fish.txt");
System.out.println(p3.normalize()); // ../../fish.txt
```

The first two examples apply the path symbols to remove the redundancies, but what about the last one? That is as simplified as it can be. **==The ``normalize()`` method does not remove all of the path symbols, only the ones that can be reduced.==**

```java
var p1 = Paths.get("/pony/../weather.txt");
var p2 = Paths.get("/weather.txt");
System.out.println(p1.equals(p2)); // false
System.out.println(p1.normalize().equals(p2.normalize())); // true
```

The ``equals()`` method returns true if two paths represent the same value.
**==This is the primary function of the ``normalize()`` method: to allow us to better compare different paths.==**

#### Retrieving the Real File System Path

While working with theoretical paths is useful, sometimes you want to verify that the path exists within the file system using ``toRealPath()``. This method is similar to ``normalize()`` in that it eliminates any redundant path symbols. It is also similar to ``toAbsolutePath()``, in that it will join the path with the current working directory if the path is relative.

Unlike those two methods, though, ``toRealPath()`` will throw an exception if the path does not exist. In addition, it will follow symbolic links, with an optional ``LinkOption`` varargs parameter to ignore them.

```java
System.out.println(Paths.get("/zebra/food.txt").toRealPath());
System.out.println(Paths.get(".././food.txt").toRealPath());
```
```text
/horse/food.txt
```

#### Reviewing NIO.2 Path APIs

![[Pasted image 20240607111546.png]]

### Creating, Moving, and Deleting Files and Directories

#### Making Directories

To create a directory, we use these ``Files`` methods:

```java
public static Path createDirectory(Path dir, FileAttribute<?>... attrs) throws IOException
public static Path createDirectories(Path dir, FileAttribute<?>... attrs) throws IOException
```

The ``createDirectory()`` method will create a directory and throw an exception if it already exists or if the paths leading up to the directory do not exist. ==**The ``createDirectories()`` method creates the target directory along with any nonexistent parent directories leading up to the path. If all of the directories already exist**==, ``createDirectories()`` will simply complete without doing anything. This is useful in situations where you want to ensure a directory exists and create it if it does not

```java
Files.createDirectory(Path.of("/bison/field"));
Files.createDirectories(Path.of("/bison/field/pasture/green"));
```

#### Copying Files

The ``Files`` class provides a method for copying files and directories within the file system.

```java
public static Path copy(Path source, Path target, CopyOption... options) throws IOException
```

The method copies a file or directory from one location to another using ``Path`` objects.

```java
Files.copy(Paths.get("/panda/bamboo.txt"),
Paths.get("/panda-save/bamboo.txt"));
Files.copy(Paths.get("/turtle"), Paths.get("/turtleCopy"));
```

When directories are copied, the copy is shallow. 
- ==**A shallow copy means that the files and subdirectories within the directory are not copied.**== 
- ==**A deep copy means that the entire tree is copied, including all of its content and subdirectories.==**

```java
public void copyPath(Path source, Path target) {
	try {
		Files.copy(source, target);
		if(Files.isDirectory(source))
			try (Stream<Path> s = Files.list(source)) {
				s.forEach(p ->copyPath(p,target.resolve(p.getFileName())));
			} catch(IOException e) {
				// Handle exception
		}
	}
}
```

##### Copying and Replacing Files

By default, if the target already exists, the ``copy()`` method will throw an exception. You can change this behavior by providing the ``StandardCopyOption`` enum value ``REPLACE_EXISTING`` to the method.

```java
Files.copy(Paths.get("book.txt"), Paths.get("movie.txt"), StandardCopyOption.REPLACE_EXISTING);
```

**==For the exam, you need to know that without the ``REPLACE_EXISTING`` option, this method will throw an exception if the file already exists.==**

##### Copying Files with I/O Streams

The Files class includes two ``copy()`` methods that operate with I/O streams.

```java
public static long copy(InputStream in, Path target, CopyOption... options) throws IOException
public static long copy(Path source, OutputStream out) throws IOException
```

- The first method reads the contents of an I/O stream and writes the output to a file. 
- The second method reads the contents of a file and writes the output to an I/O stream.

```java
try (var is = new FileInputStream("source-data. txt")) {
	// Write I/O stream data to a file
	Files.copy(is, Paths.get("/mammals/wolf.txt"));
}
Files.copy(Paths.get("/fish/clown.xsl"), System.out);
```

##### Copying Files into a Directory

For the exam, it is important that you understand how the ``copy()`` method operates on both files and directories. For example, let’s say we have a file, food.txt, and a directory, /enclosure. Both the file and directory exist. What do you think is the result of executing the following process?

```java
var file = Paths.get("food.txt");
var directory = Paths.get("/enclosure");
Files.copy(file, directory); // Exception
```

It throws an exception. The command tries to create a new file named /enclosure. Since the path /enclosure already exists, an exception is thrown at runtime.

On the other hand, if the directory did not exist, the process would create a new file with the contents of food.txt, but the file would be called /enclosure. Remember, we said files may not need to have extensions, and in this example, it matters. This behavior applies to both the ``copy()`` and ``move()`` method

The correct way to copy the file into the directory is to do the following:

```java
var file = Paths.get("food.txt");
var directory = Paths.get("/enclosure/food.txt");
Files.copy(file, directory);
```

#### Moving or Renaming Paths with ``move()``

The ``Files`` class provides a useful method for moving or renaming files and directories.

```java
public static Path move(Path source, Path target, CopyOption... options) throws IOException
```

```java
Files.move(Path.of("C:\\zoo"), Path.of("C:\\zoo-new"));
Files.move(Path.of("C:\\user\\addresses.txt"), Path.of("C:\\zoo-new\\ addresses2.txt"));
```

##### Similarities between ``move()`` and ``copy()``

Like ``copy()``, ``move()`` requires ``REPLACE_EXISTING`` to overwrite the target if it exists; otherwise, it will throw an exception. Also like ``copy()``, ``move()`` will not put a file in a directory if the source is a file and the target is a directory. Instead, it will create a new file with the name of the directory.

##### Performing an Atomic Move

Another enum value that you need to know for the exam when working with the ``move()`` method is the ``StandardCopyOption`` value ``ATOMIC_MOVE``.

An atomic move is one in which a file is moved within the file system as a single indivisible operation. Put another way, any process monitoring the file system never sees an incomplete or partially written file. If the file system does not support this feature, an ``AtomicMoveNotSupportedException`` will be thrown.
**==Note that while ``ATOMIC_MOVE`` is available as a member of the ``StandardCopyOption`` type, it will likely throw an exception if passed to a ``copy()`` method.==**

#### Deleting a File with ``delete()`` and ``deleteIfExists()``

```java
public static void delete(Path path) throws IOException
public static boolean deleteIfExists(Path path) throws IOException
```

**==To delete a directory, it must be empty==**. Both of these methods throw an exception if operated on a nonempty directory. In addition, **==if the path is a symbolic link, the symbolic link will be deleted, not the path that the symbolic link points to==**

The methods differ on how they handle a path that does not exist. The ``delete()`` method throws an exception if the path does not exist, while the ``deleteIfExists()`` method returns true if the delete was successful or false otherwise.

```java
Files.delete(Paths.get("/vulture/feathers.txt"));
Files.deleteIfExists(Paths.get("/pigeon"));
```

### Comparing Files with ``isSameFile()`` and ``mismatch()``

Since a path may include path symbols and symbolic links within a file system, the ``equals()`` method can’t be relied on to know if two ``Path`` instances refer to the same file. Luckily, there is the ``isSameFile()`` method. This method takes two ``Path`` objects as input, resolves all path symbols, and follows symbolic links. Despite the name, the method can also be used to determine whether two ``Path`` objects refer to the same directory.

While most uses of ``isSameFile()`` will trigger an exception if the paths do not exist, there is a special case in which it does not. If the two path objects are equal in terms of equals(), the method will just return true without checking whether the file exists.

![[Pasted image 20240607152227.png]]

```java
System.out.println(Files.isSameFile(Path.of("/animals/cobra"),Path.of("/animals/snake")));

System.out.println(Files.isSameFile( Path.of("/animals/monkey/ears.png"),Path.of("/animals/wolf/ears.png")));
```

Since snake is a symbolic link to cobra, the first example outputs true. In the second example, the paths refer to different files, so false is printed.

Sometimes you want to compare the contents of the file rather than whether it is physically the same file.
The ``mismatch()`` method was introduced in Java 12 to help us out here. It takes two ``Path`` objects as input. The method returns -1 if the files are the same; otherwise, it returns the index of the first position in the file that differs.

```java
System.out.println(Files.mismatch( Path.of("/animals/monkey.txt"), Path.of("/animals/wolf.txt")));
```

```java
System.out.println(Files.mismatch( Path.of("/animals/wolf.txt"), Path.of("/animals/monkey.txt")));
```

## Introducing I/O Streams

The “I/O” refers to the nature of how data is accessed, either by reading the data from a resource (input) or by writing the data to a resource (output).

### Understanding I/O Stream Fundamentals

The contents of a file may be accessed or written via an I/O stream, which is a list of data elements presented sequentially. An I/O stream can be conceptually thought of as a long, nearly never-ending stream of water with data presented one wave at a time.

![[Pasted image 20240608110359.png]]

Each type of I/O stream segments data into a wave or block in a particular way. For example, some I/O stream classes read or write data as individual bytes. Other I/O stream classes read or write individual characters or strings of characters. On top of that, some I/O stream classes read or write larger groups of bytes or characters at a time, specifically those with the word Buffered in their name.

Although I/O streams are commonly used with file I/O, they are more generally used to handle the reading/writing of any sequential data source

---

**I/O Streams Can Be Big**

**When writing code where you don’t know what the I/O stream size will be at runtime, it may be helpful to visualize an I/O stream as being so large that all of the data contained in it could not possibly fit into memory. For example, a 1 TB file could not be stored entirely in memory by most computer systems (at the time this book is being written). The file can still be read and written by a program with very little memory, since the I/O stream allows the application to focus on only a small portion of the overall I/O stream at any given time.**

---
### Learning I/O Stream Nomenclature

#### Storing Data as Bytes

Data is stored in a file system (and memory) as a 0 or 1, called a bit. Since it’s really hard for humans to read/write data that is just 0s and 1s, they are grouped into a set of 8 bits, called a byte.

#### Byte Streams vs. Character Streams

The java.io API defines two sets of I/O stream classes for reading and writing I/O streams: byte I/O streams and character I/O streams.

**Differences between Byte and Character I/O Streams**

-  ==**Byte I/O streams read/write binary data (0s and 1s) and have class names that end  in ``InputStream`` or ``OutputStream``.**==
-  ==**Character I/O streams read/write text data and have class names that end in ``Reader`` or ``Writer``.==**

The API frequently includes similar classes for both byte and character I/O streams, such as ``FileInputStream`` and ``FileReader``. **==The difference between the two classes is based on how the bytes are read or written.==**

It is important to remember that even though character I/O streams do not contain the word Stream in their class name, they are still I/O streams. **==The use of Reader/Writer in the name is just to distinguish them from byte streams.==**

**==The byte I/O streams are primarily used to work with binary data, such as an image or executable file, while character I/O streams are used to work with text files.==**

The character encoding determines how characters are encoded and stored in bytes in an I/O stream and later read back or decoded as characters. Although this may sound simple, Java supports a wide variety of character encodings, ranging from ones that may use one byte for Latin characters, UTF-8 and ASCII for example, to using two or more bytes per character, such as UTF-16

---

**Character Encoding in Java**

In Java, the character encoding can be specified using the Charset class by passing a name value to the static ``Charset.forName()`` method, such as in the following examples:

```java
Charset usAsciiCharset = Charset.forName("US-ASCII");
Charset utf8Charset = Charset.forName("UTF-8");
Charset utf16Charset = Charset.forName("UTF-16");
```

---

#### Input vs. Output Streams

Most ``InputStream`` classes have a corresponding ``OutputStream`` class, and vice versa. It follows, then, that most ``Reader`` classes have a corresponding ``Writer`` class.
 
 **==There are exceptions to this rule. For the exam, you should know that ``PrintWriter`` has no accompanying ``PrintReader`` class. Likewise, the ``PrintStream`` is an ``OutputStream`` that has no corresponding ``InputStream`` class. It also does not have Output in its name==**

#### Low-Level vs. High-Level Streams

- low-level stream connects directly with the source of the data, such as a file, an array, or a String. Low-level I/O streams process the raw data or resource and are accessed in a direct and unfiltered manner. For example, a ``FileInputStream`` is a class that reads file data one byte at a time.

- high-level stream is built on top of another I/O stream using wrapping. Wrapping is the process by which an instance is passed to the constructor of another class, and operations on the resulting instance are filtered and applied to the original instance. For example, take a look at the ``FileReader`` and ``BufferedReader``

```java
try (var br = new BufferedReader(new FileReader("zoo-data.txt"))) {
	System.out.println(br.readLine());
}
```

``FileReader`` is the low-level I/O stream, whereas ``BufferedReader`` is the high-level I/O stream that takes a ``FileReader`` as input. Many operations on the high-level I/O stream pass through as operations to the underlying low-level I/O stream, such as ``read()`` or ``close()``. Other operations override or add new functionality to the low-level I/O stream methods. The high-level I/O stream may add new methods, such as ``readLine()``, as well as performance enhancements for reading and filtering the low-level data.

```java
try (var ois = new ObjectInputStream( new BufferedInputStream( new FileInputStream("zoo-data.txt")))) {
	System.out.print(ois.readObject());
}
```

In this example, the low-level ``FileInputStream`` interacts directly with the file, which is wrapped by a high-level ``BufferedInputStream`` to improve performance. Finally, the entire object is wrapped by another high-level ``ObjectInputStream``, which allows us to interpret the data as a Java object.

#### Stream Base Classes

**==The java.io library defines four abstract classes that are the parents of all I/O stream classes defined within the API: ``InputStream``, ``OutputStream``, ``Reader``, and ``Writer``==**. The constructors of high-level I/O streams often take a reference to the abstract class

One common area where the exam likes to play tricks on you is mixing and matching I/O stream classes that are not compatible with each other.

```java
new BufferedInputStream(new FileReader("z.txt")); // DOES NOT COMPILE
new BufferedWriter(new FileOutputStream("z.txt")); // DOES NOT COMPILE
new ObjectInputStream( new FileOutputStream("z.txt")); // DOES NOT COMPILE
new BufferedInputStream(new InputStream()); // DOES NOT COMPILE
```

- The third example does not compile because we are mixing an ``OutputStream`` with an ``InputStream``. Although it is possible to read data from an ``InputStream`` and write it to an ``OutputStream``, wrapping the I/O stream is not the way to do so. the data must be copied over.
- the last example does not compile because ``InputStream`` is an abstract class, and therefore you cannot create an instance of it.

#### Decoding I/O Class Names

Pay close attention to the name of the I/O class on the exam, as decoding it often gives you context clues as to what the class does.

![[Pasted image 20240608112540.png]]

![[Pasted image 20240608112548.png]]
![[Pasted image 20240608112608.png]]

## Reading and Writing Files

### Using I/O Streams
 
 I/O streams are all about reading/writing data, so it shouldn’t be a surprise that the most important methods are ``read()`` and ``write()``. Both ``InputStream`` and ``Reader`` declare a ``read()`` method to read byte data from an I/O stream. Likewise, ``OutputStream`` and Writer both define a ``write()`` method to write a byte to the stream:
 
```java
void copyStream(InputStream in, OutputStream out) throws IOException {
	int b;
	while ((b = in.read()) != -1)
	{
		out.write(b);
	}
}
void copyStream(Reader in, Writer out) throws IOException {
	int b;
	while ((b = in.read()) != -1)
	{
		out.write(b);
	}
}
```

reading and writing bytes, so why do the methods use int instead of byte? Remember, the byte data type has a range of 256 characters. They needed an extra value to indicate the end of an I/O stream. The authors of Java decided to use a larger data type, int, so that special values like -1 would indicate the end of an I/O stream. The output stream classes use int as well, to be consistent with the input stream classes.

Reading and writing one byte at a time isn’t a particularly efficient way of doing this. Luckily, there are overloaded methods for reading and writing multiple bytes at a time. The offset and length values are applied to the array itself. For example, an offset of 3 and length of 5 indicates that the stream should read up to five bytes/characters of data and put them into the array starting with position 3

```java
10: void copyStream(InputStream in, OutputStream out) throws IOException {
11: int batchSize = 1024;
12: var buffer = new byte[batchSize];
13: int lengthRead;
14: while ((lengthRead = in.read(buffer, 0, batchSize)) > 0) {
	15: out.write(buffer, 0, lengthRead);
	16: out.flush();
17: }
```

Instead of reading the data one byte at a time, we read and write up to 1024 bytes at a time on line 14. The return value ``lengthRead`` is critical for determining whether we are at the end of the stream and knowing how many bytes we should write into our output stream. 

Unless our file happens to be a multiple of 1024 bytes, the last iteration of the while loop will write some value less than 1024 bytes. For example, if the buffer size is 1,024 bytes and the file size is 1,054 bytes, the last read will be only 30 bytes. If we ignored this return value and instead wrote 1,024 bytes, 994 bytes from the previous loop would be written to the end of the file.

We also added a ``flush()`` method on line 16 to reduce the amount of data lost if the application terminates unexpectedly. **==When data is written to an output stream, the underlying operating system does not guarantee that the data will make it to the file system immediately. The ``flush()`` method requests that all accumulated data be written immediately to disk. It is not without cost, though==**. Each time it is used, it may cause a noticeable delay in the application, especially for large files. Unless the data that you are writing is extremely critical, the ``flush()`` method should be used only intermittently

Equivalent methods exist on ``Reader`` and ``Writer``, but they use char rather than byte, making the equivalent ``copyStream()`` method very similar.

```java
26: void copyTextFile(File src, File dest) throws IOException {
	27: try (var reader = new BufferedReader(new FileReader(src));
		28: var writer = new BufferedWriter(new FileWriter(dest))) {
		29: String line = null;
		30: while ((line = reader.readLine()) != null) {
			31: writer.write(line);
			32: writer.newLine();
		33: } 
	} 
}
```

**==The key is to choose the most useful high-level classes==**. In this case, we are dealing with a ``File``, so we want to use a ``FileReader`` and ``FileWriter``. Both classes have constructors that can take either a ``String`` representing the location or a ``File`` directly.

If the source file does not exist, a ``FileNotFoundException``, which inherits ``IOException``, will be thrown. If the destination file already exists, this implementation will overwrite it. We can pass an optional boolean second parameter to ``FileWriter`` for an append flag if we want to change this behavior.

We also chose to use a ``BufferedReader`` and ``BufferedWriter`` so we can read a whole line at a time. This gives us the benefits of reading batches of characters on line 30 without having to write custom logic. Line 31 writes out the whole line of data at once. Since reading a line strips the line breaks, we add those back on line 32. Lines 27 and 28 demonstrate chaining constructors. The try-with- resources constructor takes care of closing all the objects in the chain.

We can do a little better than ``BufferedOutputStream`` and ``BufferedWriter`` by using a ``PrintStream`` and ``PrintWriter``. These classes contain four key methods. The ``print()`` and ``println()`` methods print data with and without a new line, respectively. There are also the ``format()`` and ``printf()`` methods, 

```java
void copyTextFile(File src, File dest) throws IOException {
	try (var reader = new BufferedReader(new FileReader(src));
		var writer = new PrintWriter(new FileWriter(dest))) {
		String line = null;
		while ((line = reader.readLine()) != null)
			writer.println(line);
		}
}
```

**==The print stream classes have the distinction of being the only I/O stream classes we cover that do not have corresponding input stream classes==**. And unlike other ``OutputStream`` classes, ``PrintStream`` does not have Output in its name.

Unlike the majority of the other I/O streams we’ve covered, **==the methods in the print stream classes do not throw any checked exceptions==**. If they did, you would be required to catch a checked exception any time you called ``System.out.print()``!

The line separator is \n or \r\n, depending on your operating system. The ``println()`` method takes care of this for you. If you need to get the character directly, either of the following will return it for you:

```java
System.getProperty("line.separator");
System.lineSeparator();
```

### Enhancing with Files

The NIO.2 APIs provide even easier ways to read and write a file using the ``Files`` class.

```java
private void copyPathAsString(Path input, Path output) throws IOException {
    String string = Files.readString(input);
    Files.writeString(output, string);
}

private void copyPathAsBytes(Path input, Path output) throws IOException {
    byte[] bytes = Files.readAllBytes(input);
    Files.write(output, bytes);
}

private void copyPathAsLines(Path input, Path output) throws IOException {
    List<String> lines = Files.readAllLines(input);
    Files.write(output, lines);
}
```

That’s pretty concise! You can read a ``Path`` as a ``String``, a byte array, or a List. Be aware that the entire file is read at once for all three of these, thereby storing all of the contents of the file in memory at the same time. If the file is significantly large, you may trigger an ``OutOfMemoryError`` when trying to load all of it into memory. Luckily, there is an alternative.

```java
private void readLazily(Path path) throws IOException {
	try (Stream<String> s = Files.lines(path)) {
		s.forEach(System.out::println);
	}
}
```

Now the contents of the file are read and processed lazily, which means that only a small portion of the file is stored in memory at any given time.

```java
try (var s = Files.lines(path)) {
	s.filter(f -> f.startsWith("WARN:"))
	.map(f -> f.substring(5))
	.forEach(System.out::println);
}
```

This sample code searches a log for lines that start with WARN:, outputting the text that follows. Assuming that the input file sharks.log is as follows:

```text
INFO:Server starting
DEBUG:Processes available = 10
WARN:No database could be detected
DEBUG:Processes available reset to 0
WARN:Performing manual recovery
INFO:Server successfully started
```

Then the sample output would be the following

```text
No database could be detected
Performing manual recovery
```

---
``Files.readAllLines()`` vs. ``Files.lines()``

For the exam, you need to know the difference between ``readAllLines()`` and ``lines()``. Both of these examples compile and run:

```java
Files.readAllLines(Paths.get("birds.txt")).forEach(System.out::println);
Files.lines(Paths.get("birds.txt")).forEach(System.out::println);
```

The first line reads the entire file into memory and performs a print operation on the result, while the second line lazily processes each line and prints it as it is read. The advantage of the second code snippet is that it does not require the entire file to be stored in memory at any time.

You should also be aware of when they are mixing incompatible types on the exam

```java
Files.readAllLines(Paths.get("birds.txt"))
	.filter(s ->s.length()> 2)
	.forEach(System.out::println);
```

**==The ``readAllLines()`` method returns a List, not a ``Stream``, so the ``filter()`` method is not available==**

---

### Combining with ``newBufferedReader()`` and ``newBufferedWriter()``

Sometimes you need to mix I/O streams and NIO.2. Conveniently, ``Files`` includes two convenience methods for getting I/O streams.

```java
private void copyPath(Path input, Path output) throws IOException {
    try (var reader = Files.newBufferedReader(input);
         var writer = Files.newBufferedWriter(output)) {
        String line = null;
        while ((line = reader.readLine()) != null) {
            writer.write(line);
            writer.newLine();
        }
    }
}
```

You can wrap I/O stream constructors to produce the same effect, although it’s a lot easier to use the factory method. The first method, ``newBufferedReader()``, reads the file specified at the Path location using a ``BufferedReader`` object.

### Reviewing Common Read and Write Methods

![[Pasted image 20240608120203.png]]
![[Pasted image 20240608120214.png]]
![[Pasted image 20240608120233.png]]
## Serializing Data

Serialization is the process of converting an in-memory object to a byte stream. Likewise, deserialization is the process of converting from a byte stream into an object. Serialization often involves writing an object to a stored or transmittable format, while deserialization is the reciprocal process.

![[Pasted image 20240608132812.png]]

### Applying the Serializable Interface

To serialize an object using the I/O API, the object must implement the ``java.io.Serializable`` interface. The ``Serializable`` interface is a marker interface, which means it does not have any methods. Any class can implement the ``Serializable`` interface since there are no required methods to implement.

The purpose of using the ``Serializable`` interface is to inform any process attempting to serialize the object that you have taken the proper steps to make the object serializable. 

```java
import java.io.Serializable;
public class Gorilla implements Serializable {
	private static final long serialVersionUID = 1L;
	private String name;
	private int age;
	private Boolean friendly;
	private transient String favoriteFood;
	// Constructors/Getters/Setters/toString() omitted
}
```

Note that since ``Serializable`` is not part of the`` java.lang`` package, it must be imported or referenced with the package name. **==Any field that is marked ``transient`` will not be saved to an I/O stream when the class is serialized==**

---

**Maintaining a ``serialVersionUID``**

**It’s a good practice to declare a ``static serialVersionUID`` variable in every class that implements ``Serializable``. The version is stored with each object as part of serialization. Then, every time the class structure changes, this value is updated or incremented**

**Perhaps our ``Gorilla`` class receives a new instance member ``Double banana``, or maybe the ``age`` field is renamed. The idea is a class could have been serialized with an older version of the class and deserialized with a newer version of the class.**


**The ``serialVersionUID`` helps inform the JVM that the stored data may not match the new class definition. If an older version of the class is encountered during deserialization, a ``java.io.InvalidClassException`` may be thrown. Alternatively, some APIs support converting data between versions.**

---

### Marking Data ``transient``

The ``transient`` modifier can be used for sensitive data of the class, like a password. There are other objects it does not make sense to serialize, like the state of an in-memory Thread. If the object is part of a serializable object, we just mark it transient to ignore these select instance members.
**==What happens to data marked ``transient`` on deserialization? It reverts to its default Java values, such as 0.0 for double, or null for an object==**

---

**Marking ``static`` fields ``transient`` has little effect on serialization. Other than the ``serialVersionUID``, only the instance members of a class are serialized.**

---

### Ensuring That a Class Is Serializable

Since ``Serializable`` is a marker interface, you might think there are no rules to using it. Not quite! Any process attempting to serialize an object will throw a ``NotSerializableException`` if the class does not implement the Serializable interface properly.

**How to Make a Class Serializable**
-  ==**The class must be marked ``Serializable``.**==
-  ==**Every instance member of the class must be serializable, marked ``transient``, or have a null value at the time of serialization==**

**==Be careful with the second rule. For a class to be serializable, we must apply the second rule recursively.==**

```java
public class Cat implements Serializable {
	private Tail tail = new Tail();
}
public class Tail implements Serializable {
	private Fur fur = new Fur();
}
public class Fur {}
```

``Cat`` contains an instance of ``Tail``, and both of those classes are marked ``Serializable``, so no problems there. Unfortunately, ``Tail`` contains an instance of ``Fur`` that is not marked ``Serializable``.
Either of the following changes fixes the problem and allows ``Cat`` to be serialized:

```java
public class Tail implements Serializable {
	private transient Fur fur = new Fur();
}
public class Fur implements Serializable {}
```

We could also make our ``tail`` or ``fur`` instance members null, although this would make ``Cat`` serializable only for particular instances, rather than all instances.

---

**Serializing Records**
**Do you think this record is serializable?**
```java
record Record(String name) {}
```

**It is not serializable because it does not implement Serializable. A record follows the same rules as other types of classes with respect to whether it can be serialized. Therefore, this one can be:**

```java
record Record(String name) implements Serializable {}
```

---

### Storing Data with ``ObjectOutputStream`` and ``ObjectInputStream``

The ``ObjectInputStream`` class is used to deserialize an object, while the ``ObjectOutputStream`` is used to serialize an object. They are high-level streams that operate on existing I/O streams. While both of these classes contain a number of methods for built-in data types like primitives, the two methods you need to know for the exam are the ones related to working with objects.

```java
// ObjectInputStream
public Object readObject() throws IOException, ClassNotFoundException

// ObjectOutputStream
public void writeObject(Object obj) throws IOException
```

Note the parameters, return types, and exceptions thrown

```java
void saveToFile(List<Gorilla> gorillas, File dataFile) throws IOException {
	try (var out = new ObjectOutputStream(
		new BufferedOutputStream(
		new FileOutputStream(dataFile)))) {
		for (Gorilla gorilla : gorillas)
			out.writeObject(gorilla);
	}
}

```

```java
List<Gorilla> readFromFile(File dataFile) throws IOException, ClassNotFoundException {
	var gorillas = new ArrayList<Gorilla>();
	try (var in = new ObjectInputStream(
		new BufferedInputStream(
		new FileInputStream(dataFile)))) {
		while (true) {
		var object = in.readObject();
		if (object instanceof Gorilla g)
			gorillas.add(g);
		}
	} catch (EOFException e) {
		// File end reached
	}
	return gorillas;
}
```

When calling ``readObject()``, null and -1 do not have any special meaning, as someone might have serialized objects with those values. Unlike our earlier techniques for reading methods from an input stream, we need to use an infinite loop to process the data, which throws an ``EOFException`` when the end of the I/O stream is reached.

Since the return type of ``readObject()`` is Object, we need to check the type before obtaining access to our Gorilla properties. Notice that ``readObject()`` declares a checked ``ClassNotFoundException`` since the class might not be available on deserialization.

```java
var gorillas = new ArrayList<Gorilla>();
gorillas.add(new Gorilla("Grodd", 5, false));
gorillas.add(new Gorilla("Ishmael", 8, true));
File dataFile = new File("gorilla.data");

saveToFile(gorillas, dataFile);
var gorillasFromDisk = readFromFile(dataFile);
System.out.print(gorillasFromDisk);
```
```text
[[name=Grodd, age=5, friendly=false],
[name=Ishmael, age=8, friendly=true]]
```

### Understanding the Deserialization Creation Process

When you deserialize an object, the constructor of the serialized class, along with any instance initializers, is not called when the object is created. **==Java will call the no-arg constructor of the first non-serializable parent class it can find in the class hierarchy==**. In our Gorilla example, this would just be the no-arg constructor of Object.
**==any ``static`` or ``transient`` fields are ignored. Values that are not provided will be given their default Java value, such as null for ``String``, or 0 for int values.==**

```java
import java.io.Serializable;

public class Chimpanzee implements Serializable {
    private static final long serialVersionUID = 2L;
    private transient String name;
    private transient int age = 10;
    private static char type = 'C';

    {
        this.age = 14;
    }

    public Chimpanzee() {
        this.name = "Unknown";
        this.age = 12;
        this.type = 'Q';
    }

    public Chimpanzee(String name, int age, char type) {
        this.name = name;
        this.age = age;
        this.type = type;
    }

    // Getters/Setters/toString() omitted
}
```

```java
var chimpanzees = new ArrayList<Chimpanzee>();
chimpanzees.add(new Chimpanzee("Ham", 2, 'A'));
chimpanzees.add(new Chimpanzee("Enos", 4, 'B'));
File dataFile = new File("chimpanzee.data");

saveToFile(chimpanzees, dataFile);
var chimpanzeesFromDisk = readFromFile(dataFile);
System.out.println(chimpanzeesFromDisk);
```

none of the instance members are serialized to a file. The ``name`` and ``age`` variables are both marked transient, ``while`` the type variable is ``static``. 

Even the no-arg constructor that sets the values ``[name=Unknown,age=12,type=Q]`` is ignored. The instance initializer that sets age to 14 is also not executed. 

In this case, the name variable is initialized to null since that’s the default value for ``String`` in Java. Likewise, the age variable is initialized to 0. The program prints the following, assuming the ``toString()`` method is implemented:

```text
[[name=null,age=0,type=B],
[name=null,age=0,type=B]]
```

the type variable? Since it’s ``static``, it will display whatever value was set last. If the data is serialized and deserialized within the same execution, it will display B, since that was the last ``Chimpanzee`` we created. On the other hand, if the program performs the deserialization and print on startup, it will print C, since that is the value the class is initialized with.

**==For the exam, make sure you understand that the constructor and any instance initializations defined in the serialized class are ignored during the deserialization process. Java only calls the constructor of the first non-serializable parent class in the class hierarchy.==**

```java
public class BabyChimpanzee extends Chimpanzee {
	private static final long serialVersionUID = 3L;
	private String mother = "Mom";
	public BabyChimpanzee() { super(); }
	public BabyChimpanzee(String name, char type) {
		super(name, 0, type);
	}
// Getters/Setters/toString() omitted
}
```

## Interacting with Users

### Printing Data to the User

Java includes two ``PrintStream`` instances for providing information to the user: ``System.out`` and ``System.err``. While ``System.out`` should be old hat to you, ``System.err`` might be new to you. The syntax for calling and using ``System.err`` is the same as ``System.out`` but is used to report errors to the user in a separate I/O stream from the regular output information.

```java
try (var in = new FileInputStream("zoo.txt")) {
	System.out.println("Found file!");
} catch (FileNotFoundException e) {
	System.err.println("File not found!");
}
```

### Reading Input as an I/O Stream

The ``System.in`` returns an ``InputStream`` and is used to retrieve text input from the user. It is commonly wrapped with a ``BufferedReader`` via an ``InputStreamReader`` to use the ``readLine()`` method.

```java
var reader = new BufferedReader(new InputStreamReader(System.in));
String userInput = reader.readLine();
System.out.println("You entered: " + userInput);
```

### Closing System Streams

these are the only I/O streams in the entire chapter that we did not use a try-with- resources block on! Because these are ``static`` objects, the System streams are shared by the entire application. The JVM creates and opens them for us. They can be used in a try-with- resources statement or by calling ``close()``, **==although closing them is not recommended. Closing the System streams makes them permanently unavailable for all threads in the remainder of the program.==**

```java
try (var out = System.out) {}
System.out.println("Hello");
```

The methods of ``PrintStream`` do not throw any checked exceptions and rely on the ``checkError()`` to report errors, so they fail silently.

```java
try (var err = System.err) {}
System.err.println("Hello");
```

This one also prints nothing. Like ``System.out``, ``System.err`` is a ``PrintStream``. Even if it did throw an exception, we’d have a hard time seeing it since our I/O stream for reporting errors is closed!

```java
var reader = new BufferedReader(new InputStreamReader(System.in));
try (reader) {}
String data = reader.readLine(); // IOException
```

It prints an exception at runtime. Unlike the ``PrintStream`` class, most ``InputStream`` implementations will throw an exception if you try to operate on a closed I/O stream.
### Acquiring Input with Console

The`` java.io.Console`` class is specifically designed to handle user interactions. After all, ``System.in`` and ``System.out`` are just raw streams, whereas ``Console`` is a class with numerous methods centered around user input. 
The Console class is a singleton because it is accessible only from a factory method and only one instance of it is created by the JVM.

```java
Console c = new Console(); // DOES NOT COMPILE
```

```java
if (console != null) {
	String userInput = console.readLine();
	console.writer().println("You entered: " + userInput);
} else {
	System.err.println("Console not available");
}
```

---

**The ``Console`` object may not be available, depending on where the code is being called. If it is not available, ``System.console()`` returns null. It is imperative that you check for a null value before attempting to use a ``Console`` object!**

---
#### Obtaining Underlying I/O Streams

The Console class includes access to two streams for reading and writing data.

```java
public Reader reader()
public PrintWriter writer()
```

Accessing these classes is analogous to calling ``System.in`` and ``System.out`` directly, although they use character streams rather than byte streams. In this manner, they are more appropriate for handling text data.

#### Formatting Console Data

```java
// PrintStream
public PrintStream format(String format, Object... args)
public PrintStream format(Locale loc, String format, Object... args)
// PrintWriter
public PrintWriter format(String format, Object... args)
public PrintWriter format(Locale loc, String format, Object... args)
```

```java
Console console = System.console();
if (console == null) {
	throw new RuntimeException("Console not available");
} else {
	console.writer().println("Welcome to Our Zoo!");
	console.format("It has %d animals and employs %d people", 391, 25);
	console.writer().println();
	console.printf("The zoo spans %5.1f acres", 128.91);
}
```

```text
Welcome to Our Zoo!
It has 391 animals and employs 25 people
The zoo spans 128.9 acres.
```

---

**Using ``Console`` with a ``Locale``**

**Unlike the print stream classes, ``Console`` does not include an overloaded ``format()`` method that takes a ``Locale`` instance. Instead, ==Console relies on the system locale==. Of course, you could always use a specific ``Locale`` by retrieving the ``Writer`` object and passing your own ``Locale`` instance, such as in the following example:**

```java
Console console = System.console();
console.writer().format(new Locale("fr", "CA"), "Hello World");
```

---
#### Reading Console Data

```java
public String readLine()
public String readLine(String fmt, Object... args)

public char[] readPassword()
public char[] readPassword(String fmt, Object... args)
```

The ``readPassword()`` methods are similar to the ``readLine()`` method, with two important differences:

-  ==**The text the user types is not echoed back and displayed on the screen as they are typing.**==
-  ==**The data is returned as a ``char[]`` instead of a ``String``.==**

**==The second feature involves preventing passwords from entering the ``String`` pool.==**

#### Reviewing Console Methods

```java
Console console = System.console();
if (console == null) {
    throw new RuntimeException("Console not available");
} else {
    String name = console.readLine("Please enter your name: ");
    console.writer().format("Hi %s", name);
    console.writer().println();
    console.format("What is your address? ");
    String address = console.readLine();
    char[] password = console.readPassword("Enter a password between %d and %d characters: ", 5, 10);
    char[] verify = console.readPassword("Enter the password again: ");
    console.printf("Passwords " + (Arrays.equals(password, verify) ? "match" : "do not match"));
}

```

```text
Please enter your name: Max
Hi Max
What is your address? Spoonerville
Enter a password between 5 and 10 characters:
Enter the password again:
Passwords match
```

## Working with Advanced APIs

All input stream classes include the following methods to manipulate the order in which data is read from an I/O stream:

```java
// InputStream and Reader
public boolean markSupported()
public void mark(int readLimit)
public void reset() throws IOException
public long skip(long n) throws IOException
```

**==The ``mark()`` and ``reset()`` methods return an I/O stream to an earlier position. Before calling either of these methods, you should call the ``markSupported()`` method, which returns true only if ``mark()`` is supported.==** The ``skip()`` method is pretty simple; it basically reads data from the I/O stream and discards the contents.

---

Not all input stream classes support ``mark()`` and ``reset()``. Make sure to call ``markSupported()`` on the I/O stream before calling these methods, or an exception will be thrown at runtime.

---
#### Marking Data

Assume that we have an ``InputStream`` instance whose next values are ``LION``.

```java
public void readData(InputStream is) throws IOException {
System.out.print((char) is.read()); // L
if (is.markSupported()) {
	is.mark(100); // Marks up to 100 bytes
	System.out.print((char) is.read()); // I
	System.out.print((char) is.read()); // O
	is.reset(); // Resets stream to position before I
}
System.out.print((char) is.read()); // I
System.out.print((char) is.read()); // O
System.out.print((char) is.read()); // N
}
```

The code snippet will output ``LIOION`` if ``mark()`` is supported and ``LION`` otherwise. It’s a good practice to organize your ``read()`` operations so that the I/O stream ends up at the same position regardless of whether ``mark()`` is supported.

What about the value of 100 that we passed to the mark() method? This value is called the ``readLimit``. It instructs the I/O stream that we expect to call ``reset()`` after at most 100 bytes. If our program calls ``reset()`` after reading more than 100 bytes from calling ``mark(100)``, it may throw an exception, depending on the I/O stream class.

---

**In actuality, ``mark()`` and ``reset()`` are not putting the data back into the I/O stream but are storing the data in a temporary buffer in memory to be read again. Therefore, you should not call the ``mark()`` operation with too large a value, as this could take up a lot of memory.**

---
#### Skipping Data

Assume that we have an ``InputStream`` instance whose next values are ``TIGERS``.

```java
System.out.print ((char)is.read()); // T
is.skip(2); // Skips I and G
is.read(); // Reads E but doesn't output it
System.out.print((char)is.read()); // R
System.out.print((char)is.read()); // S
```

This code prints TRS at runtime. We skipped two characters, I and G. We also read E but didn’t use it anywhere, so it behaved like calling ``skip(1)``. 

The return parameter of ``skip()`` tells us how many values were skipped. **==For example, if we are near the end of the I/O stream and call ``skip(1000)``, the return value might be 20, indicating that the end of the I/O stream was reached after 20 values==** were skipped. Using the return value of ``skip()`` is important if you need to keep track of where you are in an I/O stream and how many bytes have been processed.

#### Reviewing Manipulation APIs

![[Pasted image 20240608175052.png]]

### Discovering File Attributes

#### Checking for Symbolic Links

the ``Files`` class has methods called ``isDirectory()`` and ``isRegularFile()``, which are similar to the ``isDirectory()`` and ``isFile()`` methods on File. While the File object can’t tell you if a reference is a symbolic link, the ``isSymbolicLink()`` method on ``Files`` can.

It is possible for ``isDirectory()`` or ``isRegularFile()`` to return true for a symbolic link, as long as the link resolves to a directory or regular file, respectively.

```java
System.out.print(Files.isDirectory(Paths.get("/canine/fur.jpg")));
System.out.print(Files.isSymbolicLink(Paths.get("/canine/coyote")));
System.out.print(Files.isRegularFile(Paths.get("/canine/types.txt")));
```

- The first example prints true if fur.jpg is a directory or a symbolic link to a directory and false otherwise.
- The second example prints true if /canine/coyote is a symbolic link, regardless of whether the file or directory it points to exists.
- The third example prints true if types.txt points to a regular file or a symbolic link that points to a regular file.

#### Checking File Accessibility

In many file systems, it is possible to set a boolean attribute to a file that marks it hidden, readable, or executable. The Files class includes methods that expose this information: ``isHidden()``, ``isReadable()``, ``isWriteable()``, and ``isExecutable()``.

```java
System.out.print(Files.isHidden(Paths.get("/walrus.txt")));
System.out.print(Files.isReadable(Paths.get("/seal/baby.png")));
System.out.print(Files.isWritable(Paths.get("dolphin.txt")));
System.out.print(Files.isExecutable(Paths.get("whale.png")));
```

- If the walrus.txt file exists and is hidden within the file system, the first example prints true.
- The second example prints true if the baby.png file exists and its contents are readable.
- The third example prints true if the dolphin.txt file can be modified.
- Finally, the last example prints true if the file can be executed within the operating system

Note that the file extension does not necessarily determine whether a file is executable.

#### Improving Attribute Access

Put simply, it is far more efficient to ask the file system for all of the attributes at once rather than performing multiple round trips to the file system. Furthermore, some attributes are file system–specific and cannot be easily generalized for all file systems.
NIO.2 addresses both of these concerns by allowing you to construct views for various file systems with a single method call. A view is a group of related attributes for a particular file system type. If you need to read only one attribute of a file or directory, requesting a view is unnecessary.

##### Understanding Attribute and View Types

NIO.2 includes two methods for working with attributes in a single method call: a read-only attributes method and an updatable view method. For each method, you need to provide a file system type object, which tells the NIO.2 method which type of view you are requesting. **==By updatable view, we mean that we can both read and write attributes with the same object.==** For the exam, you only need to know about the basic file attribute types. The other views are for managing operating system–specific information.

![[Pasted image 20240608180146.png]]
##### Retrieving Attributes

The ``Files`` class includes the following method to read attributes of a class in a read-only capacity:

```java
public static <A extends BasicFileAttributes> A readAttributes(
Path path,
Class<A> type,
LinkOption... options) throws IOException
```

Applying it requires specifying the ``Path`` and ``BasicFileAttributes.class`` parameters.

```java
var path = Paths.get("/turtles/sea.txt");
BasicFileAttributes data = Files.readAttributes(path, BasicFileAttributes.class);

System.out.println("Is a directory? " + data.isDirectory());
System.out.println("Is a regular file? " + data.isRegularFile());
System.out.println("Is a symbolic link? " + data.isSymbolicLink());
System.out.println("Size (in bytes): " + data.size());
System.out.println("Last modified: " + data.lastModifiedTime());

```

The advantage of using this method, though, is that all of the attributes are retrieved at once for some operating systems.
##### Modifying Attributes

The following ``Files`` method returns an updatable view:

```java
public static <V extends FileAttributeView> V getFileAttributeView(
Path path,
Class<V> type,
LinkOption... options)
```

```java
// Read file attributes
var path = Paths.get("/turtles/sea.txt");
BasicFileAttributeView view = Files.getFileAttributeView(path,
BasicFileAttributeView.class);
BasicFileAttributes attributes = view.readAttributes();
// Modify file last modified time
FileTime lastModifiedTime = FileTime.fromMillis(
attributes.lastModifiedTime().toMillis() + 10_000);
view.setTimes(lastModifiedTime, null, null);
```

After the updatable view is retrieved, we need to call ``readAttributes()`` on the view to obtain the file metadata. From there, we create a new ``FileTime`` value and set it using the ``setTimes()`` method:

```java
// BasicFileAttributeView instance method
public void setTimes(FileTime lastModifiedTime,FileTime lastAccessTime, FileTime createTime)
```

---

**Not all file attributes can be modified with a view. For example, you cannot set a property that changes a file into a directory. Likewise, you cannot change the size of the object without modifying its contents.**

---
### Traversing a Directory Tree

While the ``Files.list()`` method is useful, it traverses the contents of only a single directory. What if we want to visit all of the paths within a directory tree? Remember that a directory is organized in a hierarchical manner. For example, a directory can contain files and other directories, which can in turn contain other files and directories. Every record in a file system has exactly one parent, with the exception of the root directory, which sits atop everything.

A file system is commonly visualized as a tree with a single root node and many branches and leaves. In this model, a directory is a branch or internal node, and a file is a leaf node.

A common task in a file system is to iterate over the descendants of a path, either recording information about them or, more commonly, filtering them for a specific set of files. For example, you may want to search a folder and print a list of all of the .java files. Furthermore, file systems store file records in a hierarchical manner. Generally speaking, if you want to search for a file, you have to start with a parent directory, read its child elements, then read their children, and so on.

Traversing a directory, also referred to as walking a directory tree, is the process by which you start with a parent directory and iterate over all of its descendants until some condition is met or there are no more elements over which to iterate.

---

**Don’t Use ``DirectoryStream`` and ``FileVisitor``**

**While browsing the NIO.2 Javadocs, you may come across methods that use the ``DirectoryStream`` and ``FileVisitor`` classes to traverse a directory. These methods predate the existence of the ``Stream`` API and were even required knowledge for older Java certification exams.**

**The best advice we can give you is to not use them. The newer Stream API–based methods are superior and accomplish the same thing, often with much less code.**

---

#### Selecting a Search Strategy

Two common strategies are associated with walking a directory tree: a depth-first search and a breadth-first search. A depth-first search traverses the structure from the root to an arbitrary leaf and then navigates back up toward the root, traversing fully any paths it skipped along the way. The search depth is the distance from the root to current node. To prevent endless searching, Java includes a search depth that is used to limit how many levels (or hops) from the root the search is allowed to go.

Alternatively, a breadth-first search starts at the root and processes all elements of each particular depth before proceeding to the next depth level. The results are ordered by depth, with all nodes at depth 1 read before all nodes at depth 2, and so on. While a breadth-first search tends to be balanced and predictable, it also requires more memory since a list of visited nodes must be maintained.

**==the NIO.2 Stream API methods use depth-first searching with a depth limit, which can be optionally changed.==**

#### Walking a Directory

The ``Files`` class includes two methods for walking the directory tree using a depth-first search.

```java
public static Stream<Path> walk(Path start, FileVisitOption... options) throws IOException
public static Stream<Path> walk(Path start, int maxDepth, FileVisitOption... options) throws IOException
```

**==``walk()`` uses lazy evaluation and evaluates a ``Path`` only as it gets to it==**. This means that even if the directory tree includes hundreds or thousands of files, the memory required to process a directory tree is low

 The first ``walk()`` method relies on a default maximum depth of ``Integer.MAX_VALUE``, while the overloaded version allows the user to set a maximum depth. This is useful in cases where the file system might be large and we know the information we are looking for is near the root.

```java
private long getSize(Path p) {
	try {
		return Files.size(p);
	} catch (IOException e) {
		throw new UncheckedIOException(e);
	}
}
public long getPathSize(Path source) throws IOException {
	try (var s = Files.walk(source)) {
		return s.parallel()
		.filter(p -> !Files.isDirectory(p))
		.mapToLong(this::getSize)
		.sum();
	}
}
```

The ``getSize()`` helper method is needed because ``Files.size()`` declares ``IOException``, and we’d rather not put a try/catch block inside a lambda expression. Instead, we wrap it in the unchecked exception class ``UncheckedIOException``

```java
var size = getPathSize(Path.of("/fox/data"));
System.out.format("Total Size: %.2f megabytes", (size/1000000.0));
```

```text
Total Size: 15.30 megabytes
```
#### Applying a Depth Limit

```java
try (var s = Files.walk(source, 5)) { }
```

This new version checks for files only within 5 steps of the starting node. A depth value of 0 indicates the current path itself. Since the method calculates values only on files, you’d have to set a depth limit of at least 1 to get a nonzero result when this method is applied to a directory tree.
#### Avoiding Circular Paths

NIO.2 methods traverse symbolic links by default, with a ``NOFOLLOW_LINKS`` used to disable this behavior. The ``walk()`` method is different in that it does not follow symbolic links by default and requires the ``FOLLOW_LINKS`` option to be enabled

```java
try (var s = Files.walk(source, FileVisitOption.FOLLOW_LINKS)) { }
```

When traversing a directory tree, your program needs to be careful of symbolic links if enabled. 
Worse yet, a symbolic link could lead to a cycle in which a path is visited repeatedly. A cycle is an infinite circular dependency in which an entry in a directory tree points to one of its ancestor directories.

![[Pasted image 20240608185155.png]]

![[Pasted image 20240608185207.png]]
![[Pasted image 20240608185218.png]]

Be aware that when the ``FOLLOW_LINKS`` option is used, the ``walk()`` method will track all of the paths it has visited, throwing a ``FileSystemLoopException`` if a path is visited twice.

### Searching a Directory

```java
public static Stream<Path> find(Path start, int maxDepth, BiPredicate<Path, BasicFileAttributes> matcher, FileVisitOption... options) throws IOException
```

The ``find()`` method behaves in a similar manner as the ``walk()`` method, except that it takes a ``BiPredicate`` to filter the data. It also requires a depth limit to be set. Like ``walk()``, ``find()`` also supports the ``FOLLOW_LINK`` option. 

The two parameters of the ``BiPredicate`` are a ``Path`` object and a ``BasicFileAttributes`` object, which you saw earlier in the chapter. In this manner, Java automatically retrieves the basic file information for you, allowing you to write complex lambda expressions that have direct access to this object

```java
Path path = Paths.get("/bigcats");
long minSize = 1_000;
try (var s = Files.find(path, 10,
(p, a) -> a.isRegularFile() && p.toString().endsWith(".java") && a.size() > minSize)) {
s.forEach(System.out::println);
}
```

## Review of Key APIs

![[Pasted image 20240608185755.png]]

![[Pasted image 20240608185811.png]]

## Summary #OCP_Summary 

**==started by showing you how to create File from I/O and Path from NIO.2. We then covered the functionality that works with both I/O and NIO.2 before getting into NIO.2-specific APIs. You should be familiar with how to combine or resolve Path objects with other Path objects. Additionally, NIO.2 includes Stream API methods that can be used to process files and directories. We discussed methods for listing a directory, walking a directory tree, searching a directory tree, and reading the lines of a file.**==

==**We spent time reviewing various methods available in the ``Files`` helper class. As discussed, the name of the function often tells you exactly what it does. We explained that most of these methods are capable of throwing an ``IOException``, and many take optional varargs enum values.**==

==**We then introduced I/O streams and explained how they are used to read or write large quantities of data. While there are a lot of I/O streams, they differ on some key points:**==
-  ==**Byte vs. character streams**==
-  ==**Input vs. output streams**==
-  ==**Low-level vs. high-level streams**==

==**Often, the name of the I/O stream can tell you a lot about what it does. We visited many of the I/O stream classes that you will need to know for the exam in increasing order of complexity. A common practice is to start with a low-level resource or file stream and wrap it in a buffered I/O stream to improve performance. You can also apply a high-level stream to manipulate the data, such as an object or print stream. We described what it means to be serializable in Java, and we showed you how to use the object stream classes to persist objects directly to and from disk.**==

==**We explained how to read input data from the user using both the system stream objects and the Console class. The Console class has many useful features, such as built-in support for passwords and formatting.**==

==**We also discussed how NIO.2 provides methods for reading and writing file metadata. NIO.2 includes two methods for retrieving all of the file system attributes for a path in a single call without numerous round trips to the operating system. One method requires a read-only attribute type, while the second method requires an updatable view type. It also allows NIO.2 to support operating system–specific file attributes.==**

## Exam Essentials #Essential 

**Understand files and directories**. Files are records that store data within a persistent storage device, such as a hard disk drive, that is available after the application has finished executing. Files are organized within a file system in directories, which in turn may contain other directories. The root directory is the topmost directory in a file system.

**Be able to use File and Path**. An I/O File instance is created by calling the constructor. It contains a number of instance methods for creating and manipulating a file or directory. An NIO.2 Path instance is an immutable object that is commonly created from the factory method ``Paths.get()`` or ``Path.of()``. It can also be created from ``FileSystem``, ``java.net.URI``, or ``java.io.File`` instances. The Path interface includes many instance methods for reading and manipulating the abstract path value.

**Distinguish between types of I/O streams**. I/O streams are categorized by byte/character,
input/output, and low-level/ high-level. Byte streams operate on binary data and have names that end with Stream, **==while character streams operate on text data and have names that end in ``Reader`` or ``Writer``. The ``InputStream`` and ``Reader`` classes are the topmost abstract classes that receive data, while the ``OutputStream`` and Writer classes are the topmost abstract classes that send data==**. A low-level stream is one that operates directly on the underlying resource, such as a file or network connection. A high-level stream operates on a low-level or other high-level stream to filter data, convert data, or improve performance.

**Understand how to use Java serialization**. A class is considered serializable if it implements the ``java.io.Serializable`` interface and contains instance members that are either serializable or marked ``transient``. All Java primitives and the String class are serializable. The ``ObjectInputStream`` and ``ObjectOutputStream`` classes can be used to read and write a Serializable object from and to an I/O stream, respectively.

**Be able to interact with the user**. Be able to interact with the user using the system streams (``System.out``, ``System.err``, and ``System.in``) as well as the ``Console`` class. The ``Console`` class includes special methods for formatting data and retrieving complex input such as passwords.

**Manage file attributes**. The NIO.2 Files class includes many methods for reading single file attributes, such as its size or whether it is a directory, a symbolic link, hidden, etc. NIO.2 also supports reading all of the attributes in a single call. An attribute type is used to support operating system–specific views. Finally, NIO.2 supports updatable views for modifying selected attributes.

## Review Questions

1. Which class would be best to use to read a binary file into a Java object?

A. BufferedStream
B. FileReader
C. ObjectInputStream
D. ObjectReader
E. ObjectOutputStream
F. ObjectWriter
G. None of the above

**Since the question asks about putting data into a structured object, the best class would be one that deserializes the data. Therefore, ObjectInputStream is the best choice, which is option C. ObjectWriter, BufferedStream, and ObjectReader are not I/O stream classes. ObjectOutputStream is an I/O class but is used to serialize data, not deserialize it. FileReader can be used to read text file data and construct an object, but the question asks what would be the best class to use for binary data.**

---

2. Assuming that / is the root directory within the file system, which of the following are true statements? (Choose all that apply.)

A. /home/parrot is an absolute path.
B. /home/parrot is a directory.
C. /home/parrot is a relative path.
D. new File("/home") will throw an exception if /home does not exist.
E. new File("/home").delete() will throw an exception if /home does not exist.
F. A Reader offers character encoding, making it more useful when working with String data than an InputStream.
G. A Reader offers multithreading support, making it more useful than an InputStream.

**Paths that begin with the root directory are absolute paths, so option A is correct, and option C is incorrect. Option B is incorrect because the path could be a file or directory within the file system. There is no rule that files have to end with a file extension. Option D is incorrect, as it is possible to create a File reference to files and directories that do not exist. Option E is also incorrect. The delete() method returns false if the file or directory cannot be deleted. Character stream classes often include built-in convenience methods for working with String data, so option F is correct. There is no such optimization for multi-threading, making option G incorrect.**

---

3. What are possible results of executing the following code? (Choose all that apply.)

```java
public static void main(String[] args) throws IOException {
String line;
var c = System.console();
Writer w = c.writer();
try (w) {
if ((line = c.readLine("Enter your name: ")) != null)
w.append(line);
w.flush();
}
}
```

A. The code runs, but nothing is printed.
B. The code prints what was entered by the user.
C. The code behaves the same if throws IOException is removed.
D. A NullPointerException may be thrown.
E. A NullPointerException will always be thrown.
F. A NullPointerException will never be thrown.
G. The code does not compile

**If the console is unavailable, System.console() will return null, making option D correct and options E and F incorrect. The writer methods throw a checked IOException, making option C incorrect. The code works correctly, prompting for input and printing it. Therefore, option A is incorrect and option B is correct.**

---

4. For which values of path sent to this method would it be possible for the following code to output Success? (Choose all that apply.)

```java
public void removeBadFile(Path path) {
if(Files.isDirectory(path))
System.out.println(Files.deleteIfExists(path)
? "Success": "Try Again");
}
```

A. path refers to a regular file in the file system.
B. path refers to a symbolic link in the file system.
C. path refers to an empty directory in the file system.
D. path refers to a directory with content in the file system.
E. path does not refer to a record that exists within the file system.
F. The code does not compile.

**The code does not compile, as Files.deleteIfExists() declares the checked IOException that must be handled or declared. Remember, most Files methods declare IOException, especially the ones that modify a file or directory. For this reason, option F is correct. If the method were corrected to declare the appropriate exceptions, option C would be correct. Option B would also be correct if the method were provided a symbolic link that pointed to an empty directory. Options A and E would not print anything, as Files.isDirectory() returns false for both. Finally, option D would throw a DirectoryNotEmptyException at runtime.**

---

5. Assume that the directory /animals exists and is empty. What is the result of executing the following code?

```java
Path path = Path.of("/animals");
try (var z = Files.walk(path)) {
boolean b = z
.filter((p,a) ->
a.isDirectory() && !path.equals(p)) // x
.findFirst().isPresent(); // y
System.out.print(b ? "No Sub": "Has Sub");
}
```

A. It prints No Sub.
B. It prints Has Sub.
C. The code will not compile because of line x.
D. The code will not compile because of line y.
E. The output cannot be determined.
F. It produces an infinite loop at runtime.

**The filter() operation applied to a Stream< Path> takes only one parameter, not two, so the code does not compile, and option C is correct. If the code were rewritten to use the Files.find() method with the BiPredicate as input (along with a maxDepth value), the output would be option B, Has Sub, since the directory is given to be empty. For fun, we reversed the expected output of the ternary operation.**

---

6. What would be the value of name if the instance of Eagle created in the main() method were serialized and then deserialized?

```java
import java.io.Serializable;
class Bird {
protected transient String name;
public void setName(String name) { this.name = name; }
public String getName() { return name; }
public Bird() {
this.name = "Matt";
}
}
public class Eagle extends Bird implements Serializable {
{ this.name = "Olivia"; }
public Eagle() {
this.name = "Bridget";
}
public static void main(String[] args) {
var e = new Eagle();
e.name = "Adeline";
}
}
```

A. Adeline
B. Bridget
C. Matt
D. Olivia
E. null
F. The code does not compile.
G. The code compiles but throws an exception at runtime.

**The code compiles and runs without issue, so options F and G are incorrect. The key here is that while Eagle is serializable, its parent class, Bird, is not. Therefore, none of the members of Bird will be serialized. Even if you didn’t know that, you should know what happens on deserialization. During deserialization, Java calls the constructor of the first non-serializable parent. In this case, the Bird constructor is called, with name being set to Matt, making option C correct. Note that none of the constructors or instance initializers in Eagle are executed as part of deserialization.**

---

7. Assume that /kang exists as a symbolic link to the directory /mammal/kangaroo within the file system. Which of the following statements are correct about this code snippet? (Choose all that apply.)

```java
var path = Paths.get("/kang");
if(Files.isDirectory(path) && Files.isSymbolicLink(path))
Files.createDirectory(path.resolve("joey"));
```

A. A new directory will always be created.
B. A new directory may be created.
C. If the code creates a directory, it will be reachable at /kang/joey.
D. If the code creates a directory, it will be reachable at /mammal/joey.
E. The code does not compile.
F. The code will compile but will always throw an exception at runtime.

**The code snippet will attempt to create a directory if the target of the symbolic link exists and is a directory. If the directory already exists, though, it will throw an exception. For this reason, option A is incorrect, and option B is correct. It will be created in /mammal/kangaroo/joey and also reachable at /kang/joey because of the symbolic link, making option C correct.**

---

8. Assuming that the /fox/food-schedule. csv file exists with the specified contents, what is the expected output of calling printData() on it?

```text
/fox/food-schedule.
csv
6am,Breakfast
9am,SecondBreakfast
12pm,Lunch
6pm,Dinner
```
```java
void printData(Path path) throws IOException {
Files.readAllLines(path) // r1
.flatMap(p ->
Stream.of(p.split(","))) // r2
.map(q ->
q.toUpperCase()) // r3
.forEach(System.out::println);
}
```

A. The code will not compile because of line r1.
B. The code will not compile because of line r2.
C. The code will not compile because of line r3.
D. It throws an exception at runtime.
E. It does not print anything at runtime.
F. None of the above

**The readAllLines() method returns a List, not a Stream. Therefore, the call to flatMap() is invalid, and option B is correct. If the Files.lines() method were used instead, it would print the contents of the file one capitalized word at a time with the commas removed.**

---

9. Given the following method, which statements are correct? (Choose all that apply.)

```java
public void copyFile(File file1, File file2) throws Exception {
var reader = new InputStreamReader(new FileInputStream(file1));
try (var writer = new FileWriter(file2)) {
char[] buffer = new char[10];
while(reader.read(buffer) != -1)
{
writer.write(buffer);
// n1
}
}
}
```

A. The code does not compile because reader is not a buffered stream.
B. The code does not compile because writer is not a buffered stream.
C. The code compiles and correctly copies the data between some files.
D. The code compiles and correctly copies the data between all files.
E. If we check file2 on line n1 within the file system after five iterations of the while loop, it may be empty.
F. If we check file2 on line n1 within the file system after five iterations, it will contain exactly 50 characters.
G. This method contains a resource leak.
 
 **First, the method does compile, so options A and B are incorrect. Methods to read/write byte[] values exist in the abstract parent of all I/O stream classes. This implementation is not correct, though, as the return value of read(buffer) is not used properly. It will only correctly copy files whose character count is a multiple of 10, making option C correct and option D incorrect. Option E is also correct as the data may not have made it to disk yet. Option F would be correct if the flush() method were called after every write. Finally, option G is correct as the reader stream is never closed.**

---

10. Which of the following correctly create Path instances? (Choose all that apply.)

A. new Path("jaguar.txt")
B. FileSystems.getDefault().getPath("puma.txt")
C. Path.get("cats","lynx.txt")
D. new java.io.File("tiger.txt").toPath()
E. new FileSystem().getPath("lion")
F. Paths.getPath("ocelot.txt")
G. Path.of(Path.of(".").toUri())

**Options A and E are incorrect because Path and FileSystem, respectively, are abstract types that should be instantiated using a factory method. Option C is incorrect because the static method in the Path interface is of(), not get(). Option F is incorrect because the static method in the Paths class is get(), not getPath(). Options B and D are correct ways to obtain a Path instance. Option G is also correct, as there is an overloaded static method in Path that takes a URI instead of a String.**

---

11. Which classes will allow the following to compile? (Choose all that apply.)

```java
var is = new BufferedInputStream(new FileInputStream("z.txt"));
InputStream wrapper = new ?? (is);
try (wrapper) {}
```

A. BufferedInputStream
B. BufferedReader
C. BufferedWriter
D. FileInputStream
E. ObjectInputStream
F. ObjectOutputStream
G. None of the above, as the first line does not compile

**The code will compile if the correct classes are used, so option G is incorrect. Remember, a try-with- resources statement can use resources declared before the start of the statement. The reference type of wrapper is InputStream, so we need a class that inherits InputStream. We can eliminate BufferedWriter, ObjectOutputStream, and BufferedReader since their names do not end in InputStream. Next, we see the class must take another stream as input, so we need to choose the remaining streams that are high-level streams. BufferedInputStream is a high-level stream, so option A is correct. Even though the instance is already a BufferedInputStream, there’s no rule that it can’t be wrapped multiple times by a high-level stream. Option D is incorrect, as FileInputStream operates on a file, not another stream. Finally, option E is correct—an ObjectInputStream is a high-level stream that operates on other streams.**

---

12.  What is the result of executing the following code? (Choose all that apply.)

```java
4: var p = Paths.get("sloth.schedule");
5: var a = Files.readAttributes(p, BasicFileAttributes.class);
6: Files.mkdir(p.resolve(".backup"));
7: if(a.size()>0 && a.isDirectory()) {
8: a.setTimes(null,null,null);
9: }
```

A. It compiles and runs without issue.
B. The code will not compile because of line 5.
C. The code will not compile because of line 6.
D. The code will not compile because of line 7.
E. The code will not compile because of line 8.
F. None of the above

**The method to create a directory in the Files class is createDirectory(), not mkdir(). For this reason, line 6 does not compile, and option C is correct. In addition, the setTimes() method is available only on BasicFileAttributeView, not the read-only BasicFileAttributes, so line 8 will also not compile, making option E correct.**

---

13. Which of the following are true statements about serialization in Java? (Choose all that apply.)

A. All non-null instance members of the class must be serializable or marked transient.
B. Records are automatically serializable.
C. Serialization involves converting data into Java objects.
D. Serializable is a functional interface.
E. The class must declare a static serialVersionUID variable.
F. The class must extend the Serializable class.
G. The class must implement the Serializable interface.

**For a class to be serialized, it must implement the Serializable interface and contain instance members that are serializable or marked transient. For these reasons, options A and G are correct and option F is incorrect. Option B is incorrect because even records are required to implement Serializable to be serialized. Option C is incorrect because it describes deserialization. The Serializable interface is a marker interface that does not contain any abstract methods, making option D incorrect. While it is a good practice for a serializable class to include a static serialVersionUID variable, it is not required. Therefore, option E is incorrect as well.**

---

14. What is the output of the following code? (Choose three.)

```java
22: var p1 = Path.of("/zoo/./bear","../food.txt");
23: p1.normalize().relativize(Path.of("/lion"));
24: System.out.println(p1);
25:
26: var p2 = Paths.get("/zoo/animals/bear/koala/food.txt");
27: System.out.println(p2.subpath(1,3).getName(1));
28:
29: var p3 = Path.of("/pets/../cat.txt");
30: var p4 = Paths.get("./dog.txt");
31: System.out.println(p4.resolve(p3));
```

A. ../../lion
B. /zoo/./bear/../food.txt
C. animal
D. bear
E. /pets/../cat.txt
F. /pets/../cat.txt/./dog.txt

**Path is immutable, so line 23 is ignored. If it were assigned to p1, option A would be correct. Since it is not assigned, the original value is still present, which is option B. Moving on to the second section, the subpath() method on line 27 is applied to the absolute path, which returns the relative path animals/bear. Next, the getName() method is applied to the relative path, and since this is indexed from 0, it returns the relative path bear. Therefore, option D is correct. Finally, remember calling resolve() with an absolute path as a parameter returns the absolute path, so option E is correct.**

---

15. Suppose that the working directory is /weather and the absolute path /weather/winter/snow.dat represents a file that exists within the file system. Which of the following lines of code create an object that represents the file? (Choose all that apply.)

A. new File("/weather", "winter", "snow.dat")
B. new File("/weather/winter/snow.dat")
C. new File("/weather/winter", new File("snow.dat"))
D. new File("weather", "/winter/snow.dat")
E. new File(new File("/weather/winter"), "snow.dat")
F. Path.of("/weather/winer/snow.dat").toFile();
G. None of the above

**Option A does not compile, as there is no File constructor that takes three parameters. Option B is correct and is the proper way to create a File instance with a single String parameter. Option C is incorrect, as there is no constructor that takes a String followed by a File. There is a constructor that takes a File followed by a String, making option E correct. Option D is incorrect because the first parameter is missing a slash (/) to indicate it is an absolute path. Since it’s a relative path, it is correct only when the user’s current directory is the root directory. Finally, option F is correct as it creates a File from a Path.**

---

16. Assuming zoo-data. txt exists and is not empty, what statements about the following method are correct? (Choose all that apply.)

```java
private void echo() throws IOException {
var o = new FileWriter("new-zoo.
txt");
try (var f = new FileReader("zoo-data.
txt");
var b = new BufferedReader(f); o) {
o.write(b.readLine());
}
o.write("");
}
```

A. When run, the method creates a new file with one line of text in it.
B. When run, the method creates a new file with two lines of text in it.
C. When run, the method creates a new file with the same number of lines as the original file.
D. The method compiles but will produce an exception at runtime.
E. The method does not compile.
F. The method uses byte stream classes.

**The method compiles, so option E is incorrect. The method creates a new-zoo. txt file and copies the first line from zoo-data. txt into it, making option A correct. The try-with- resources statement closes all of the declared resources, including the FileWriter o. For this reason, the Writer is closed when the last o.write() is called, resulting in an IOException at runtime and making option D correct. Option F is incorrect because this implementation uses the character stream classes, which inherit from Reader or Writer.**

---

17. Which are true statements? (Choose all that apply.)

A. NIO.2 includes a method to delete an entire directory tree.
B. NIO.2 includes a method to traverse a directory tree.
C. NIO.2 includes methods that are aware of symbolic links.
D. Files.readAttributes() cannot access file-system dependent attributes.
E. Files.readAttributes() is often more performant since it reads multiple attributes
rather than accessing individual attributes.
F. Files.readAttributes() works with the File object.

**Options B and C are properties of NIO.2 and are good reasons to use it over the java.io.File class. Option A is incorrect as both APIs can delete only empty directories, not a directory tree. Using a view to read multiple attributes leads to fewer round trips between the process and the file system and better performance, making option E correct. Views can be used to access file system–specific attributes that are not available in Files methods; therefore, option D is correct. Files is part of NIO.2, whereas File is part of java.io, which means option F is incorrect.**

---

18. Assume that reader is a valid stream whose next characters are PEACOCKS. What is true about the output of the following code snippet? (Choose all that apply.)

```java
var sb = new StringBuilder();
sb.append((char)reader.read());
reader.mark(10);
for(int i=0; i<2; i++) {
sb.append((char)reader.read());
reader.skip(2);
}
reader.reset();
reader.skip(0);
sb.append((char)reader.read());
System.out.println(sb.toString());
```

A. The code may print PEAE.
B. The code may print PEOA.
C. The code may print PEOE.
D. The code may print PEOS.
E. The code will always print PEAE.
F. The code will always print PEOA.
G. The code will always print PEOE.
H. The code will always print PEOS.

**Since a Reader may or may not support mark(), we can rule out options E, F, G, and H. Assuming mark() is supported, P is added to the StringBuilder first. Next, the position in the stream is marked before E. The E is added to the StringBuilder, with AC being skipped, and then the O is added to the StringBuilder, with CK being skipped. The stream is then reset() to the position before the E. The call to skip(0) doesn’t do anything since there are no characters to skip, so E is added onto the StringBuilder in the next read() call. The value PEOE is printed, and option C is correct.**

---

19. Assuming that the directories and files referenced exist and are not symbolic links, what is the result of executing the following code?

```java
var p1 = Path.of("/lizard",".").resolve(Path.of("walking.txt"));
var p2 = new File("/lizard/././actions/../walking.txt").toPath();
System.out.print(Files.isSameFile(p1,p2));
System.out.print(" ");
System.out.print(p1.equals(p2));
System.out.print(" ");
System.out.print(Files.mismatch(p1,p2));
```

A. true true -1
B. true true 0
C. true false -1
D. true false 0
E. false true -1
F. false true 0
G. The code does not compile.
H. The result cannot be determined.

**The code compiles and runs without issue, so option G is incorrect. If you simplify the redundant path symbols, p1 and p2 represent the same path, /lizard/walking.txt. Therefore, isSameFile() returns true. The second output is false, because equals() checks only if the path values are the same, without reducing the path symbols. Finally, mismatch() sees that the contents are the same and returns -1. For these reasons, option C is correct.**

---

20. Assume that monkey.txt is a file that exists in the current working directory. Which statements about the following code snippet are correct? (Choose all that apply.)

```java
Files.move(Path.of("monkey.txt"), Paths.get("/animals"), StandardCopyOption.ATOMIC_MOVE, LinkOption.NOFOLLOW_LINKS);
```

A. If /animals/monkey.txt exists, it will be overwritten at runtime.
B. If /animals exists as an empty directory, /animals/monkey.txt will be the new location of the file.
C. If monkey.txt is a symbolic link, the file it points to will be moved at runtime.
D. If the move is successful and another process is monitoring the file system, it will not see an incomplete file at runtime.
E. None of the above

**The target path of the file after the move() operation is /animals, not /animals/monkey.txt, so options A and B are both incorrect. Both will throw an exception at runtime since /animals already exists and is a directory. Next, the NOFOLLOW_LINKS option means that if the source is a symbolic link, the link itself and not the target will be copied at runtime, so option C is also incorrect. The option ATOMIC_MOVE means that any process monitoring the file system will not see an incomplete file during the move, so option D is correct.**

---

21. Assume that /monkeys exists as a directory containing multiple files, symbolic links, and subdirectories. Which statement about the following code is correct?

```java
var f = Path.of("/monkeys");
try (var m =
Files.find(f, 0, (p,a) ->
a.isSymbolicLink())) { // y1
m.map(s ->
s.toString())
.collect(Collectors.toList())
.stream() 
.filter(s -> s.toString().endsWith(".txt")) // y2 .forEach(System.out::println);
}
```

A. It will print all symbolic links in the directory tree ending in .txt.
B. It will print the target of all symbolic links in the directory ending in .txt.
C. It will print nothing.
D. It does not compile because of line y1.
E. It does not compile because of line y2.
F. It compiles but throws an exception at runtime.

**The code compiles and runs without issue, so options D, E, and F are incorrect. The most important thing to notice is that the depth parameter specified as the second argument to find() is 0, meaning the only record that will be searched is the top-level directory. Since we know that the top directory is a directory and not a symbolic link, no other paths will be visited, and nothing will be printed. For these reasons, option C is the correct answer.**

---

22. Which of the following fields will be null after an instance of the class created on line 17 is serialized and then deserialized using ObjectOutputStream and ObjectInputStream? (Choose all that apply.)

```java
1: import java.io.Serializable;
2: import java.util.List;
3: public class Zebra implements Serializable {
4: private transient String name = "George";
5: private static String birthPlace = "Africa";
6: private transient Integer age;
7: List<Zebra> friends = new java.util.ArrayList<>();
8: private Object stripes = new Object();
9: { age = 10;}
10: public Zebra() {
11: this.name = "Sophia";
12: }
13: static Zebra writeAndRead(Zebra z) {
14: // Implementation omitted
15: }
16: public static void main(String[] args) {
17: var zebra = new Zebra();
18: zebra = writeAndRead(zebra);
19: }
```

A. age
B. birthplace
C. friends
D. name
E. stripes
F. The code does not compile.
G. The code compiles but throws an exception at runtime

**The code compiles, so option F is incorrect. To be serializable, a class must implement the Serializable interface, which Zebra does. It must also contain instance members that either are marked transient or are serializable. The instance member stripes is of type Object, which is not serializable. If Object implemented Serializable, all objects would be serializable by default, defeating the purpose of having the Serializable interface. Therefore, the Zebra class is not serializable, with the program throwing an exception at runtime if serialized and making option G correct. If stripes were removed from the class, options A and D would be the correct answers, as name and age are both marked transient.**

---

23. What are some possible results of executing the following code? (Choose all that apply.)

```java
var x = Path.of("/animals/fluffy/..");
Files.walk(x.toRealPath().getParent()) // u1
.map(p ->
p.toAbsolutePath().toString()) // u2
.filter(s ->
s.endsWith(".java"))
.forEach(System.out::println);
```

A. It prints some files in the root directory.
B. It prints all files in the root directory.
C. FileSystemLoopException is thrown at runtime.
D. Another exception is thrown at runtime.
E. The code will not compile because of line u1.
F. The code will not compile because of line u2.

**The code compiles without issue, so options E and F are incorrect. The toRealPath() method will simplify the path to /animals and throw an exception if it does not exist, making option D correct. If the path does exist, calling getParent() on it returns the root directory. Walking the root directory with the filter expression will print all .java files in the root directory (along with all .java files in the directory tree), making option A correct. Option B is incorrect because it will skip files and directories that do not end in the .java extension. Option C is also incorrect as Files.walk() does not follow symbolic links by default. Only if the FOLLOW_LINKS option is provided and a cycle is encountered will the exception be thrown.**

---

24. Assume that the source instance passed to the following method represents a file that exists. Also assume that /flip/sounds.txt exists as a file prior to executing this method. When  this method is executed, which statement correctly copies the file to the path specified by /flip/sounds.txt?

```java
void copyIntoFlipDirectory(Path source) throws IOException {
var dolphinDir = Path.of("/flip");
dolphinDir = Files.createDirectories(dolphinDir);
var n = Paths.get("sounds.txt");
???;
}
```

A. Files.copy(source, dolphinDir)
B. Files.copy(source, dolphinDir.resolve(n),
StandardCopyOption.REPLACE_EXISTING)
C. Files.copy(source, dolphinDir,
StandardCopyOption.REPLACE_EXISTING )
D. Files.copy(source, dolphinDir.resolve(n))
E. The method does not compile, regardless of what is placed in the blank.
F. The method compiles but throws an exception at runtime, regardless of what is placed in the blank.


**The method compiles without issue, so option E is incorrect. Option F is also incorrect. Even though /flip exists, createDirectories() does not throw an exception if the path already exists. If createDirectory() were used instead, option F would be correct. Next, the copy() command takes a target that is the path to the new file location, not the directory to be copied into. Therefore, the target path should be /flip/sounds.txt, not /flip. For this reason, options A and C are incorrect. Since the question says the file already exists, the REPLACE_EXISTING option must be specified or an exception will be thrown at runtime, making option B the correct answer.**


---

25. Suppose that you need to read text data from a file and want the data to be performant on large files. Which two java.io stream classes can be chained together to best achieve this result? (Choose two.)

A. BufferedInputStream
B. BufferedReader
C. FileInputStream
D. FileReader
E. PrintInputStream
F. ObjectInputStream
G. PrintReader

**Since you need to read characters, the Reader classes are appropriate. Therefore, you can eliminate options A, C, and F. Additionally, options E and G are incorrect, as they reference classes that do not exist. Options B and D are correct since they read from a file and buffer for performance.**

---

# Chapter - 15  JDBC #Chapter 

## Introducing Relational Databases and SQL

Data is information. A database is an organized collection of data. A relational database is a database that is organized into tables, which consist of rows and columns.
There are two main ways to access a relational database from Java:

-  ==**Java Database Connectivity (JDBC): Accesses data as rows and columns.**== 
-  ==**Java Persistence API (JPA): Accesses data through Java objects using a concept called object-relational mapping (ORM). The idea is that you don’t have to write as much code, and you get your data in Java objects.==**

A relational database is accessed through Structured Query Language (SQL). SQL is a programming language used to interact with database records. JDBC works by sending a SQL command to the database and then processing the response.

In addition to relational databases, there is another type of database called a NoSQL database. These databases store their data in a format other than tables, such as key/value, document stores, and graph-based databases.

### Identifying the Structure of a Relational Database

![[Pasted image 20240616114636.png]]

### Writing Basic SQL Statements

The most important thing that you need to know about SQL for the exam is that there are four types of statements for working with the data in tables. They are referred to as CRUD (Create, Read, Update, Delete). The SQL keywords don’t match the acronym, so pay attention to the SQL keyword

![[Pasted image 20240616114719.png]]

Unlike Java, SQL keywords are case insensitive. Like Java primitive types, SQL has a number of data types.
Most are self-explanatory, like INTEGER. There’s also DECIMAL, which functions a lot like a double in Java. The strangest one is VARCHAR, standing for “variable character,” which is like a String in Java. The variable part means that the database should use only as much space as it needs to store the value.

## Introducing the Interfaces of JDBC

For the exam, you need to know five key interfaces of JDBC. The interfaces are declared in the JDK.

With JDBC, the concrete classes come from the JDBC driver. Each database has a different JAR file with these classes. For example, PostgreSQL’s JAR is called something like ``postgresql-9.4– 1201.jdbc4.jar``. MySQL’s JAR is called something like ``mysql-connector- java- 5.1.36. jar``. The exact name depends on the vendor and version of the driver JAR.

With JDBC, you use only the interfaces in your code and never the implementation classes directly. In fact, they might not even be ``public`` classes.

-  ==**``Driver``: Establishes a connection to the database**==
-  ==**``Connection``: Sends commands to a database**==
-  ==**``PreparedStatement``: Executes a SQL query**==
-  ==**``CallableStatement``: Executes commands stored in the database**==
-  ==**``ResultSet``: Reads the results of a query==**

![[Pasted image 20240616115045.png]]

```java
public class MyFirstDatabaseConnection {
	public static void main(String[] args) throws SQLException {
	String url = "jdbc:hsqldb:file:zoo";
		try (Connection conn = DriverManager.getConnection(url);
			PreparedStatement ps = conn.prepareStatement(
			"SELECT name FROM exhibits");
			ResultSet rs = ps.executeQuery()) {
			while (rs.next())
				System.out.println(rs.getString(1));
		} 
	} 
}
```

## Connecting to a Database

The first step in doing anything with a database is connecting to it.
### Building a JDBC URL

To access a database, you need to know this information about it. Unlike web URLs, JDBC URLs have a variety of formats. They have three parts in common,

- ==**The first piece is always the same. It is the protocol jdbc.**==
- ==**The second part is the *subprotocol*, which is the name of the database, such as ``hsqldb``, ``mysql``, or ``postgres``.**==
- ==**The third part is the subname, which is a database-specific format. Colons ``(:)`` separate the three parts.==**

![[Pasted image 20240616120402.png]]

```java
jdbc:postgresql://localhost/zoo
jdbc:oracle:thin:@123.123.123.123:1521:zoo
jdbc:mysql://localhost:3306
jdbc:mysql://localhost:3306/zoo?profileSQL=true
```

### Getting a Database Connection

There are two main ways to get a ``Connection``: ``DriverManager`` and ``DataSource``. ``DriverManager`` is the one covered on the exam. A ``DataSource`` has more features than ``DriverManager``.

The ``DriverManager`` class is in the JDK, as it is an API that comes with Java. It uses the factory pattern, which means that you call a static method to get a ``Connection`` rather than calling a constructor.

```java
import java.sql.*;
public class TestConnect {
	public static void main(String[] args) throws SQLException {
		try (Connection conn = DriverManager.getConnection("jdbc:hsqldb:file:zoo")) {
			System.out.println(conn);
		} 
	}
}
```

e use a try-with- resources statement to ensure that database resources are closed. Assuming the program runs successfully, it prints something like this:

```text
org.hsqldb.jdbc.JDBCConnection@3dfc5fb8
```

Just notice that the class is not ``Connection``. It is a vendor implementation of ``Connection``.
There is also a signature that takes a username and password.

```java
import java.sql.*;
public class TestExternal {
	public static void main(String[] args) throws SQLException {
		try (Connection conn = DriverManager.getConnection(
		"jdbc:postgresql://localhost:5432/ocp-book", "username","Password20182")) {
			System.out.println(conn);
		} 
	} 
}
```

to run this with the Postgres driver JAR, it would print something like this:

```text
org.postgresql.jdbc4.Jdbc4Connection@eed1f14
```

Again, notice that it is a driver-specific implementation class. 

Unless the exam specifies a command line, you can assume that the correct JDBC driver JAR is in the classpath. The exam creators explicitly ask about the driver JAR if they want you to think about it. 

The nice thing about the factory pattern is that it takes care of the logic of creating a class for you. You don’t need to know the name of the class that implements ``Connection``, and you don’t need to know how it is created. You are probably a bit curious, though. 

``DriverManager`` looks through any drivers it can find to see whether they can handle the JDBC URL. If so, it creates a ``Connection`` using that ``Driver``. If not, it gives up and throws a ``SQLException``.

## Working with a ``PreparedStatement``

In Java, you have a choice of working with a ``Statement``, ``PreparedStatement``, or ``CallableStatement``.

![[Pasted image 20240616121106.png]]

What about Statement, you ask? It is an interface that both ``PreparedStatement`` and ``CallableStatement`` extend. A ``Statement`` and **==a ``PreparedStatement`` are similar to each other, except that a ``PreparedStatement`` takes parameters, while a ``Statement`` does not. A ``Statement`` just executes whatever SQL query you give it.==**

``PreparedStatement`` is far superior for the following reasons:

-  **Performance**: In most programs, you run similar queries multiple times. When you use ``PreparedStatement``, the database software often devises a plan to run the query well and remembers it.
-  **Security**: You are protected against an attack called SQL injection when using a ``PreparedStatement`` correctly.
- **Readability**: It’s nice not to have to deal with string concatenation in building a query string with lots of parameters.
-  **Future use**: Even if your query is being run only once or doesn’t have any parameters, you should still use a ``PreparedStatement``. That way, future editors of the code won’t add a variable and have to remember to change to ``PreparedStatement`` then.

### Obtaining a ``PreparedStatement``

To run SQL, you need to tell a ``PreparedStatement`` about it. Getting a ``PreparedStatement`` from a ``Connection`` is easy

```java
try (PreparedStatement ps = conn.prepareStatement( "SELECT * FROM exhibits")) {
	// work with ps
}
```

An instance of a ``PreparedStatement`` represents a SQL statement that you want to run using the ``Connection``. **==It does not execute the query yet!==** Passing a SQL statement when creating the object is mandatory.

```java
try (var ps = conn.prepareStatement()) {} // DOES NOT COMPILE
```

The previous example does not compile, because SQL is not supplied at the time a ``PreparedStatement`` is requested.

There are overloaded signatures that allow you to specify a ``ResultSet`` type and concurrency mode. On the exam, you only need to know how to use the default options, which process the results in order.
### Executing a ``PreparedStatement``
 
 The method for running SQL varies depending on what kind of SQL statement it is.

#### Modifying Data with ``executeUpdate()``

**==Those are SQL statements that begin with ``DELETE``, ``INSERT``, or ``UPDATE``. They typically use a method called ``executeUpdate()``==**. The name is a little tricky because the SQL UPDATE statement is not the only statement that uses this method.

The method takes the SQL statement to run as a parameter. It returns the number of rows that were inserted, deleted, or changed.

```java
10: var insertSql = "INSERT INTO exhibits VALUES(10, 'Deer', 3)";
11: var updateSql = "UPDATE exhibits SET name = '' " +
12: "WHERE name = 'None'";
13: var deleteSql = "DELETE FROM exhibits WHERE id = 10";
14:
15: try (var ps = conn.prepareStatement(insertSql)) {
	16: int result = ps.executeUpdate();
	17: System.out.println(result); // 1
18: }
19:
20: try (var ps = conn.prepareStatement(updateSql)) {
	21: int result = ps.executeUpdate();
	22: System.out.println(result); // 0
23: }
24:
25: try (var ps = conn.prepareStatement(deleteSql)) {
	26: int result = ps.executeUpdate();
	27: System.out.println(result); // 1
28: }
```

#### Reading Data with ``executeQuery()``

**==SQL statement that begins with ``SELECT``. This time, we use the ``executeQuery()`` method.==**

```java
30: var sql = "SELECT * FROM exhibits";
31: try (var ps = conn.prepareStatement(sql);
32: ResultSet rs = ps.executeQuery() ) {
33:
34: // work with rs
35: }
```

#### Processing Data with ``execute()``

There’s a third method called ``execute()`` that can run either a query or an update. It returns a ``boolean`` so that we know whether there is a ``ResultSet``. That way, we can call the proper method to get more detail.

```java
boolean isResultSet = ps.execute();
if (isResultSet) {
	try (ResultSet rs = ps.getResultSet()) {
		System.out.println("ran a query");
	}
} else {
	int result = ps.getUpdateCount();
	System.out.println("ran an update");
}
```

If the ``PreparedStatement`` refers to sql that is a ``SELECT``, the ``boolean`` is true, and we can get the ``ResultSet``. If it is not a ``SELECT``, we can get the number of rows updated.

#### Using the Correct Method

What do you think happens if we use the wrong method for a SQL statement?

```java
var sql = "SELECT * FROM names";
try (var ps = conn.prepareStatement(sql)) {
	var result = ps.executeUpdate();
}
```
```text
Exception in thread "main" java.sql.SQLException:
statement does not generate a row count
```

We also get a ``SQLException`` when using ``executeQuery()`` with SQL that changes the database.

```text
Exception in thread "main" java.sql.SQLException:
statement does not generate a result set
```

#### Reviewing ``PreparedStatement`` Methods

![[Pasted image 20240616122543.png]]

![[Pasted image 20240616122556.png]]

### Working with Parameters

```java
public static void register(Connection conn) throws SQLException {
	var sql = "INSERT INTO names VALUES(6, 1, 'Edith')";
	try (var ps = conn.prepareStatement(sql)) {
		ps.executeUpdate();
	}
}
```

Luckily, a ``PreparedStatement`` allows us to set parameters. Instead of specifying the three values in the SQL, we can use a question mark ``(?)``. A bind variable is a placeholder that lets you specify the actual values at runtime. A bind variable is like a parameter, and you will see bind variables referenced as both variables and parameters

```java
String sql = "INSERT INTO names VALUES(?, ?, ?)";
```

Bind variables make the SQL easier to read since you no longer need to use quotes around ``String`` values in the SQL

```java
4: public static void register(Connection conn, int key,
	15: int type, String name) throws SQLException {
	16:
	17: String sql = "INSERT INTO names VALUES(?, ?, ?)";
	18:
	19: try (PreparedStatement ps = conn.prepareStatement(sql)) {
		20: ps.setInt(1, key);
		21: ps.setString(3, name);
		22: ps.setInt(2, type);
		23: ps.executeUpdate();
	24: }
25: }
```

**==Notice how the bind variables are counted starting with 1 rather than 0. This is really important,==**
**==The rule is only that they are each set before the query is executed==**

```java
var sql = "INSERT INTO names VALUES(?, ?, ?)";
try (var ps = conn.prepareStatement(sql)) {
	ps.setInt(1, key);
	ps.setInt(2, type);
	// missing the set for parameter number 3
	ps.executeUpdate();
}
```

The code compiles, and you get a ``SQLException``

```text
Exception in thread "main" java.sql.SQLException: Parameter not set
```

What about if you try to set more values than you have as bind variables?

```java
var sql = "INSERT INTO names VALUES(?, ?)";
try (var ps = conn.prepareStatement(sql)) {
	ps.setInt(1, key);
	ps.setInt(2, type);
	ps.setString(3, name);
	ps.executeUpdate();
}
```

```text
Exception in thread "main" java.sql.SQLException:
row column count mismatch in statement [INSERT INTO names VALUES(?, ?)]
```

![[Pasted image 20240616124253.png]]

The ``setNull()`` method takes an int parameter representing the column type in the database.
Notice that the ``setObject()`` method works with any Java type. If you pass a primitive, it will be autoboxed into a wrapper type.

```java
String sql = "INSERT INTO names VALUES(?, ?, ?)";
try (PreparedStatement ps = conn.prepareStatement(sql)) {
	ps.setObject(1, key);
	ps.setObject(2, type);
	ps.setObject(3, name);
	ps.executeUpdate();
}
```

Java will handle the type conversion for you. It is still better to call the more specific setter methods since that will give you a compile-time error if you pass the wrong type instead of a runtime error.
### Updating Multiple Records

```java
var sql = "INSERT INTO names VALUES(?, ?, ?)";
try (var ps = conn.prepareStatement(sql)) {
	ps.setInt(1, 20);
	ps.setInt(2, 1);
	ps.setString(3, "Ester");
	ps.executeUpdate();
	
	ps.setInt(1, 21);
	ps.setString(3, "Elias");
	ps.executeUpdate();
}
```

Note that we set all three parameters when adding Ester but only two for Elias. **==The ``PreparedStatement`` is smart enough to remember the parameters that were already set and retain them. You only have to set the ones that are different.==**

## Getting Data from a ``ResultSet``

### Reading a ``ResultSet``

When working with a ``ResultSet``, most of the time, you will write a loop to look at each row.

```java
20: String sql = "SELECT id, name FROM exhibits";
21: var idToNameMap = new HashMap<Integer, String>();
22:
23: try (var ps = conn.prepareStatement(sql);
	24: ResultSet rs = ps.executeQuery()) {
25:
26: while (rs.next()) {
	27: int id = rs.getInt("id");
	28: String name = rs.getString("name");
	29: idToNameMap.put(id, name);
30: }
	31: System.out.println(idToNameMap);
32: }
```

Each time through the loop represents one row in the ``ResultSet``. A ``ResultSet`` has a cursor, which points to the current location in the data.

![[Pasted image 20240616130126.png]]

the “best way” to get data was with column names. There is another way to access the columns. You can use an index, counting from 1 instead of a column name.

```java
27: int id = rs.getInt(1);
28: String name = rs.getString(2);
```

Notice how the columns are counted starting with 1 rather than 0. Just like with a ``PreparedStatement``, JDBC starts counting at 1 in a ``ResultSet``.

Sometimes you want to get only one row from the table. **==When you want only one row, you use an ``if`` statement rather than a ``while`` loop.==**

```java
var sql = "SELECT count(*) FROM exhibits";
try (var ps = conn.prepareStatement(sql);
	var rs = ps.executeQuery()) {
	if (rs.next()) {
		int count = rs.getInt(1);
		System.out.println(count);
	}
}
```

It is important to check that ``rs.next()`` returns true before trying to call a getter on the ``ResultSet``. If a query didn’t return any rows, it would throw a ``SQLException``, so the if statement checks that it is safe to call. Alternatively, you can use the column name.

```java
var count = rs.getInt("count");
```

```java
var sql = "SELECT count(*) AS count FROM exhibits";
try (var ps = conn.prepareStatement(sql);
	var rs = ps.executeQuery()) {
	if (rs.next()) {
		var count = rs.getInt("total");
		System.out.println(count);
	}
}
```

```text
Exception in thread "main" java.sql.SQLException: Column not found: total
```

Attempting to access a column name or index that does not exist throws a ``SQLException``, as does getting data from a ``ResultSet`` when it isn’t pointing at a valid row. You need to be able to recognize such code.

```java
var sql = "SELECT * FROM exhibits where name='Not in table'";
try (var ps = conn.prepareStatement(sql);
var rs = ps.executeQuery()) {
	rs.next();
	rs.getInt(1); // SQLException
}
```

Calling ``rs.next()`` works. It returns false. However, calling a getter afterward throws a ``SQLException`` because the result set cursor does not point to a valid position. If a match were returned, this code would have worked.

```java
var sql = "SELECT count(*) FROM exhibits";
try (var ps = conn.prepareStatement(sql);
var rs = ps.executeQuery()) {
	rs.getInt(1); // SQLException
}
```

Not calling ``rs.next()`` at all is a problem. The result set cursor is still pointing to a location before the first row, so the getter has nothing to point to.

To sum up this section, it is important to remember the following:
-  ==**Always use an if statement or while loop when calling ``rs.next()``.**==
-  ==**Column indexes begin with 1.==**

### Getting Data for a Column

![[Pasted image 20240616131133.png]]

The exam will not try to trick you by using a get method name that doesn’t exist for JDBC

The ``getObject()`` method can return any type. For a primitive, it uses the wrapper class.

```java
16: var sql = "SELECT id, name FROM exhibits";
17: try (var ps = conn.prepareStatement(sql);
18: var rs = ps.executeQuery()) {
19:
20: while (rs.next()) {
	21: Object idField = rs.getObject("id");
	22: Object nameField = rs.getObject("name");
	23: if (idField instanceof Integer id)
		24: System.out.println(id);
	25: if (nameField instanceof String name)
		26: System.out.println(name);
	27: }
28: }
```

### Using Bind Variables

We’ve been creating the ``PreparedStatement`` and ``ResultSet`` in the same try-with-resources statement. This doesn’t work if you have bind variables because they need to be set in between. Luckily, we can nest try-with- resources to handle this.

```java
30: var sql = "SELECT id FROM exhibits WHERE name = ?";
31:
32: try (var ps = conn.prepareStatement(sql)) {
33: ps.setString(1, "Zebra");
34:
35: try (var rs = ps.executeQuery()) {
		36: while (rs.next()) {
			37: int id = rs.getInt("id");
			38: System.out.println(id);
		39: }
	40: }
41: }
```

## Calling a ``CallableStatement``

In some situations, it is useful to store SQL queries in the database instead of packaging them with the Java code. This is particularly useful when there are many complex queries. A stored procedure is code that is compiled in advance and stored in the database. Stored procedures are commonly written in a database-specific variant of SQL, which varies among database software providers.

Using a stored procedure reduces network round trips. It also allows database experts to own that part of the code. However, stored procedures are database-specific and introduce complexity into maintaining your application.

![[Pasted image 20240616170003.png]]

### Calling a Procedure without Parameters

``read_e_names()`` stored procedure doesn’t take any parameters. It does return a ``ResultSet``

```java
12: String sql = "{call read_e_names()}";
13: try (CallableStatement cs = conn.prepareCall(sql);
	14: ResultSet rs = cs.executeQuery()) {
	15:
	16: while (rs.next()) {
		17: System.out.println(rs.getString(3));
	18: }
19: }
```

**==A stored procedure is called by putting the word ``call`` and the procedure name in braces ``({})``.==**
**==Here, we use the ``prepareCall()`` method instead.==**

### Passing an ``IN`` Parameter

A stored procedure that always returns the same thing is only somewhat useful. The
``read_names_by_letter()`` stored procedure takes a parameter for the prefix or first letter of the stored procedure. An ``IN`` parameter is used for input.

```java
25: var sql = "{call read_names_by_letter(?)}";
	26: try (var cs = conn.prepareCall(sql)) {
		27: cs.setString("prefix", "Z");
		28:
		29: try (var rs = cs.executeQuery()) {
			30: while (rs.next()) {
				31: System.out.println(rs.getString(3));
			32: }
		33: }
	34: }
```

Unlike with ``PreparedStatement``, we can use either the parameter number (starting with 1) or the parameter name. That means these two statements are equivalent:

```java
cs.setString(1, "Z");
cs.setString("prefix", "Z");
```

### Returning an ``OUT`` Parameter

Some stored procedures return other information. Luckily, stored procedures can have ``OUT`` parameters for output

```java
40: var sql = "{?= call magic_number(?) }";
41: try (var cs = conn.prepareCall(sql)) {
	42: cs.registerOutParameter(1, Types.INTEGER);
	43: cs.execute();
	44: System.out.println(cs.getInt("num"));
45: }
```

- On line 40, we include two special characters ``(?=)`` to specify that the stored procedure has an output value. This is optional since we have the ``OUT`` parameter, but it does aid in readability.
- On line 42, we register the ``OUT`` parameter. This is important. It allows JDBC to retrieve the value on line 44. **==Remember to always call ``registerOutParameter()`` for each ``OUT`` or ``INOUT`` parameter==**
- On line 43, we call ``execute()`` instead of ``executeQuery()`` since we are not returning a ``ResultSet`` from our stored procedure.

### Working with an ``INOUT`` Parameter

Finally, it is possible to use the same parameter for both input and output.

```java
50: var sql = "{call double_number(?)}";
51: try (var cs = conn.prepareCall(sql)) {
	52: cs.setInt(1, 8);
	53: cs.registerOutParameter(1, Types.INTEGER);
	54: cs.execute();
	55: System.out.println(cs.getInt("num"));
56: }
```

For an ``IN`` parameter, line 52 is required since it sets the value. For an ``OUT`` parameter, line 53 is required to register it. Line 54 uses ``execute()`` again because we are not returning a ``ResultSet``.

**==Remember that an ``INOUT`` parameter acts as both an ``IN`` parameter and an ``OUT`` parameter, so it has all the requirements of both.==**
### Comparing Callable Statement Parameters

![[Pasted image 20240616171102.png]]

### Using Additional Options

There are three ``ResultSet`` integer type values:

-  ==**``ResultSet.TYPE_FORWARD_ONLY``: Can go through the ``ResultSet`` only one row at a time**==
-  ==**``ResultSet.TYPE_SCROLL_INSENSITIVE``: Can go through the ``ResultSet`` in any order but will not see changes made to the underlying database table**==
-  ==**``ResultSet.TYPE_SCROLL_SENSITIVE``: Can go through the ``ResultSet`` in any order and will see changes made to the underlying database table==**

There are two ``ResultSet`` integer concurrency mode values:

-  ==**``ResultSet.CONCUR_READ_ONLY``: The ``ResultSet`` cannot be updated.**==
-  ==**``ResultSet.CONCUR_UPDATABLE``: The ``ResultSet`` can be updated.==**

These options are integer values, not enum values, which means you pass both as additional parameters after the SQL.

```java
conn.prepareCall(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE);
```

---

**If you see these options on the exam, pay attention to how they are used. Remember that type always comes first. Also, the methods that take type also take concurrency mode, so be wary of any question that only passes one option.**

---

## Controlling Data with Transactions

- A commit is like saving a file. On the exam, changes commit automatically unless otherwise specified. 
- A transaction is when one or more statements are grouped with the final results committed or rolled back.
- Rollback is like closing a file without saving. All the changes from the start of the transaction are discarded.

### Committing and Rolling Back

```java
public static void main(String[] args) throws SQLException {
    try (Connection conn = DriverManager.getConnection("jdbc:hsqldb:file:zoo")) {
        conn.setAutoCommit(false);

        var elephantRowsUpdated = updateRow(conn, 5, "African Elephant");
        var zebraRowsUpdated = updateRow(conn, -5, "Zebra");

        if (!elephantRowsUpdated || !zebraRowsUpdated) {
            conn.rollback();
        } else {
            String selectSql = """
                SELECT COUNT(*)
                FROM exhibits
                WHERE num_acres <= 0""";
            try (PreparedStatement ps = conn.prepareStatement(selectSql);
                 ResultSet rs = ps.executeQuery()) {

                rs.next();
                int count = rs.getInt(1);
                if (count == 0) {
                    conn.commit();
                } else {
                    conn.rollback();
                }
            }
        }
    }
}

private static boolean updateRow(Connection conn, int numToAdd, String name) throws SQLException {
    String updateSql = """
        UPDATE exhibits
        SET num_acres = num_acres + ?
        WHERE name = ?""";
    try (PreparedStatement ps = conn.prepareStatement(updateSql)) {
        ps.setInt(1, numToAdd);
        ps.setString(2, name);
        return ps.executeUpdate() > 0;
    }
}
```

The first interesting thing in this example is , where we turn off autocommit mode and declare that we will handle transactions ourselves. Most databases support disabling autocommit mode. If a database does not, it will throw a ``SQLException`` .

Assuming at least one row is updated, we check exhibits and make sure none of the rows contain an invalid ``num_acres`` value. If this were a real application, we would have more logic to make sure the amount of space makes sense. we decide whether to commit the transaction to the database or roll back all updates made to the exhibits table.

---

**Autocommit Edge Cases**

**You need to know two edge cases for the exam. First, ==calling ``setAutoCommit(true)`` will automatically trigger a commit when you are not already in autocommit mode. After that, autocommit mode takes effect, and each statement is automatically committed.==**

**The other edge case is what happens ==if you have autocommit set to ``false`` and close your connection without rolling back or committing your changes. The answer is that the behavior is undefined. It may commit or roll back, depending solely on the driver==. Don’t depend on this behavior; remember to commit or roll back at the end of a transaction!**


---
### Bookmarking with Savepoints

You can use savepoints to have more control of the rollback point

```java
20: conn.setAutoCommit(false);
21: Savepoint sp1 = conn.setSavepoint();
22: // database code
23: Savepoint sp2 = conn.setSavepoint("second savepoint");
24: // database code
25: conn.rollback(sp2);
26: // database code
27: conn.rollback(sp1);
```

- Line 20 is important. **==You can only use savepoints when you are controlling the transaction==**.

**==Order matters==**. If we reversed lines 25 and 27, the code would throw an exception. Rolling back to sp1 gets rid of any changes made after that, which includes the second savepoint! Similarly, calling ``conn.rollback()`` on line 25 would void both savepoints, and line 27 would again throw an exception.

### Reviewing Transaction APIs

![[Pasted image 20240616172205.png]]
## Closing Database Resources

JDBC resources, such as a ``Connection``, are expensive to create. Not closing them creates a resource leak that will eventually slow your program.

**==The resources need to be closed in a specific order. The ``ResultSet`` is closed first, followed by the ``PreparedStatement`` (or ``CallableStatement``) and then the ``Connection``.==**

While it is a good habit to close all three resources, it isn’t strictly necessary. Closing a JDBC resource should close any resources that it created. In particular, the following are true:

-  ==**Closing a ``Connection`` also closes ``PreparedStatement`` (or ``CallableStatement``) and ``ResultSet``.**==
-  ==**Closing a ``PreparedStatement`` (or ``CallableStatement``) also closes the ``ResultSet``.==**



## Summary #OCP_Summary 

**==There are four key SQL statements you should know for the exam, one for each of the CRUD operations: create (INSERT) a new row, read (SELECT) data, update (UPDATE) one or more rows, and delete (DELETE) one or more rows.**==

==**For the exam, you should be familiar with five JDBC interfaces: ``Driver``, ``Connection``, ``PreparedStatement``, ``CallableStatement``, and ``ResultSet``. The interfaces are part of the Java API. A database-specific JAR file provides the implementations.**==

==**To connect to a database, you need the JDBC URL. A JDBC URL has three parts separated by colons. The first part is jdbc. The second part is the name of the vendor/product. The third part varies by database, but it includes the location and/or name of the database. The location is either localhost or an IP address followed by an optional port. The ``DriverManager`` class provides a factory method called ``getConnection()`` to get a Connection implementation.**==

==**You create a ``PreparedStatement`` or ``CallableStatement`` using ``prepareStatement()`` and ``prepareCall()``, respectively. A ``PreparedStatement`` is used when the SQL is specified in your application, and a ``CallableStatement`` is used when the SQL is in the database. A ``PreparedStatement`` allows you to set the values of bind variables. A ``CallableStatement`` also allows you to set IN, OUT, and INOUT parameters.**==

==**When running a SELECT SQL statement, the ``executeQuery()`` method returns a ``ResultSet``. When running a DELETE, INSERT, or UPDATE SQL statement, the ``executeUpdate()`` method returns the number of rows that were affected. There is also an ``execute()`` method that returns a boolean to indicate whether the statement was a query.**==

==**You call ``rs.next()`` from an if statement or while loop to advance the cursor position. To get data from a column, call a method like ``getString(1)`` or ``getString("a")``. Column indexes begin with 1, not 0. In addition to getting a String or primitive, you can call ``getObject()`` to get any type.**==

==**JDBC lets you choose whether to automatically commit your statements or manage transactions yourself. If you choose the latter, you can control when data is committed or rolled back. Additionally, you can set savepoints to roll back to specific points.**==

==**It is important to close JDBC resources when finished with them to avoid leaking resources. Closing a ``Connection`` automatically closes the ``Statement`` and ``ResultSet`` objects. Closing a ``Statement`` automatically closes the ``ResultSet`` object. Also, running another SQL statement closes the previous ``ResultSet`` object from that ``Statement``.==**

## Exam Essentials #Essential 

**Name the core five JDBC interfaces that you need to know for the exam and where they are defined**. The five key interfaces are Driver, ``Connection``, ``PreparedStatement``, ``CallableStatement``, and ``ResultSet``. The interfaces are part of the core Java APIs. The implementations are part of a database driver JAR file.

**Identify correct and incorrect JDBC URLs**. A JDBC URL starts with jdbc:, followed by the vendor/product name. Next comes another colon and then a database-specific connection string. This database-specific string includes the location, such as localhost or an IP address with an optional port. It may also contain the name of the database.

**Describe how to get a Connection using ``DriverManager``**. After including the driver JAR in the classpath, call ``DriverManager.getConnection(url)`` or ``DriverManager.getConnection(url, username, password)`` to get a driver-specific ``Connection`` implementation class.

**Run queries using a ``PreparedStatement``**. When using a ``PreparedStatement``, the SQL contains question marks (?) for the parameters or bind variables. This SQL is passed at the time the ``PreparedStatement`` is created, not when it is run. You must call a setter for each of these with the proper value before executing the query.
 
 **Loop through a ``ResultSet``**. Before trying to get data from a ``ResultSet``, you call ``rs.next()`` inside an if statement or while loop. This ensures that the cursor is in a valid position. To get data from a column, call a method like ``getString(1)`` or ``getString("a")``. Remember that column indexes begin with 1.
 
**Work with transactions**. When autocommit is false, the ``commit()`` and ``rollback()`` methods control the transaction. There is an overloaded rollback method taking a ``Savepoint`` to roll back to a specific point.

**Identify when a resource should be closed**. If you’re closing all three resources, the ``ResultSet`` must be closed first, followed by the ``PreparedStatement``/ ``CallableStatement``, and the ``Connection``.

## Review Questions

1. Which interfaces or classes are in a database-specific JAR file? (Choose all that apply.)

A. Driver
B. Driver’s implementation
C. Manager
D. DriverManager’s implementation
E. PreparedStatement
F. PreparedStatement implementation

**The Driver and PreparedStatement interfaces are part of the JDK, making options A and E incorrect. Option C is incorrect because we made it up. The concrete DriverManager class is also part of the JDK, making option D incorrect. Options B and F are correct since the implementation of these interfaces is part of the database-specific driver JAR file.**

---

2. Which of the following is a valid JDBC URL?

A. jdbc:sybase:localhost:1234/db
B. jdbc::sybase::localhost::/db
C. jdbc::sybase:localhost::1234/db
D. sybase:localhost:1234/db
E. sybase::localhost::/db
F. sybase::localhost::1234/db

**A JDBC URL has three main parts separated by single colons, making options B, C, E, and F incorrect. The first part is always jdbc, making option D incorrect. Therefore, the correct answer is option A. Notice that you can get this right even if you’ve never heard of the Sybase database before.**

---

3. Which of the options can fill in the blank to make the code compile and run without error? (Choose all that apply.)

```java
var sql = """
UPDATE habitat SET environment = null
WHERE environment = ? """;
try (var ps = conn.prepareStatement(sql)) {
??
ps.executeUpdate();
}
```

A. ps.setString(0, "snow");
B. ps.setString(1, "snow");
C. ps.setString("environment", "snow");
D. ps.setString(1, "snow"); ps.setString(1, "snow");
E. ps.setString(1, "snow"); ps.setString(2, "snow");
F. ps.setString("environment", "snow"); ps.setString("environment", "snow");

**When setting parameters on a PreparedStatement, there are only options that take an index, making options C and F incorrect. The indexing starts with 1, making option A incorrect. This query has only one parameter, so option E is also incorrect. Option B is correct because it simply sets the parameter. Option D is also correct because it sets the parameter and then immediately overwrites it with the same value.**

---

4. Suppose that you have a table named animal with two rows. What is the result of the following code?

```java
6: var conn = new Connection(url, userName, password);
7: var ps = conn.prepareStatement(
8: "SELECT count(*) FROM animal");
9: var rs = ps.executeQuery();
10: if (rs.next()) System.out.println(rs.getInt(1));
```

A. 0
B. 2
C. There is a compiler error on line 6.
D. There is a compiler error on line 10.
E. There is a compiler error on another line.
F. A runtime exception is thrown.

**A Connection is created using a static method on DriverManager. It does not use a constructor. Therefore, option C is correct. If the Connection was created properly, the answer would be option B.**

---

5. Which option can fill in the blanks to make the code compile?

```java
boolean bool = ps. ();
int num = ps. ();
ResultSet rs = ps. ();
```

A. execute, executeQuery, executeUpdate
B. execute, executeUpdate, executeQuery
C. executeQuery, execute, executeUpdate
D. executeQuery, executeUpdate, execute
E. executeUpdate, execute, executeQuery
F. executeUpdate, executeQuery, execute
 
 **The first line has a return type of boolean, making it an execute() call. The second line returns the number of modified rows, making it an executeUpdate() call. The third line returns the results of a query, making it an executeQuery() call. Therefore, option B is the answer.**

---

6. Suppose there are two rows in the table before this code is run, and executeUpdate() runs without error. How many rows are in the table after the code completes?

```java
conn.setAutoCommit(true);
String sql = "INSERT INTO games VALUES(3, Jenga);";
try (PreparedStatement ps = conn.prepareStatement(sql,
ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)) {
ps.executeUpdate();
}
conn.rollback();
```

A. Two
B. Three
C. The code does not compile.
D. The code throws an exception.

**The first line enables autocommit mode. This is the default and means to commit immediately after each update. When the rollback() runs, there are no uncommitted statements, so there is nothing to roll back. This gives us the initial two rows in addition to the inserted one making option B correct. If setAutoCommit(false) were called, option A would be the answer. The ResultSet types are just there to mislead you. Any types are valid for executeUpdate() since no ResultSet is involved.**

---

7. Suppose that the table names has five rows and the following SQL statement updates all of them. What is the result of this code?

```java
public static void main(String[] args) throws SQLException {
var sql = "UPDATE names SET name = 'Animal'";
try (var conn = DriverManager.getConnection("jdbc:hsqldb:file:zoo");
var ps = conn.prepareStatement(sql)) {
var result = ps.executeUpdate();
System.out.println(result);
}
}
```

A. 0
B. 1
C. 5
D. The code does not compile.
E. A SQLException is thrown.
F. A different exception is thrown.

**This code works as expected. It updates each of the five rows in the table and returns the number of rows updated. Therefore, option C is correct.**

---

8.  Suppose learn() is a stored procedure that takes one IN parameter. What is wrong with the following code? (Choose all that apply.)

```java
18: var sql = "call learn()";
19: try (var cs = conn.prepareCall(sql)) {
20: cs.setString(1, "java");
21: try (var rs = cs.executeQuery()) {
22: while (rs.next())
23: System.out.println(rs.getString(3));
24: }
25: }
```

A. Line 18 is missing braces.
B. Line 18 is missing a ?.
C. Line 19 is not allowed to use var.
D. Line 20 does not compile.
E. Line 22 does not compile.
F. Something else is wrong with the code.
G. None of the above. This code is correct.

**Option A is one of the answers because you are supposed to use braces ({}) for all SQL in a CallableStatement. Option B is the other answer because each parameter should be passed with a question mark (?). The rest of the code is correct. Note that your database might not behave the way that’s described here, but you still need to know this syntax for the exam.**

---

9. Suppose that the table enrichment has three rows with the animals bat, rat, and snake. How many lines does this code print?

```java
var sql = "SELECT toy FROM enrichment WHERE animal = ?";
try (var ps = conn.prepareStatement(sql)) {
try (var rs = ps.executeQuery()) {
while (rs.next())
System.out.println(rs.getString(1));
}
}
```

A. 0
B. 1
C. 3
D. The code does not compile.
E. A SQLException is thrown.
F. A different exception is thrown.

**This code declares a bind variable with ? but never assigns a value to it. The compiler does not enforce bind variables have values, so the code compiles, but produces a SQLException at runtime, making option E correct.**

---

10. Suppose that the table food has five rows, and this SQL statement updates all of them. What is the result of this code?

```java
public static void main(String[] args) {
var sql = "UPDATE food SET amount = amount + 1";
try (var conn = DriverManager.getConnection("jdbc:hsqldb:file:zoo");
var ps = conn.prepareStatement(sql)) {
var result = ps.executeUpdate();
System.out.println(result);
}
}
```

A. 0
B. 1
C. 5
D. The code does not compile.
E. A SQLException is thrown.
F. A different exception is thrown.

**JDBC code throws a SQLException, which is a checked exception. The code does not handle or declare this exception, and therefore it doesn’t compile. Since the code doesn’t compile, option D is correct. If the exception were handled or declared, the answer would be option C.**

---

11. Suppose we have a JDBC program that calls a stored procedure, which returns a set of results. Which is the correct order in which to close database resources for this call?

A. Connection, ResultSet, CallableStatement
B. Connection, CallableStatement, ResultSet
C. ResultSet, Connection, CallableStatement
D. ResultSet, CallableStatement, Connection
E. CallableStatement, Connection, ResultSet
F. CallableStatement, ResultSet, Connection

**JDBC resources should be closed in the reverse order from that in which they were opened. The order for opening is Connection, CallableStatement, and ResultSet. The order for closing is ResultSet, CallableStatement, and Connection, which is option D.**

---

12.  Suppose that the table counts has five rows with the numbers 1 to 5. How many lines does this code print? 

```java
var sql = "SELECT num FROM counts WHERE num> ?";
try (var ps = conn.prepareStatement(sql,
ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE)) {
ps.setInt(1, 3);
try (var rs = ps.executeQuery()) {
while (rs.next())
System.out.println(rs.getObject(1));
}
ps.setInt(1, 100);
try (var rs = ps.executeQuery()) {
while (rs.next())
System.out.println(rs.getObject(1));
}
}
```

A. 0
B. 1
C. 2
D. 4
E. The code does not compile.
F. The code throws an exception.

**This code calls the PreparedStatement twice. The first time, it gets the numbers greater than 3. Since there are two such numbers, it prints two lines. The second time, it gets the numbers greater than 100. There are no such numbers, so the ResultSet is empty. Two lines are printed in total, making option C correct. The ResultSet options are just there to trick you since only the default settings are used by the rest of the code.**

---

13. Which of the following can fill in the blank correctly? (Choose all that apply.)

```java
var rs = ps.executeQuery();
if (rs.next())
??
```

A. String s = rs.getString(0)
B. String s = rs.getString(1)
C. String s = rs.getObject(0)
D. String s = rs.getObject(1)
E. Object s = rs.getObject(0)
F. Object s = rs.getObject(1)

**In a ResultSet, columns are indexed starting with 1, not 0. Therefore, options A, C, and E are incorrect. There are methods to get the column as a String or Object. However, option D is incorrect because an Object cannot be assigned to a String without a cast.**

---

14. Suppose learn() is a stored procedure that takes one IN parameter and one OUT parameter. What is wrong with the following code? (Choose all that apply.)

```java
18: var sql = "{?= call learn(?)}";
19: try (var cs = conn.prepareCall(sql)) {
20: cs.setInt(1, 8);
21: cs.execute();
22: System.out.println(cs.getInt(1));
23: }
```

A. Line 18 does not call the stored procedure properly.
B. The parameter value is not set for input.
C. The parameter is not registered for output.
D. The code does not compile.
E. Something else is wrong with the code.
F. None of the above. This code is correct.

**Since an OUT parameter is used, the code should call registerOutParameter(). Since this is missing, option C is correct.**

---

15. Which can fill in the blank and have the code run without error? (Choose all that apply.)

```java
17: conn.setAutoCommit(false);
18:
19: var larry = conn.setSavepoint();
20: var curly = conn.setSavepoint();
21: var moe = conn.setSavepoint();
22: var shemp = conn.setSavepoint();
23:
24: ??;
25:
26: conn.rollback(curly);
```

A. conn.rollback(larry)
B. conn.rollback(curly)
C. conn.rollback(moe)
D. conn.rollback(shemp)
E. conn.rollback()
F. The code does not compile.

**Rolling back to a point invalidates any savepoints created after it. Options A and E are incorrect because they roll back to lines 19 and 17, respectively. Option B is incorrect because you cannot roll back to the same savepoint twice. Options C and D are the answers because those savepoints were created after curly**

---

16. Which of the following can fill in the blank? (Choose all that apply.)

```java
var sql = " ";
try (var ps = conn.prepareStatement(sql)) {
ps.setObject(3, "red");
ps.setInt(2, 8);
ps.setString(1, "ball");
ps.executeUpdate();
}
```

A. { call insert_toys(?, ?) }
B. { call insert_toys(?, ?, ?) }
C. { call insert_toys(?, ?, ?, ?) }
D. INSERT INTO toys VALUES (?, ?)
E. INSERT INTO toys VALUES (?, ?, ?)
F. INSERT INTO toys VALUES (?, ?, ?, ?)

**First, notice that this code uses a PreparedStatement. Options A, B, and C are incorrect because they are for a CallableStatement. Next, remember that the number of parameters must be an exact match, making option E correct. Remember that you will not be tested on SQL syntax. When you see a question that appears to be about SQL, think about what it might be trying to test you on.**

---

17. Suppose that the table counts has five rows with the numbers 1 to 5. How many lines does this code print?

```java
var sql = "SELECT num FROM counts WHERE num> ?";
try (var ps = conn.prepareStatement(sql)) {
ps.setInt(1, 3);
try (var rs = ps.executeQuery()) {
while (rs.next())
System.out.println(rs.getObject(1));
}
try (var rs = ps.executeQuery()) {
while (rs.next())
System.out.println(rs.getObject(1));
}
}
```

A. 0
B. 1
C. 2
D. 4
E. The code does not compile.
F. The code throws an exception.

**This code calls the PreparedStatement twice. The first time, it gets the numbers greater than 3. Since there are two such numbers, it prints two lines. Since the parameter is not set between the first and second calls, the second attempt also prints two rows. Four lines are printed in total, making option D correct.**

---

18. There are currently 100 rows in the table species before inserting a new row. What is the output of the following code?

```java
String insert = "INSERT INTO species VALUES (3, 'Ant', .05)";
String select = "SELECT count(*) FROM species";
try (var ps = conn.prepareStatement(insert)) {
ps.executeUpdate();
}
try (var ps = conn.prepareStatement(select)) {
var rs = ps.executeQuery();
System.out.println(rs.getInt(1));
}
```

A. 100
B. 101
C. The code does not compile.
D. A SQLException is thrown.
E. A different exception is thrown.

**Before accessing data from a ResultSet, the cursor needs to be positioned. The call to rs.next() is missing from this code causing a SQLException and option D to be correct.**

---

19. Which of the options can fill in the blank to make the code compile and run without error? (Choose all that apply.)

```java
var sql = "UPDATE habitat WHERE environment = ?";
try (var ps = conn.prepareCall(sql)) {
??
ps.executeUpdate();
}
```

A. ps.setString(0, "snow");
B. ps.setString(1, "snow");
C. ps.setString("environment", "snow");
D. The code does not compile.
E. The code throws an exception at runtime.
 
 **This code should call prepareStatement() instead of prepareCall() since it is not executing a stored procedure. Since we are using var, it does compile. Java will happily create a CallableStatement for you. Since this compile safety is lost, the code will not cause issues until runtime. At that point, Java will complain that you are trying to execute SQL as if it were a stored procedure, making option E correct.**

---

20. Which is the first line containing a compiler error?

```java
25: String url = "jdbc:hsqldb:file:zoo";
26: try (var conn = DriverManager.getConnection(url);
27: var ps = conn.prepareStatement();
28: var rs = ps.executeQuery("SELECT * FROM swings")) {
29: while (rs.next()) {
30: System.out.println(rs.getInteger(1));
31: }
32: }
```


A. Line 26
B. Line 27
C. Line 28
D. Line 29
E. Line 30
F. None of the above

**The prepareStatement() method requires SQL to be passed in. Since this parameteris omitted, line 27 does not compile, and option B is correct.**

---

21. Suppose conn is a valid connection object and the exhibits table is empty. Which are true? (Choose two.)

```java
try (conn) {
conn.setAutoCommit(false);
String sql = "INSERT INTO exhibits VALUES(3, 'Test', 2)";
try (PreparedStatement ps = conn.prepareStatement(sql)) {
ps.executeUpdate();
}
conn.setAutoCommit(true); // line W
}
```

A. As written, the table will remain empty after this code.
B. As written, the table will contain one row after this code.
C. As written, the code will throw an exception.
D. When line W is commented out, the table will remain empty after this code.
E. When line W is commented out, the table will contain one row after this code.
F. When line W is commented out, the code will throw an exception.

**The code starts with autocommit off. As written, we turn autocommit mode back on and immediately commit the transaction. This is option B. When line W is commented out, the update gets lost, making option D the other answer.**

